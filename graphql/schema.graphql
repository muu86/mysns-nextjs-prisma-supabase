# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type Query {
  aggregateAccount(
    where: AccountWhereInput
    orderBy: [AccountOrderByWithRelationInput!]
    cursor: AccountWhereUniqueInput
    take: Int
    skip: Int
  ): AggregateAccount!
  findFirstAccount(
    where: AccountWhereInput
    orderBy: [AccountOrderByWithRelationInput!]
    cursor: AccountWhereUniqueInput
    take: Int
    skip: Int
    distinct: [AccountScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): Account
  findFirstAccountOrThrow(
    where: AccountWhereInput
    orderBy: [AccountOrderByWithRelationInput!]
    cursor: AccountWhereUniqueInput
    take: Int
    skip: Int
    distinct: [AccountScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): Account
  accounts(
    where: AccountWhereInput
    orderBy: [AccountOrderByWithRelationInput!]
    cursor: AccountWhereUniqueInput
    take: Int
    skip: Int
    distinct: [AccountScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): [Account!]!
  account(where: AccountWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): Account
  getAccount(where: AccountWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): Account
  groupByAccount(
    where: AccountWhereInput
    orderBy: [AccountOrderByWithAggregationInput!]
    by: [AccountScalarFieldEnum!]!
    having: AccountScalarWhereWithAggregatesInput
    take: Int
    skip: Int
  ): [AccountGroupBy!]!
  aggregateAddress(
    where: AddressWhereInput
    orderBy: [AddressOrderByWithRelationInput!]
    cursor: AddressWhereUniqueInput
    take: Int
    skip: Int
  ): AggregateAddress!
  findFirstAddress(
    where: AddressWhereInput
    orderBy: [AddressOrderByWithRelationInput!]
    cursor: AddressWhereUniqueInput
    take: Int
    skip: Int
    distinct: [AddressScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): Address
  findFirstAddressOrThrow(
    where: AddressWhereInput
    orderBy: [AddressOrderByWithRelationInput!]
    cursor: AddressWhereUniqueInput
    take: Int
    skip: Int
    distinct: [AddressScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): Address
  addresses(
    where: AddressWhereInput
    orderBy: [AddressOrderByWithRelationInput!]
    cursor: AddressWhereUniqueInput
    take: Int
    skip: Int
    distinct: [AddressScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): [Address!]!
  address(where: AddressWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): Address
  getAddress(where: AddressWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): Address
  groupByAddress(
    where: AddressWhereInput
    orderBy: [AddressOrderByWithAggregationInput!]
    by: [AddressScalarFieldEnum!]!
    having: AddressScalarWhereWithAggregatesInput
    take: Int
    skip: Int
  ): [AddressGroupBy!]!
  aggregateChat(
    where: ChatWhereInput
    orderBy: [ChatOrderByWithRelationInput!]
    cursor: ChatWhereUniqueInput
    take: Int
    skip: Int
  ): AggregateChat!
  findFirstChat(
    where: ChatWhereInput
    orderBy: [ChatOrderByWithRelationInput!]
    cursor: ChatWhereUniqueInput
    take: Int
    skip: Int
    distinct: [ChatScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): Chat
  findFirstChatOrThrow(
    where: ChatWhereInput
    orderBy: [ChatOrderByWithRelationInput!]
    cursor: ChatWhereUniqueInput
    take: Int
    skip: Int
    distinct: [ChatScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): Chat
  chats(
    where: ChatWhereInput
    orderBy: [ChatOrderByWithRelationInput!]
    cursor: ChatWhereUniqueInput
    take: Int
    skip: Int
    distinct: [ChatScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): [Chat!]!
  chat(where: ChatWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): Chat
  getChat(where: ChatWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): Chat
  groupByChat(
    where: ChatWhereInput
    orderBy: [ChatOrderByWithAggregationInput!]
    by: [ChatScalarFieldEnum!]!
    having: ChatScalarWhereWithAggregatesInput
    take: Int
    skip: Int
  ): [ChatGroupBy!]!
  aggregateChatMessage(
    where: ChatMessageWhereInput
    orderBy: [ChatMessageOrderByWithRelationInput!]
    cursor: ChatMessageWhereUniqueInput
    take: Int
    skip: Int
  ): AggregateChatMessage!
  findFirstChatMessage(
    where: ChatMessageWhereInput
    orderBy: [ChatMessageOrderByWithRelationInput!]
    cursor: ChatMessageWhereUniqueInput
    take: Int
    skip: Int
    distinct: [ChatMessageScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): ChatMessage
  findFirstChatMessageOrThrow(
    where: ChatMessageWhereInput
    orderBy: [ChatMessageOrderByWithRelationInput!]
    cursor: ChatMessageWhereUniqueInput
    take: Int
    skip: Int
    distinct: [ChatMessageScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): ChatMessage
  chatMessages(
    where: ChatMessageWhereInput
    orderBy: [ChatMessageOrderByWithRelationInput!]
    cursor: ChatMessageWhereUniqueInput
    take: Int
    skip: Int
    distinct: [ChatMessageScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): [ChatMessage!]!
  chatMessage(where: ChatMessageWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): ChatMessage
  getChatMessage(where: ChatMessageWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): ChatMessage
  groupByChatMessage(
    where: ChatMessageWhereInput
    orderBy: [ChatMessageOrderByWithAggregationInput!]
    by: [ChatMessageScalarFieldEnum!]!
    having: ChatMessageScalarWhereWithAggregatesInput
    take: Int
    skip: Int
  ): [ChatMessageGroupBy!]!
  aggregateChatUser(
    where: ChatUserWhereInput
    orderBy: [ChatUserOrderByWithRelationInput!]
    cursor: ChatUserWhereUniqueInput
    take: Int
    skip: Int
  ): AggregateChatUser!
  findFirstChatUser(
    where: ChatUserWhereInput
    orderBy: [ChatUserOrderByWithRelationInput!]
    cursor: ChatUserWhereUniqueInput
    take: Int
    skip: Int
    distinct: [ChatUserScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): ChatUser
  findFirstChatUserOrThrow(
    where: ChatUserWhereInput
    orderBy: [ChatUserOrderByWithRelationInput!]
    cursor: ChatUserWhereUniqueInput
    take: Int
    skip: Int
    distinct: [ChatUserScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): ChatUser
  chatUsers(
    where: ChatUserWhereInput
    orderBy: [ChatUserOrderByWithRelationInput!]
    cursor: ChatUserWhereUniqueInput
    take: Int
    skip: Int
    distinct: [ChatUserScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): [ChatUser!]!
  chatUser(where: ChatUserWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): ChatUser
  getChatUser(where: ChatUserWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): ChatUser
  groupByChatUser(
    where: ChatUserWhereInput
    orderBy: [ChatUserOrderByWithAggregationInput!]
    by: [ChatUserScalarFieldEnum!]!
    having: ChatUserScalarWhereWithAggregatesInput
    take: Int
    skip: Int
  ): [ChatUserGroupBy!]!
  aggregateComment(
    where: CommentWhereInput
    orderBy: [CommentOrderByWithRelationInput!]
    cursor: CommentWhereUniqueInput
    take: Int
    skip: Int
  ): AggregateComment!
  findFirstComment(
    where: CommentWhereInput
    orderBy: [CommentOrderByWithRelationInput!]
    cursor: CommentWhereUniqueInput
    take: Int
    skip: Int
    distinct: [CommentScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): Comment
  findFirstCommentOrThrow(
    where: CommentWhereInput
    orderBy: [CommentOrderByWithRelationInput!]
    cursor: CommentWhereUniqueInput
    take: Int
    skip: Int
    distinct: [CommentScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): Comment
  comments(
    where: CommentWhereInput
    orderBy: [CommentOrderByWithRelationInput!]
    cursor: CommentWhereUniqueInput
    take: Int
    skip: Int
    distinct: [CommentScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): [Comment!]!
  comment(where: CommentWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): Comment
  getComment(where: CommentWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): Comment
  groupByComment(
    where: CommentWhereInput
    orderBy: [CommentOrderByWithAggregationInput!]
    by: [CommentScalarFieldEnum!]!
    having: CommentScalarWhereWithAggregatesInput
    take: Int
    skip: Int
  ): [CommentGroupBy!]!
  aggregateFile(
    where: FileWhereInput
    orderBy: [FileOrderByWithRelationInput!]
    cursor: FileWhereUniqueInput
    take: Int
    skip: Int
  ): AggregateFile!
  findFirstFile(
    where: FileWhereInput
    orderBy: [FileOrderByWithRelationInput!]
    cursor: FileWhereUniqueInput
    take: Int
    skip: Int
    distinct: [FileScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): File
  findFirstFileOrThrow(
    where: FileWhereInput
    orderBy: [FileOrderByWithRelationInput!]
    cursor: FileWhereUniqueInput
    take: Int
    skip: Int
    distinct: [FileScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): File
  files(
    where: FileWhereInput
    orderBy: [FileOrderByWithRelationInput!]
    cursor: FileWhereUniqueInput
    take: Int
    skip: Int
    distinct: [FileScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): [File!]!
  file(where: FileWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): File
  getFile(where: FileWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): File
  groupByFile(
    where: FileWhereInput
    orderBy: [FileOrderByWithAggregationInput!]
    by: [FileScalarFieldEnum!]!
    having: FileScalarWhereWithAggregatesInput
    take: Int
    skip: Int
  ): [FileGroupBy!]!
  aggregatePost(
    where: PostWhereInput
    orderBy: [PostOrderByWithRelationInput!]
    cursor: PostWhereUniqueInput
    take: Int
    skip: Int
  ): AggregatePost!
  findFirstPost(
    where: PostWhereInput
    orderBy: [PostOrderByWithRelationInput!]
    cursor: PostWhereUniqueInput
    take: Int
    skip: Int
    distinct: [PostScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): Post
  findFirstPostOrThrow(
    where: PostWhereInput
    orderBy: [PostOrderByWithRelationInput!]
    cursor: PostWhereUniqueInput
    take: Int
    skip: Int
    distinct: [PostScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): Post
  posts(
    where: PostWhereInput
    orderBy: [PostOrderByWithRelationInput!]
    cursor: PostWhereUniqueInput
    take: Int
    skip: Int
    distinct: [PostScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): [Post!]!
  post(where: PostWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): Post
  getPost(where: PostWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): Post
  groupByPost(
    where: PostWhereInput
    orderBy: [PostOrderByWithAggregationInput!]
    by: [PostScalarFieldEnum!]!
    having: PostScalarWhereWithAggregatesInput
    take: Int
    skip: Int
  ): [PostGroupBy!]!
  aggregatePostFile(
    where: PostFileWhereInput
    orderBy: [PostFileOrderByWithRelationInput!]
    cursor: PostFileWhereUniqueInput
    take: Int
    skip: Int
  ): AggregatePostFile!
  findFirstPostFile(
    where: PostFileWhereInput
    orderBy: [PostFileOrderByWithRelationInput!]
    cursor: PostFileWhereUniqueInput
    take: Int
    skip: Int
    distinct: [PostFileScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): PostFile
  findFirstPostFileOrThrow(
    where: PostFileWhereInput
    orderBy: [PostFileOrderByWithRelationInput!]
    cursor: PostFileWhereUniqueInput
    take: Int
    skip: Int
    distinct: [PostFileScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): PostFile
  postFiles(
    where: PostFileWhereInput
    orderBy: [PostFileOrderByWithRelationInput!]
    cursor: PostFileWhereUniqueInput
    take: Int
    skip: Int
    distinct: [PostFileScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): [PostFile!]!
  postFile(where: PostFileWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): PostFile
  getPostFile(where: PostFileWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): PostFile
  groupByPostFile(
    where: PostFileWhereInput
    orderBy: [PostFileOrderByWithAggregationInput!]
    by: [PostFileScalarFieldEnum!]!
    having: PostFileScalarWhereWithAggregatesInput
    take: Int
    skip: Int
  ): [PostFileGroupBy!]!
  aggregateSession(
    where: SessionWhereInput
    orderBy: [SessionOrderByWithRelationInput!]
    cursor: SessionWhereUniqueInput
    take: Int
    skip: Int
  ): AggregateSession!
  findFirstSession(
    where: SessionWhereInput
    orderBy: [SessionOrderByWithRelationInput!]
    cursor: SessionWhereUniqueInput
    take: Int
    skip: Int
    distinct: [SessionScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): Session
  findFirstSessionOrThrow(
    where: SessionWhereInput
    orderBy: [SessionOrderByWithRelationInput!]
    cursor: SessionWhereUniqueInput
    take: Int
    skip: Int
    distinct: [SessionScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): Session
  sessions(
    where: SessionWhereInput
    orderBy: [SessionOrderByWithRelationInput!]
    cursor: SessionWhereUniqueInput
    take: Int
    skip: Int
    distinct: [SessionScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): [Session!]!
  session(where: SessionWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): Session
  getSession(where: SessionWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): Session
  groupBySession(
    where: SessionWhereInput
    orderBy: [SessionOrderByWithAggregationInput!]
    by: [SessionScalarFieldEnum!]!
    having: SessionScalarWhereWithAggregatesInput
    take: Int
    skip: Int
  ): [SessionGroupBy!]!
  aggregateSpatial_ref_sys(
    where: Spatial_ref_sysWhereInput
    orderBy: [Spatial_ref_sysOrderByWithRelationInput!]
    cursor: Spatial_ref_sysWhereUniqueInput
    take: Int
    skip: Int
  ): AggregateSpatial_ref_sys!
  findFirstSpatial_ref_sys(
    where: Spatial_ref_sysWhereInput
    orderBy: [Spatial_ref_sysOrderByWithRelationInput!]
    cursor: Spatial_ref_sysWhereUniqueInput
    take: Int
    skip: Int
    distinct: [Spatial_ref_sysScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): Spatial_ref_sys
  findFirstSpatial_ref_sysOrThrow(
    where: Spatial_ref_sysWhereInput
    orderBy: [Spatial_ref_sysOrderByWithRelationInput!]
    cursor: Spatial_ref_sysWhereUniqueInput
    take: Int
    skip: Int
    distinct: [Spatial_ref_sysScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): Spatial_ref_sys
  findManySpatial_ref_sys(
    where: Spatial_ref_sysWhereInput
    orderBy: [Spatial_ref_sysOrderByWithRelationInput!]
    cursor: Spatial_ref_sysWhereUniqueInput
    take: Int
    skip: Int
    distinct: [Spatial_ref_sysScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): [Spatial_ref_sys!]!
  findUniqueSpatial_ref_sys(
    where: Spatial_ref_sysWhereUniqueInput!
    relationLoadStrategy: RelationLoadStrategy
  ): Spatial_ref_sys
  findUniqueSpatial_ref_sysOrThrow(
    where: Spatial_ref_sysWhereUniqueInput!
    relationLoadStrategy: RelationLoadStrategy
  ): Spatial_ref_sys
  groupBySpatial_ref_sys(
    where: Spatial_ref_sysWhereInput
    orderBy: [Spatial_ref_sysOrderByWithAggregationInput!]
    by: [Spatial_ref_sysScalarFieldEnum!]!
    having: Spatial_ref_sysScalarWhereWithAggregatesInput
    take: Int
    skip: Int
  ): [Spatial_ref_sysGroupBy!]!
  aggregateUser(
    where: UserWhereInput
    orderBy: [UserOrderByWithRelationInput!]
    cursor: UserWhereUniqueInput
    take: Int
    skip: Int
  ): AggregateUser!
  findFirstUser(
    where: UserWhereInput
    orderBy: [UserOrderByWithRelationInput!]
    cursor: UserWhereUniqueInput
    take: Int
    skip: Int
    distinct: [UserScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): User
  findFirstUserOrThrow(
    where: UserWhereInput
    orderBy: [UserOrderByWithRelationInput!]
    cursor: UserWhereUniqueInput
    take: Int
    skip: Int
    distinct: [UserScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): User
  users(
    where: UserWhereInput
    orderBy: [UserOrderByWithRelationInput!]
    cursor: UserWhereUniqueInput
    take: Int
    skip: Int
    distinct: [UserScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): [User!]!
  user(where: UserWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): User
  getUser(where: UserWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): User
  groupByUser(
    where: UserWhereInput
    orderBy: [UserOrderByWithAggregationInput!]
    by: [UserScalarFieldEnum!]!
    having: UserScalarWhereWithAggregatesInput
    take: Int
    skip: Int
  ): [UserGroupBy!]!
  aggregateUserAddress(
    where: UserAddressWhereInput
    orderBy: [UserAddressOrderByWithRelationInput!]
    cursor: UserAddressWhereUniqueInput
    take: Int
    skip: Int
  ): AggregateUserAddress!
  findFirstUserAddress(
    where: UserAddressWhereInput
    orderBy: [UserAddressOrderByWithRelationInput!]
    cursor: UserAddressWhereUniqueInput
    take: Int
    skip: Int
    distinct: [UserAddressScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): UserAddress
  findFirstUserAddressOrThrow(
    where: UserAddressWhereInput
    orderBy: [UserAddressOrderByWithRelationInput!]
    cursor: UserAddressWhereUniqueInput
    take: Int
    skip: Int
    distinct: [UserAddressScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): UserAddress
  userAddresses(
    where: UserAddressWhereInput
    orderBy: [UserAddressOrderByWithRelationInput!]
    cursor: UserAddressWhereUniqueInput
    take: Int
    skip: Int
    distinct: [UserAddressScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): [UserAddress!]!
  userAddress(where: UserAddressWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): UserAddress
  getUserAddress(where: UserAddressWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): UserAddress
  groupByUserAddress(
    where: UserAddressWhereInput
    orderBy: [UserAddressOrderByWithAggregationInput!]
    by: [UserAddressScalarFieldEnum!]!
    having: UserAddressScalarWhereWithAggregatesInput
    take: Int
    skip: Int
  ): [UserAddressGroupBy!]!
  aggregateUserFile(
    where: UserFileWhereInput
    orderBy: [UserFileOrderByWithRelationInput!]
    cursor: UserFileWhereUniqueInput
    take: Int
    skip: Int
  ): AggregateUserFile!
  findFirstUserFile(
    where: UserFileWhereInput
    orderBy: [UserFileOrderByWithRelationInput!]
    cursor: UserFileWhereUniqueInput
    take: Int
    skip: Int
    distinct: [UserFileScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): UserFile
  findFirstUserFileOrThrow(
    where: UserFileWhereInput
    orderBy: [UserFileOrderByWithRelationInput!]
    cursor: UserFileWhereUniqueInput
    take: Int
    skip: Int
    distinct: [UserFileScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): UserFile
  userFiles(
    where: UserFileWhereInput
    orderBy: [UserFileOrderByWithRelationInput!]
    cursor: UserFileWhereUniqueInput
    take: Int
    skip: Int
    distinct: [UserFileScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): [UserFile!]!
  userFile(where: UserFileWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): UserFile
  getUserFile(where: UserFileWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): UserFile
  groupByUserFile(
    where: UserFileWhereInput
    orderBy: [UserFileOrderByWithAggregationInput!]
    by: [UserFileScalarFieldEnum!]!
    having: UserFileScalarWhereWithAggregatesInput
    take: Int
    skip: Int
  ): [UserFileGroupBy!]!
  aggregateVerificationToken(
    where: VerificationTokenWhereInput
    orderBy: [VerificationTokenOrderByWithRelationInput!]
    cursor: VerificationTokenWhereUniqueInput
    take: Int
    skip: Int
  ): AggregateVerificationToken!
  findFirstVerificationToken(
    where: VerificationTokenWhereInput
    orderBy: [VerificationTokenOrderByWithRelationInput!]
    cursor: VerificationTokenWhereUniqueInput
    take: Int
    skip: Int
    distinct: [VerificationTokenScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): VerificationToken
  findFirstVerificationTokenOrThrow(
    where: VerificationTokenWhereInput
    orderBy: [VerificationTokenOrderByWithRelationInput!]
    cursor: VerificationTokenWhereUniqueInput
    take: Int
    skip: Int
    distinct: [VerificationTokenScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): VerificationToken
  verificationTokens(
    where: VerificationTokenWhereInput
    orderBy: [VerificationTokenOrderByWithRelationInput!]
    cursor: VerificationTokenWhereUniqueInput
    take: Int
    skip: Int
    distinct: [VerificationTokenScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
  ): [VerificationToken!]!
  verificationToken(
    where: VerificationTokenWhereUniqueInput!
    relationLoadStrategy: RelationLoadStrategy
  ): VerificationToken
  getVerificationToken(
    where: VerificationTokenWhereUniqueInput!
    relationLoadStrategy: RelationLoadStrategy
  ): VerificationToken
  groupByVerificationToken(
    where: VerificationTokenWhereInput
    orderBy: [VerificationTokenOrderByWithAggregationInput!]
    by: [VerificationTokenScalarFieldEnum!]!
    having: VerificationTokenScalarWhereWithAggregatesInput
    take: Int
    skip: Int
  ): [VerificationTokenGroupBy!]!
  postsNear(
    where: PostWhereInput
    orderBy: [PostOrderByWithRelationInput!]
    cursor: PostWhereUniqueInput
    take: Int
    skip: Int
    distinct: [PostScalarFieldEnum!]
    relationLoadStrategy: RelationLoadStrategy
    selectedAddressId: ID!
  ): [Post!]!
}

type AggregateAccount {
  _count: AccountCountAggregate
  _avg: AccountAvgAggregate
  _sum: AccountSumAggregate
  _min: AccountMinAggregate
  _max: AccountMaxAggregate
}

type AccountCountAggregate {
  type: Int!
  provider: Int!
  providerAccountId: Int!
  refresh_token: Int!
  access_token: Int!
  expires_at: Int!
  token_type: Int!
  scope: Int!
  id_token: Int!
  session_state: Int!
  createdAt: Int!
  updatedAt: Int!
  userId: Int!
  _all: Int!
}

type AccountAvgAggregate {
  expires_at: Float
  userId: Float
}

type AccountSumAggregate {
  expires_at: Int
  userId: Int
}

type AccountMinAggregate {
  type: String
  provider: String
  providerAccountId: String
  refresh_token: String
  access_token: String
  expires_at: Int
  token_type: String
  scope: String
  id_token: String
  session_state: String
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  userId: Int
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.This scalar is serialized to a string in ISO 8601 format and parsed from a string in ISO 8601 format.
"""
scalar DateTimeISO

type AccountMaxAggregate {
  type: String
  provider: String
  providerAccountId: String
  refresh_token: String
  access_token: String
  expires_at: Int
  token_type: String
  scope: String
  id_token: String
  session_state: String
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  userId: Int
}

input AccountWhereInput {
  AND: [AccountWhereInput!]
  OR: [AccountWhereInput!]
  NOT: [AccountWhereInput!]
  type: StringFilter
  provider: StringFilter
  providerAccountId: StringFilter
  refresh_token: StringNullableFilter
  access_token: StringNullableFilter
  expires_at: IntNullableFilter
  token_type: StringNullableFilter
  scope: StringNullableFilter
  id_token: StringNullableFilter
  session_state: StringNullableFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  userId: IntFilter
  user: UserRelationFilter
}

input StringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: QueryMode
  not: NestedStringFilter
}

enum QueryMode {
  default
  insensitive
}

input NestedStringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringFilter
}

input StringNullableFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: QueryMode
  not: NestedStringNullableFilter
}

input NestedStringNullableFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringNullableFilter
}

input IntNullableFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: NestedIntNullableFilter
}

input NestedIntNullableFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: NestedIntNullableFilter
}

input DateTimeFilter {
  equals: DateTimeISO
  in: [DateTimeISO!]
  notIn: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  not: NestedDateTimeFilter
}

input NestedDateTimeFilter {
  equals: DateTimeISO
  in: [DateTimeISO!]
  notIn: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  not: NestedDateTimeFilter
}

input IntFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: NestedIntFilter
}

input NestedIntFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: NestedIntFilter
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

input UserWhereInput {
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
  id: IntFilter
  content: StringNullableFilter
  babyBirth: DateTimeNullableFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  email: StringFilter
  emailVerified: DateTimeNullableFilter
  image: StringNullableFilter
  name: StringNullableFilter
  username: StringNullableFilter
  role: EnumRoleFilter
  accounts: AccountListRelationFilter
  chats: ChatUserListRelationFilter
  comments: CommentListRelationFilter
  posts: PostListRelationFilter
  sessions: SessionListRelationFilter
  addresses: UserAddressListRelationFilter
  files: UserFileListRelationFilter
  chatMessages: ChatMessageListRelationFilter
}

input DateTimeNullableFilter {
  equals: DateTimeISO
  in: [DateTimeISO!]
  notIn: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  not: NestedDateTimeNullableFilter
}

input NestedDateTimeNullableFilter {
  equals: DateTimeISO
  in: [DateTimeISO!]
  notIn: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  not: NestedDateTimeNullableFilter
}

input EnumRoleFilter {
  equals: Role
  in: [Role!]
  notIn: [Role!]
  not: NestedEnumRoleFilter
}

enum Role {
  READ
  WRITE
}

input NestedEnumRoleFilter {
  equals: Role
  in: [Role!]
  notIn: [Role!]
  not: NestedEnumRoleFilter
}

input AccountListRelationFilter {
  every: AccountWhereInput
  some: AccountWhereInput
  none: AccountWhereInput
}

input ChatUserListRelationFilter {
  every: ChatUserWhereInput
  some: ChatUserWhereInput
  none: ChatUserWhereInput
}

input ChatUserWhereInput {
  AND: [ChatUserWhereInput!]
  OR: [ChatUserWhereInput!]
  NOT: [ChatUserWhereInput!]
  id: IntFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  chatId: IntFilter
  userId: IntFilter
  chat: ChatRelationFilter
  user: UserRelationFilter
}

input ChatRelationFilter {
  is: ChatWhereInput
  isNot: ChatWhereInput
}

input ChatWhereInput {
  AND: [ChatWhereInput!]
  OR: [ChatWhereInput!]
  NOT: [ChatWhereInput!]
  id: IntFilter
  name: StringNullableFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  messages: ChatMessageListRelationFilter
  users: ChatUserListRelationFilter
}

input ChatMessageListRelationFilter {
  every: ChatMessageWhereInput
  some: ChatMessageWhereInput
  none: ChatMessageWhereInput
}

input ChatMessageWhereInput {
  AND: [ChatMessageWhereInput!]
  OR: [ChatMessageWhereInput!]
  NOT: [ChatMessageWhereInput!]
  id: IntFilter
  message: StringFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  chatId: IntFilter
  userId: IntFilter
  user: UserRelationFilter
  chat: ChatRelationFilter
}

input CommentListRelationFilter {
  every: CommentWhereInput
  some: CommentWhereInput
  none: CommentWhereInput
}

input CommentWhereInput {
  AND: [CommentWhereInput!]
  OR: [CommentWhereInput!]
  NOT: [CommentWhereInput!]
  id: IntFilter
  content: StringFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  userId: IntFilter
  postId: IntFilter
  post: PostRelationFilter
  user: UserRelationFilter
}

input PostRelationFilter {
  is: PostWhereInput
  isNot: PostWhereInput
}

input PostWhereInput {
  AND: [PostWhereInput!]
  OR: [PostWhereInput!]
  NOT: [PostWhereInput!]
  id: IntFilter
  content: StringFilter
  addressId: IntFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  userId: IntFilter
  comments: CommentListRelationFilter
  files: PostFileListRelationFilter
  address: AddressRelationFilter
  user: UserRelationFilter
}

input PostFileListRelationFilter {
  every: PostFileWhereInput
  some: PostFileWhereInput
  none: PostFileWhereInput
}

input PostFileWhereInput {
  AND: [PostFileWhereInput!]
  OR: [PostFileWhereInput!]
  NOT: [PostFileWhereInput!]
  id: IntFilter
  postId: IntFilter
  fileId: IntFilter
  status: EnumActiveStatusFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  file: FileRelationFilter
  post: PostRelationFilter
}

input EnumActiveStatusFilter {
  equals: ActiveStatus
  in: [ActiveStatus!]
  notIn: [ActiveStatus!]
  not: NestedEnumActiveStatusFilter
}

enum ActiveStatus {
  ACTIVE
  INACTIVE
}

input NestedEnumActiveStatusFilter {
  equals: ActiveStatus
  in: [ActiveStatus!]
  notIn: [ActiveStatus!]
  not: NestedEnumActiveStatusFilter
}

input FileRelationFilter {
  is: FileWhereInput
  isNot: FileWhereInput
}

input FileWhereInput {
  AND: [FileWhereInput!]
  OR: [FileWhereInput!]
  NOT: [FileWhereInput!]
  id: IntFilter
  location: StringFilter
  type: EnumFileStorageTypeFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  posts: PostFileListRelationFilter
  files: UserFileListRelationFilter
}

input EnumFileStorageTypeFilter {
  equals: FileStorageType
  in: [FileStorageType!]
  notIn: [FileStorageType!]
  not: NestedEnumFileStorageTypeFilter
}

enum FileStorageType {
  S3
}

input NestedEnumFileStorageTypeFilter {
  equals: FileStorageType
  in: [FileStorageType!]
  notIn: [FileStorageType!]
  not: NestedEnumFileStorageTypeFilter
}

input UserFileListRelationFilter {
  every: UserFileWhereInput
  some: UserFileWhereInput
  none: UserFileWhereInput
}

input UserFileWhereInput {
  AND: [UserFileWhereInput!]
  OR: [UserFileWhereInput!]
  NOT: [UserFileWhereInput!]
  id: IntFilter
  userId: IntFilter
  fileId: IntFilter
  status: EnumActiveStatusFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  file: FileRelationFilter
  user: UserRelationFilter
}

input AddressRelationFilter {
  is: AddressWhereInput
  isNot: AddressWhereInput
}

input AddressWhereInput {
  AND: [AddressWhereInput!]
  OR: [AddressWhereInput!]
  NOT: [AddressWhereInput!]
  id: IntFilter
  code: StringFilter
  c1: StringFilter
  c2: StringNullableFilter
  c3: StringNullableFilter
  c4: StringNullableFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  posts: PostListRelationFilter
  users: UserAddressListRelationFilter
}

input PostListRelationFilter {
  every: PostWhereInput
  some: PostWhereInput
  none: PostWhereInput
}

input UserAddressListRelationFilter {
  every: UserAddressWhereInput
  some: UserAddressWhereInput
  none: UserAddressWhereInput
}

input UserAddressWhereInput {
  AND: [UserAddressWhereInput!]
  OR: [UserAddressWhereInput!]
  NOT: [UserAddressWhereInput!]
  id: IntFilter
  userId: IntFilter
  addressId: IntFilter
  status: EnumActiveStatusFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  address: AddressRelationFilter
  user: UserRelationFilter
}

input SessionListRelationFilter {
  every: SessionWhereInput
  some: SessionWhereInput
  none: SessionWhereInput
}

input SessionWhereInput {
  AND: [SessionWhereInput!]
  OR: [SessionWhereInput!]
  NOT: [SessionWhereInput!]
  sessionToken: StringFilter
  expires: DateTimeFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  userId: IntFilter
  user: UserRelationFilter
}

input AccountOrderByWithRelationInput {
  type: SortOrder
  provider: SortOrder
  providerAccountId: SortOrder
  refresh_token: SortOrderInput
  access_token: SortOrderInput
  expires_at: SortOrderInput
  token_type: SortOrderInput
  scope: SortOrderInput
  id_token: SortOrderInput
  session_state: SortOrderInput
  createdAt: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
  user: UserOrderByWithRelationInput
}

enum SortOrder {
  asc
  desc
}

input SortOrderInput {
  sort: SortOrder!
  nulls: NullsOrder
}

enum NullsOrder {
  first
  last
}

input UserOrderByWithRelationInput {
  id: SortOrder
  content: SortOrderInput
  babyBirth: SortOrderInput
  createdAt: SortOrder
  updatedAt: SortOrder
  email: SortOrder
  emailVerified: SortOrderInput
  image: SortOrderInput
  name: SortOrderInput
  username: SortOrderInput
  role: SortOrder
  accounts: AccountOrderByRelationAggregateInput
  chats: ChatUserOrderByRelationAggregateInput
  comments: CommentOrderByRelationAggregateInput
  posts: PostOrderByRelationAggregateInput
  sessions: SessionOrderByRelationAggregateInput
  addresses: UserAddressOrderByRelationAggregateInput
  files: UserFileOrderByRelationAggregateInput
  chatMessages: ChatMessageOrderByRelationAggregateInput
}

input AccountOrderByRelationAggregateInput {
  _count: SortOrder
}

input ChatUserOrderByRelationAggregateInput {
  _count: SortOrder
}

input CommentOrderByRelationAggregateInput {
  _count: SortOrder
}

input PostOrderByRelationAggregateInput {
  _count: SortOrder
}

input SessionOrderByRelationAggregateInput {
  _count: SortOrder
}

input UserAddressOrderByRelationAggregateInput {
  _count: SortOrder
}

input UserFileOrderByRelationAggregateInput {
  _count: SortOrder
}

input ChatMessageOrderByRelationAggregateInput {
  _count: SortOrder
}

input AccountWhereUniqueInput {
  provider_providerAccountId: AccountProviderProviderAccountIdCompoundUniqueInput
  AND: [AccountWhereInput!]
  OR: [AccountWhereInput!]
  NOT: [AccountWhereInput!]
  type: StringFilter
  provider: StringFilter
  providerAccountId: StringFilter
  refresh_token: StringNullableFilter
  access_token: StringNullableFilter
  expires_at: IntNullableFilter
  token_type: StringNullableFilter
  scope: StringNullableFilter
  id_token: StringNullableFilter
  session_state: StringNullableFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  userId: IntFilter
  user: UserRelationFilter
}

input AccountProviderProviderAccountIdCompoundUniqueInput {
  provider: String!
  providerAccountId: String!
}

type Account {
  type: String!
  provider: String!
  providerAccountId: String!
  refresh_token: String
  access_token: String
  expires_at: Int
  token_type: String
  scope: String
  id_token: String
  session_state: String
  createdAt: DateTimeISO!
  updatedAt: DateTimeISO!
  userId: Int!
  user: User!
}

type User {
  id: ID!
  content: String
  babyBirth: DateTimeISO
  createdAt: DateTimeISO!
  updatedAt: DateTimeISO!
  email: String!
  emailVerified: DateTimeISO
  image: String
  name: String
  username: String
  role: Role!
  _count: UserCount
  accounts(
    where: AccountWhereInput
    orderBy: [AccountOrderByWithRelationInput!]
    cursor: AccountWhereUniqueInput
    take: Int
    skip: Int
    distinct: [AccountScalarFieldEnum!]
  ): [Account!]!
  chats(
    where: ChatUserWhereInput
    orderBy: [ChatUserOrderByWithRelationInput!]
    cursor: ChatUserWhereUniqueInput
    take: Int
    skip: Int
    distinct: [ChatUserScalarFieldEnum!]
  ): [ChatUser!]!
  comments(
    where: CommentWhereInput
    orderBy: [CommentOrderByWithRelationInput!]
    cursor: CommentWhereUniqueInput
    take: Int
    skip: Int
    distinct: [CommentScalarFieldEnum!]
  ): [Comment!]!
  posts(
    where: PostWhereInput
    orderBy: [PostOrderByWithRelationInput!]
    cursor: PostWhereUniqueInput
    take: Int
    skip: Int
    distinct: [PostScalarFieldEnum!]
  ): [Post!]!
  sessions(
    where: SessionWhereInput
    orderBy: [SessionOrderByWithRelationInput!]
    cursor: SessionWhereUniqueInput
    take: Int
    skip: Int
    distinct: [SessionScalarFieldEnum!]
  ): [Session!]!
  addresses(
    where: UserAddressWhereInput
    orderBy: [UserAddressOrderByWithRelationInput!]
    cursor: UserAddressWhereUniqueInput
    take: Int
    skip: Int
    distinct: [UserAddressScalarFieldEnum!]
  ): [UserAddress!]!
  files(
    where: UserFileWhereInput
    orderBy: [UserFileOrderByWithRelationInput!]
    cursor: UserFileWhereUniqueInput
    take: Int
    skip: Int
    distinct: [UserFileScalarFieldEnum!]
  ): [UserFile!]!
  chatMessages(
    where: ChatMessageWhereInput
    orderBy: [ChatMessageOrderByWithRelationInput!]
    cursor: ChatMessageWhereUniqueInput
    take: Int
    skip: Int
    distinct: [ChatMessageScalarFieldEnum!]
  ): [ChatMessage!]!
}

type UserCount {
  accounts(where: AccountWhereInput): Int!
  chats(where: ChatUserWhereInput): Int!
  comments(where: CommentWhereInput): Int!
  posts(where: PostWhereInput): Int!
  sessions(where: SessionWhereInput): Int!
  addresses(where: UserAddressWhereInput): Int!
  files(where: UserFileWhereInput): Int!
  chatMessages(where: ChatMessageWhereInput): Int!
}

enum AccountScalarFieldEnum {
  type
  provider
  providerAccountId
  refresh_token
  access_token
  expires_at
  token_type
  scope
  id_token
  session_state
  createdAt
  updatedAt
  userId
}

type ChatUser {
  id: ID!
  createdAt: DateTimeISO!
  updatedAt: DateTimeISO!
  chatId: Int!
  userId: Int!
  chat: Chat!
  user: User!
}

type Chat {
  id: ID!
  name: String
  createdAt: DateTimeISO!
  updatedAt: DateTimeISO!
  _count: ChatCount
  messages(
    where: ChatMessageWhereInput
    orderBy: [ChatMessageOrderByWithRelationInput!]
    cursor: ChatMessageWhereUniqueInput
    take: Int
    skip: Int
    distinct: [ChatMessageScalarFieldEnum!]
  ): [ChatMessage!]!
  users(
    where: ChatUserWhereInput
    orderBy: [ChatUserOrderByWithRelationInput!]
    cursor: ChatUserWhereUniqueInput
    take: Int
    skip: Int
    distinct: [ChatUserScalarFieldEnum!]
  ): [ChatUser!]!
}

type ChatCount {
  messages(where: ChatMessageWhereInput): Int!
  users(where: ChatUserWhereInput): Int!
}

type ChatMessage {
  id: ID!
  message: String!
  createdAt: DateTimeISO!
  updatedAt: DateTimeISO!
  chatId: Int!
  userId: Int!
  user: User!
  chat: Chat!
}

input ChatMessageOrderByWithRelationInput {
  id: SortOrder
  message: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  chatId: SortOrder
  userId: SortOrder
  user: UserOrderByWithRelationInput
  chat: ChatOrderByWithRelationInput
}

input ChatOrderByWithRelationInput {
  id: SortOrder
  name: SortOrderInput
  createdAt: SortOrder
  updatedAt: SortOrder
  messages: ChatMessageOrderByRelationAggregateInput
  users: ChatUserOrderByRelationAggregateInput
}

input ChatMessageWhereUniqueInput {
  id: Int
  AND: [ChatMessageWhereInput!]
  OR: [ChatMessageWhereInput!]
  NOT: [ChatMessageWhereInput!]
  message: StringFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  chatId: IntFilter
  userId: IntFilter
  user: UserRelationFilter
  chat: ChatRelationFilter
}

enum ChatMessageScalarFieldEnum {
  id
  message
  createdAt
  updatedAt
  chatId
  userId
}

input ChatUserOrderByWithRelationInput {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  chatId: SortOrder
  userId: SortOrder
  chat: ChatOrderByWithRelationInput
  user: UserOrderByWithRelationInput
}

input ChatUserWhereUniqueInput {
  id: Int
  AND: [ChatUserWhereInput!]
  OR: [ChatUserWhereInput!]
  NOT: [ChatUserWhereInput!]
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  chatId: IntFilter
  userId: IntFilter
  chat: ChatRelationFilter
  user: UserRelationFilter
}

enum ChatUserScalarFieldEnum {
  id
  createdAt
  updatedAt
  chatId
  userId
}

type Comment {
  id: ID!
  content: String!
  createdAt: DateTimeISO!
  updatedAt: DateTimeISO!
  userId: Int!
  postId: Int!
  post: Post!
  user: User!
}

type Post {
  id: ID!
  content: String!
  addressId: Int!
  createdAt: DateTimeISO!
  updatedAt: DateTimeISO!
  userId: Int!
  _count: PostCount
  comments(
    where: CommentWhereInput
    orderBy: [CommentOrderByWithRelationInput!]
    cursor: CommentWhereUniqueInput
    take: Int
    skip: Int
    distinct: [CommentScalarFieldEnum!]
  ): [Comment!]!
  files(
    where: PostFileWhereInput
    orderBy: [PostFileOrderByWithRelationInput!]
    cursor: PostFileWhereUniqueInput
    take: Int
    skip: Int
    distinct: [PostFileScalarFieldEnum!]
  ): [PostFile!]!
  address: Address!
  user: User!
}

type PostCount {
  comments(where: CommentWhereInput): Int!
  files(where: PostFileWhereInput): Int!
}

input CommentOrderByWithRelationInput {
  id: SortOrder
  content: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
  postId: SortOrder
  post: PostOrderByWithRelationInput
  user: UserOrderByWithRelationInput
}

input PostOrderByWithRelationInput {
  id: SortOrder
  content: SortOrder
  addressId: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
  comments: CommentOrderByRelationAggregateInput
  files: PostFileOrderByRelationAggregateInput
  address: AddressOrderByWithRelationInput
  user: UserOrderByWithRelationInput
}

input PostFileOrderByRelationAggregateInput {
  _count: SortOrder
}

input AddressOrderByWithRelationInput {
  id: SortOrder
  code: SortOrder
  c1: SortOrder
  c2: SortOrderInput
  c3: SortOrderInput
  c4: SortOrderInput
  createdAt: SortOrder
  updatedAt: SortOrder
  posts: PostOrderByRelationAggregateInput
  users: UserAddressOrderByRelationAggregateInput
}

input CommentWhereUniqueInput {
  id: Int
  AND: [CommentWhereInput!]
  OR: [CommentWhereInput!]
  NOT: [CommentWhereInput!]
  content: StringFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  userId: IntFilter
  postId: IntFilter
  post: PostRelationFilter
  user: UserRelationFilter
}

enum CommentScalarFieldEnum {
  id
  content
  createdAt
  updatedAt
  userId
  postId
}

type PostFile {
  id: ID!
  postId: Int!
  fileId: Int!
  status: ActiveStatus!
  createdAt: DateTimeISO!
  updatedAt: DateTimeISO!
  file: File!
  post: Post!
}

type File {
  id: ID!
  location: String!
  type: FileStorageType!
  createdAt: DateTimeISO!
  updatedAt: DateTimeISO!
  _count: FileCount
  posts(
    where: PostFileWhereInput
    orderBy: [PostFileOrderByWithRelationInput!]
    cursor: PostFileWhereUniqueInput
    take: Int
    skip: Int
    distinct: [PostFileScalarFieldEnum!]
  ): [PostFile!]!
  files(
    where: UserFileWhereInput
    orderBy: [UserFileOrderByWithRelationInput!]
    cursor: UserFileWhereUniqueInput
    take: Int
    skip: Int
    distinct: [UserFileScalarFieldEnum!]
  ): [UserFile!]!
  url: CustomFileUrl!
}

type FileCount {
  posts(where: PostFileWhereInput): Int!
  files(where: UserFileWhereInput): Int!
}

input PostFileOrderByWithRelationInput {
  id: SortOrder
  postId: SortOrder
  fileId: SortOrder
  status: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  file: FileOrderByWithRelationInput
  post: PostOrderByWithRelationInput
}

input FileOrderByWithRelationInput {
  id: SortOrder
  location: SortOrder
  type: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  posts: PostFileOrderByRelationAggregateInput
  files: UserFileOrderByRelationAggregateInput
}

input PostFileWhereUniqueInput {
  id: Int
  AND: [PostFileWhereInput!]
  OR: [PostFileWhereInput!]
  NOT: [PostFileWhereInput!]
  postId: IntFilter
  fileId: IntFilter
  status: EnumActiveStatusFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  file: FileRelationFilter
  post: PostRelationFilter
}

enum PostFileScalarFieldEnum {
  id
  postId
  fileId
  status
  createdAt
  updatedAt
}

type UserFile {
  id: ID!
  userId: Int!
  fileId: Int!
  status: ActiveStatus!
  createdAt: DateTimeISO!
  updatedAt: DateTimeISO!
  file: File!
  user: User!
}

input UserFileOrderByWithRelationInput {
  id: SortOrder
  userId: SortOrder
  fileId: SortOrder
  status: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  file: FileOrderByWithRelationInput
  user: UserOrderByWithRelationInput
}

input UserFileWhereUniqueInput {
  id: Int
  AND: [UserFileWhereInput!]
  OR: [UserFileWhereInput!]
  NOT: [UserFileWhereInput!]
  userId: IntFilter
  fileId: IntFilter
  status: EnumActiveStatusFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  file: FileRelationFilter
  user: UserRelationFilter
}

enum UserFileScalarFieldEnum {
  id
  userId
  fileId
  status
  createdAt
  updatedAt
}

type CustomFileUrl {
  raw: String
  lg: String
  md: String
  sm: String
}

type Address {
  id: ID!
  code: String!
  c1: String!
  c2: String
  c3: String
  c4: String
  createdAt: DateTimeISO!
  updatedAt: DateTimeISO!
  _count: AddressCount
  posts(
    where: PostWhereInput
    orderBy: [PostOrderByWithRelationInput!]
    cursor: PostWhereUniqueInput
    take: Int
    skip: Int
    distinct: [PostScalarFieldEnum!]
  ): [Post!]!
  users(
    where: UserAddressWhereInput
    orderBy: [UserAddressOrderByWithRelationInput!]
    cursor: UserAddressWhereUniqueInput
    take: Int
    skip: Int
    distinct: [UserAddressScalarFieldEnum!]
  ): [UserAddress!]!
}

type AddressCount {
  posts(where: PostWhereInput): Int!
  users(where: UserAddressWhereInput): Int!
}

input PostWhereUniqueInput {
  id: Int
  AND: [PostWhereInput!]
  OR: [PostWhereInput!]
  NOT: [PostWhereInput!]
  content: StringFilter
  addressId: IntFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  userId: IntFilter
  comments: CommentListRelationFilter
  files: PostFileListRelationFilter
  address: AddressRelationFilter
  user: UserRelationFilter
}

enum PostScalarFieldEnum {
  id
  content
  addressId
  createdAt
  updatedAt
  userId
}

type UserAddress {
  id: ID!
  userId: Int!
  addressId: Int!
  status: ActiveStatus!
  createdAt: DateTimeISO!
  updatedAt: DateTimeISO!
  address: Address!
  user: User!
}

input UserAddressOrderByWithRelationInput {
  id: SortOrder
  userId: SortOrder
  addressId: SortOrder
  status: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  address: AddressOrderByWithRelationInput
  user: UserOrderByWithRelationInput
}

input UserAddressWhereUniqueInput {
  id: Int
  AND: [UserAddressWhereInput!]
  OR: [UserAddressWhereInput!]
  NOT: [UserAddressWhereInput!]
  userId: IntFilter
  addressId: IntFilter
  status: EnumActiveStatusFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  address: AddressRelationFilter
  user: UserRelationFilter
}

enum UserAddressScalarFieldEnum {
  id
  userId
  addressId
  status
  createdAt
  updatedAt
}

type Session {
  sessionToken: String!
  expires: DateTimeISO!
  createdAt: DateTimeISO!
  updatedAt: DateTimeISO!
  userId: Int!
  user: User!
}

input SessionOrderByWithRelationInput {
  sessionToken: SortOrder
  expires: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
  user: UserOrderByWithRelationInput
}

input SessionWhereUniqueInput {
  sessionToken: String
  AND: [SessionWhereInput!]
  OR: [SessionWhereInput!]
  NOT: [SessionWhereInput!]
  expires: DateTimeFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  userId: IntFilter
  user: UserRelationFilter
}

enum SessionScalarFieldEnum {
  sessionToken
  expires
  createdAt
  updatedAt
  userId
}

enum RelationLoadStrategy {
  query
  join
}

type AccountGroupBy {
  type: String!
  provider: String!
  providerAccountId: String!
  refresh_token: String
  access_token: String
  expires_at: Int
  token_type: String
  scope: String
  id_token: String
  session_state: String
  createdAt: DateTimeISO!
  updatedAt: DateTimeISO!
  userId: Int!
  _count: AccountCountAggregate
  _avg: AccountAvgAggregate
  _sum: AccountSumAggregate
  _min: AccountMinAggregate
  _max: AccountMaxAggregate
}

input AccountOrderByWithAggregationInput {
  type: SortOrder
  provider: SortOrder
  providerAccountId: SortOrder
  refresh_token: SortOrderInput
  access_token: SortOrderInput
  expires_at: SortOrderInput
  token_type: SortOrderInput
  scope: SortOrderInput
  id_token: SortOrderInput
  session_state: SortOrderInput
  createdAt: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
  _count: AccountCountOrderByAggregateInput
  _avg: AccountAvgOrderByAggregateInput
  _max: AccountMaxOrderByAggregateInput
  _min: AccountMinOrderByAggregateInput
  _sum: AccountSumOrderByAggregateInput
}

input AccountCountOrderByAggregateInput {
  type: SortOrder
  provider: SortOrder
  providerAccountId: SortOrder
  refresh_token: SortOrder
  access_token: SortOrder
  expires_at: SortOrder
  token_type: SortOrder
  scope: SortOrder
  id_token: SortOrder
  session_state: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input AccountAvgOrderByAggregateInput {
  expires_at: SortOrder
  userId: SortOrder
}

input AccountMaxOrderByAggregateInput {
  type: SortOrder
  provider: SortOrder
  providerAccountId: SortOrder
  refresh_token: SortOrder
  access_token: SortOrder
  expires_at: SortOrder
  token_type: SortOrder
  scope: SortOrder
  id_token: SortOrder
  session_state: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input AccountMinOrderByAggregateInput {
  type: SortOrder
  provider: SortOrder
  providerAccountId: SortOrder
  refresh_token: SortOrder
  access_token: SortOrder
  expires_at: SortOrder
  token_type: SortOrder
  scope: SortOrder
  id_token: SortOrder
  session_state: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input AccountSumOrderByAggregateInput {
  expires_at: SortOrder
  userId: SortOrder
}

input AccountScalarWhereWithAggregatesInput {
  AND: [AccountScalarWhereWithAggregatesInput!]
  OR: [AccountScalarWhereWithAggregatesInput!]
  NOT: [AccountScalarWhereWithAggregatesInput!]
  type: StringWithAggregatesFilter
  provider: StringWithAggregatesFilter
  providerAccountId: StringWithAggregatesFilter
  refresh_token: StringNullableWithAggregatesFilter
  access_token: StringNullableWithAggregatesFilter
  expires_at: IntNullableWithAggregatesFilter
  token_type: StringNullableWithAggregatesFilter
  scope: StringNullableWithAggregatesFilter
  id_token: StringNullableWithAggregatesFilter
  session_state: StringNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  userId: IntWithAggregatesFilter
}

input StringWithAggregatesFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  _count: NestedIntFilter
  _min: NestedStringFilter
  _max: NestedStringFilter
}

input NestedStringWithAggregatesFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringWithAggregatesFilter
  _count: NestedIntFilter
  _min: NestedStringFilter
  _max: NestedStringFilter
}

input StringNullableWithAggregatesFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  _count: NestedIntNullableFilter
  _min: NestedStringNullableFilter
  _max: NestedStringNullableFilter
}

input NestedStringNullableWithAggregatesFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringNullableWithAggregatesFilter
  _count: NestedIntNullableFilter
  _min: NestedStringNullableFilter
  _max: NestedStringNullableFilter
}

input IntNullableWithAggregatesFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: NestedIntNullableWithAggregatesFilter
  _count: NestedIntNullableFilter
  _avg: NestedFloatNullableFilter
  _sum: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _max: NestedIntNullableFilter
}

input NestedIntNullableWithAggregatesFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: NestedIntNullableWithAggregatesFilter
  _count: NestedIntNullableFilter
  _avg: NestedFloatNullableFilter
  _sum: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _max: NestedIntNullableFilter
}

input NestedFloatNullableFilter {
  equals: Float
  in: [Float!]
  notIn: [Float!]
  lt: Float
  lte: Float
  gt: Float
  gte: Float
  not: NestedFloatNullableFilter
}

input DateTimeWithAggregatesFilter {
  equals: DateTimeISO
  in: [DateTimeISO!]
  notIn: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  not: NestedDateTimeWithAggregatesFilter
  _count: NestedIntFilter
  _min: NestedDateTimeFilter
  _max: NestedDateTimeFilter
}

input NestedDateTimeWithAggregatesFilter {
  equals: DateTimeISO
  in: [DateTimeISO!]
  notIn: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  not: NestedDateTimeWithAggregatesFilter
  _count: NestedIntFilter
  _min: NestedDateTimeFilter
  _max: NestedDateTimeFilter
}

input IntWithAggregatesFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: NestedIntWithAggregatesFilter
  _count: NestedIntFilter
  _avg: NestedFloatFilter
  _sum: NestedIntFilter
  _min: NestedIntFilter
  _max: NestedIntFilter
}

input NestedIntWithAggregatesFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: NestedIntWithAggregatesFilter
  _count: NestedIntFilter
  _avg: NestedFloatFilter
  _sum: NestedIntFilter
  _min: NestedIntFilter
  _max: NestedIntFilter
}

input NestedFloatFilter {
  equals: Float
  in: [Float!]
  notIn: [Float!]
  lt: Float
  lte: Float
  gt: Float
  gte: Float
  not: NestedFloatFilter
}

type AggregateAddress {
  _count: AddressCountAggregate
  _avg: AddressAvgAggregate
  _sum: AddressSumAggregate
  _min: AddressMinAggregate
  _max: AddressMaxAggregate
}

type AddressCountAggregate {
  id: Int!
  code: Int!
  c1: Int!
  c2: Int!
  c3: Int!
  c4: Int!
  createdAt: Int!
  updatedAt: Int!
  _all: Int!
}

type AddressAvgAggregate {
  id: Float
}

type AddressSumAggregate {
  id: Int
}

type AddressMinAggregate {
  id: Int
  code: String
  c1: String
  c2: String
  c3: String
  c4: String
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
}

type AddressMaxAggregate {
  id: Int
  code: String
  c1: String
  c2: String
  c3: String
  c4: String
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
}

input AddressWhereUniqueInput {
  id: Int
  code: String
  AND: [AddressWhereInput!]
  OR: [AddressWhereInput!]
  NOT: [AddressWhereInput!]
  c1: StringFilter
  c2: StringNullableFilter
  c3: StringNullableFilter
  c4: StringNullableFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  posts: PostListRelationFilter
  users: UserAddressListRelationFilter
}

enum AddressScalarFieldEnum {
  id
  code
  c1
  c2
  c3
  c4
  createdAt
  updatedAt
}

type AddressGroupBy {
  id: Int!
  code: String!
  c1: String!
  c2: String
  c3: String
  c4: String
  createdAt: DateTimeISO!
  updatedAt: DateTimeISO!
  _count: AddressCountAggregate
  _avg: AddressAvgAggregate
  _sum: AddressSumAggregate
  _min: AddressMinAggregate
  _max: AddressMaxAggregate
}

input AddressOrderByWithAggregationInput {
  id: SortOrder
  code: SortOrder
  c1: SortOrder
  c2: SortOrderInput
  c3: SortOrderInput
  c4: SortOrderInput
  createdAt: SortOrder
  updatedAt: SortOrder
  _count: AddressCountOrderByAggregateInput
  _avg: AddressAvgOrderByAggregateInput
  _max: AddressMaxOrderByAggregateInput
  _min: AddressMinOrderByAggregateInput
  _sum: AddressSumOrderByAggregateInput
}

input AddressCountOrderByAggregateInput {
  id: SortOrder
  code: SortOrder
  c1: SortOrder
  c2: SortOrder
  c3: SortOrder
  c4: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
}

input AddressAvgOrderByAggregateInput {
  id: SortOrder
}

input AddressMaxOrderByAggregateInput {
  id: SortOrder
  code: SortOrder
  c1: SortOrder
  c2: SortOrder
  c3: SortOrder
  c4: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
}

input AddressMinOrderByAggregateInput {
  id: SortOrder
  code: SortOrder
  c1: SortOrder
  c2: SortOrder
  c3: SortOrder
  c4: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
}

input AddressSumOrderByAggregateInput {
  id: SortOrder
}

input AddressScalarWhereWithAggregatesInput {
  AND: [AddressScalarWhereWithAggregatesInput!]
  OR: [AddressScalarWhereWithAggregatesInput!]
  NOT: [AddressScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  code: StringWithAggregatesFilter
  c1: StringWithAggregatesFilter
  c2: StringNullableWithAggregatesFilter
  c3: StringNullableWithAggregatesFilter
  c4: StringNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type AggregateChat {
  _count: ChatCountAggregate
  _avg: ChatAvgAggregate
  _sum: ChatSumAggregate
  _min: ChatMinAggregate
  _max: ChatMaxAggregate
}

type ChatCountAggregate {
  id: Int!
  name: Int!
  createdAt: Int!
  updatedAt: Int!
  _all: Int!
}

type ChatAvgAggregate {
  id: Float
}

type ChatSumAggregate {
  id: Int
}

type ChatMinAggregate {
  id: Int
  name: String
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
}

type ChatMaxAggregate {
  id: Int
  name: String
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
}

input ChatWhereUniqueInput {
  id: Int
  AND: [ChatWhereInput!]
  OR: [ChatWhereInput!]
  NOT: [ChatWhereInput!]
  name: StringNullableFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  messages: ChatMessageListRelationFilter
  users: ChatUserListRelationFilter
}

enum ChatScalarFieldEnum {
  id
  name
  createdAt
  updatedAt
}

type ChatGroupBy {
  id: Int!
  name: String
  createdAt: DateTimeISO!
  updatedAt: DateTimeISO!
  _count: ChatCountAggregate
  _avg: ChatAvgAggregate
  _sum: ChatSumAggregate
  _min: ChatMinAggregate
  _max: ChatMaxAggregate
}

input ChatOrderByWithAggregationInput {
  id: SortOrder
  name: SortOrderInput
  createdAt: SortOrder
  updatedAt: SortOrder
  _count: ChatCountOrderByAggregateInput
  _avg: ChatAvgOrderByAggregateInput
  _max: ChatMaxOrderByAggregateInput
  _min: ChatMinOrderByAggregateInput
  _sum: ChatSumOrderByAggregateInput
}

input ChatCountOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
}

input ChatAvgOrderByAggregateInput {
  id: SortOrder
}

input ChatMaxOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
}

input ChatMinOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
}

input ChatSumOrderByAggregateInput {
  id: SortOrder
}

input ChatScalarWhereWithAggregatesInput {
  AND: [ChatScalarWhereWithAggregatesInput!]
  OR: [ChatScalarWhereWithAggregatesInput!]
  NOT: [ChatScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  name: StringNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type AggregateChatMessage {
  _count: ChatMessageCountAggregate
  _avg: ChatMessageAvgAggregate
  _sum: ChatMessageSumAggregate
  _min: ChatMessageMinAggregate
  _max: ChatMessageMaxAggregate
}

type ChatMessageCountAggregate {
  id: Int!
  message: Int!
  createdAt: Int!
  updatedAt: Int!
  chatId: Int!
  userId: Int!
  _all: Int!
}

type ChatMessageAvgAggregate {
  id: Float
  chatId: Float
  userId: Float
}

type ChatMessageSumAggregate {
  id: Int
  chatId: Int
  userId: Int
}

type ChatMessageMinAggregate {
  id: Int
  message: String
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  chatId: Int
  userId: Int
}

type ChatMessageMaxAggregate {
  id: Int
  message: String
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  chatId: Int
  userId: Int
}

type ChatMessageGroupBy {
  id: Int!
  message: String!
  createdAt: DateTimeISO!
  updatedAt: DateTimeISO!
  chatId: Int!
  userId: Int!
  _count: ChatMessageCountAggregate
  _avg: ChatMessageAvgAggregate
  _sum: ChatMessageSumAggregate
  _min: ChatMessageMinAggregate
  _max: ChatMessageMaxAggregate
}

input ChatMessageOrderByWithAggregationInput {
  id: SortOrder
  message: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  chatId: SortOrder
  userId: SortOrder
  _count: ChatMessageCountOrderByAggregateInput
  _avg: ChatMessageAvgOrderByAggregateInput
  _max: ChatMessageMaxOrderByAggregateInput
  _min: ChatMessageMinOrderByAggregateInput
  _sum: ChatMessageSumOrderByAggregateInput
}

input ChatMessageCountOrderByAggregateInput {
  id: SortOrder
  message: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  chatId: SortOrder
  userId: SortOrder
}

input ChatMessageAvgOrderByAggregateInput {
  id: SortOrder
  chatId: SortOrder
  userId: SortOrder
}

input ChatMessageMaxOrderByAggregateInput {
  id: SortOrder
  message: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  chatId: SortOrder
  userId: SortOrder
}

input ChatMessageMinOrderByAggregateInput {
  id: SortOrder
  message: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  chatId: SortOrder
  userId: SortOrder
}

input ChatMessageSumOrderByAggregateInput {
  id: SortOrder
  chatId: SortOrder
  userId: SortOrder
}

input ChatMessageScalarWhereWithAggregatesInput {
  AND: [ChatMessageScalarWhereWithAggregatesInput!]
  OR: [ChatMessageScalarWhereWithAggregatesInput!]
  NOT: [ChatMessageScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  message: StringWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  chatId: IntWithAggregatesFilter
  userId: IntWithAggregatesFilter
}

type AggregateChatUser {
  _count: ChatUserCountAggregate
  _avg: ChatUserAvgAggregate
  _sum: ChatUserSumAggregate
  _min: ChatUserMinAggregate
  _max: ChatUserMaxAggregate
}

type ChatUserCountAggregate {
  id: Int!
  createdAt: Int!
  updatedAt: Int!
  chatId: Int!
  userId: Int!
  _all: Int!
}

type ChatUserAvgAggregate {
  id: Float
  chatId: Float
  userId: Float
}

type ChatUserSumAggregate {
  id: Int
  chatId: Int
  userId: Int
}

type ChatUserMinAggregate {
  id: Int
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  chatId: Int
  userId: Int
}

type ChatUserMaxAggregate {
  id: Int
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  chatId: Int
  userId: Int
}

type ChatUserGroupBy {
  id: Int!
  createdAt: DateTimeISO!
  updatedAt: DateTimeISO!
  chatId: Int!
  userId: Int!
  _count: ChatUserCountAggregate
  _avg: ChatUserAvgAggregate
  _sum: ChatUserSumAggregate
  _min: ChatUserMinAggregate
  _max: ChatUserMaxAggregate
}

input ChatUserOrderByWithAggregationInput {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  chatId: SortOrder
  userId: SortOrder
  _count: ChatUserCountOrderByAggregateInput
  _avg: ChatUserAvgOrderByAggregateInput
  _max: ChatUserMaxOrderByAggregateInput
  _min: ChatUserMinOrderByAggregateInput
  _sum: ChatUserSumOrderByAggregateInput
}

input ChatUserCountOrderByAggregateInput {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  chatId: SortOrder
  userId: SortOrder
}

input ChatUserAvgOrderByAggregateInput {
  id: SortOrder
  chatId: SortOrder
  userId: SortOrder
}

input ChatUserMaxOrderByAggregateInput {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  chatId: SortOrder
  userId: SortOrder
}

input ChatUserMinOrderByAggregateInput {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  chatId: SortOrder
  userId: SortOrder
}

input ChatUserSumOrderByAggregateInput {
  id: SortOrder
  chatId: SortOrder
  userId: SortOrder
}

input ChatUserScalarWhereWithAggregatesInput {
  AND: [ChatUserScalarWhereWithAggregatesInput!]
  OR: [ChatUserScalarWhereWithAggregatesInput!]
  NOT: [ChatUserScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  chatId: IntWithAggregatesFilter
  userId: IntWithAggregatesFilter
}

type AggregateComment {
  _count: CommentCountAggregate
  _avg: CommentAvgAggregate
  _sum: CommentSumAggregate
  _min: CommentMinAggregate
  _max: CommentMaxAggregate
}

type CommentCountAggregate {
  id: Int!
  content: Int!
  createdAt: Int!
  updatedAt: Int!
  userId: Int!
  postId: Int!
  _all: Int!
}

type CommentAvgAggregate {
  id: Float
  userId: Float
  postId: Float
}

type CommentSumAggregate {
  id: Int
  userId: Int
  postId: Int
}

type CommentMinAggregate {
  id: Int
  content: String
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  userId: Int
  postId: Int
}

type CommentMaxAggregate {
  id: Int
  content: String
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  userId: Int
  postId: Int
}

type CommentGroupBy {
  id: Int!
  content: String!
  createdAt: DateTimeISO!
  updatedAt: DateTimeISO!
  userId: Int!
  postId: Int!
  _count: CommentCountAggregate
  _avg: CommentAvgAggregate
  _sum: CommentSumAggregate
  _min: CommentMinAggregate
  _max: CommentMaxAggregate
}

input CommentOrderByWithAggregationInput {
  id: SortOrder
  content: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
  postId: SortOrder
  _count: CommentCountOrderByAggregateInput
  _avg: CommentAvgOrderByAggregateInput
  _max: CommentMaxOrderByAggregateInput
  _min: CommentMinOrderByAggregateInput
  _sum: CommentSumOrderByAggregateInput
}

input CommentCountOrderByAggregateInput {
  id: SortOrder
  content: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
  postId: SortOrder
}

input CommentAvgOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
  postId: SortOrder
}

input CommentMaxOrderByAggregateInput {
  id: SortOrder
  content: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
  postId: SortOrder
}

input CommentMinOrderByAggregateInput {
  id: SortOrder
  content: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
  postId: SortOrder
}

input CommentSumOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
  postId: SortOrder
}

input CommentScalarWhereWithAggregatesInput {
  AND: [CommentScalarWhereWithAggregatesInput!]
  OR: [CommentScalarWhereWithAggregatesInput!]
  NOT: [CommentScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  content: StringWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  userId: IntWithAggregatesFilter
  postId: IntWithAggregatesFilter
}

type AggregateFile {
  _count: FileCountAggregate
  _avg: FileAvgAggregate
  _sum: FileSumAggregate
  _min: FileMinAggregate
  _max: FileMaxAggregate
}

type FileCountAggregate {
  id: Int!
  location: Int!
  type: Int!
  createdAt: Int!
  updatedAt: Int!
  _all: Int!
}

type FileAvgAggregate {
  id: Float
}

type FileSumAggregate {
  id: Int
}

type FileMinAggregate {
  id: Int
  location: String
  type: FileStorageType
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
}

type FileMaxAggregate {
  id: Int
  location: String
  type: FileStorageType
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
}

input FileWhereUniqueInput {
  id: Int
  AND: [FileWhereInput!]
  OR: [FileWhereInput!]
  NOT: [FileWhereInput!]
  location: StringFilter
  type: EnumFileStorageTypeFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  posts: PostFileListRelationFilter
  files: UserFileListRelationFilter
}

enum FileScalarFieldEnum {
  id
  location
  type
  createdAt
  updatedAt
}

type FileGroupBy {
  id: Int!
  location: String!
  type: FileStorageType!
  createdAt: DateTimeISO!
  updatedAt: DateTimeISO!
  _count: FileCountAggregate
  _avg: FileAvgAggregate
  _sum: FileSumAggregate
  _min: FileMinAggregate
  _max: FileMaxAggregate
}

input FileOrderByWithAggregationInput {
  id: SortOrder
  location: SortOrder
  type: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  _count: FileCountOrderByAggregateInput
  _avg: FileAvgOrderByAggregateInput
  _max: FileMaxOrderByAggregateInput
  _min: FileMinOrderByAggregateInput
  _sum: FileSumOrderByAggregateInput
}

input FileCountOrderByAggregateInput {
  id: SortOrder
  location: SortOrder
  type: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
}

input FileAvgOrderByAggregateInput {
  id: SortOrder
}

input FileMaxOrderByAggregateInput {
  id: SortOrder
  location: SortOrder
  type: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
}

input FileMinOrderByAggregateInput {
  id: SortOrder
  location: SortOrder
  type: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
}

input FileSumOrderByAggregateInput {
  id: SortOrder
}

input FileScalarWhereWithAggregatesInput {
  AND: [FileScalarWhereWithAggregatesInput!]
  OR: [FileScalarWhereWithAggregatesInput!]
  NOT: [FileScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  location: StringWithAggregatesFilter
  type: EnumFileStorageTypeWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

input EnumFileStorageTypeWithAggregatesFilter {
  equals: FileStorageType
  in: [FileStorageType!]
  notIn: [FileStorageType!]
  not: NestedEnumFileStorageTypeWithAggregatesFilter
  _count: NestedIntFilter
  _min: NestedEnumFileStorageTypeFilter
  _max: NestedEnumFileStorageTypeFilter
}

input NestedEnumFileStorageTypeWithAggregatesFilter {
  equals: FileStorageType
  in: [FileStorageType!]
  notIn: [FileStorageType!]
  not: NestedEnumFileStorageTypeWithAggregatesFilter
  _count: NestedIntFilter
  _min: NestedEnumFileStorageTypeFilter
  _max: NestedEnumFileStorageTypeFilter
}

type AggregatePost {
  _count: PostCountAggregate
  _avg: PostAvgAggregate
  _sum: PostSumAggregate
  _min: PostMinAggregate
  _max: PostMaxAggregate
}

type PostCountAggregate {
  id: Int!
  content: Int!
  addressId: Int!
  createdAt: Int!
  updatedAt: Int!
  userId: Int!
  _all: Int!
}

type PostAvgAggregate {
  id: Float
  addressId: Float
  userId: Float
}

type PostSumAggregate {
  id: Int
  addressId: Int
  userId: Int
}

type PostMinAggregate {
  id: Int
  content: String
  addressId: Int
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  userId: Int
}

type PostMaxAggregate {
  id: Int
  content: String
  addressId: Int
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  userId: Int
}

type PostGroupBy {
  id: Int!
  content: String!
  addressId: Int!
  createdAt: DateTimeISO!
  updatedAt: DateTimeISO!
  userId: Int!
  _count: PostCountAggregate
  _avg: PostAvgAggregate
  _sum: PostSumAggregate
  _min: PostMinAggregate
  _max: PostMaxAggregate
}

input PostOrderByWithAggregationInput {
  id: SortOrder
  content: SortOrder
  addressId: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
  _count: PostCountOrderByAggregateInput
  _avg: PostAvgOrderByAggregateInput
  _max: PostMaxOrderByAggregateInput
  _min: PostMinOrderByAggregateInput
  _sum: PostSumOrderByAggregateInput
}

input PostCountOrderByAggregateInput {
  id: SortOrder
  content: SortOrder
  addressId: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input PostAvgOrderByAggregateInput {
  id: SortOrder
  addressId: SortOrder
  userId: SortOrder
}

input PostMaxOrderByAggregateInput {
  id: SortOrder
  content: SortOrder
  addressId: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input PostMinOrderByAggregateInput {
  id: SortOrder
  content: SortOrder
  addressId: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input PostSumOrderByAggregateInput {
  id: SortOrder
  addressId: SortOrder
  userId: SortOrder
}

input PostScalarWhereWithAggregatesInput {
  AND: [PostScalarWhereWithAggregatesInput!]
  OR: [PostScalarWhereWithAggregatesInput!]
  NOT: [PostScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  content: StringWithAggregatesFilter
  addressId: IntWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  userId: IntWithAggregatesFilter
}

type AggregatePostFile {
  _count: PostFileCountAggregate
  _avg: PostFileAvgAggregate
  _sum: PostFileSumAggregate
  _min: PostFileMinAggregate
  _max: PostFileMaxAggregate
}

type PostFileCountAggregate {
  id: Int!
  postId: Int!
  fileId: Int!
  status: Int!
  createdAt: Int!
  updatedAt: Int!
  _all: Int!
}

type PostFileAvgAggregate {
  id: Float
  postId: Float
  fileId: Float
}

type PostFileSumAggregate {
  id: Int
  postId: Int
  fileId: Int
}

type PostFileMinAggregate {
  id: Int
  postId: Int
  fileId: Int
  status: ActiveStatus
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
}

type PostFileMaxAggregate {
  id: Int
  postId: Int
  fileId: Int
  status: ActiveStatus
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
}

type PostFileGroupBy {
  id: Int!
  postId: Int!
  fileId: Int!
  status: ActiveStatus!
  createdAt: DateTimeISO!
  updatedAt: DateTimeISO!
  _count: PostFileCountAggregate
  _avg: PostFileAvgAggregate
  _sum: PostFileSumAggregate
  _min: PostFileMinAggregate
  _max: PostFileMaxAggregate
}

input PostFileOrderByWithAggregationInput {
  id: SortOrder
  postId: SortOrder
  fileId: SortOrder
  status: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  _count: PostFileCountOrderByAggregateInput
  _avg: PostFileAvgOrderByAggregateInput
  _max: PostFileMaxOrderByAggregateInput
  _min: PostFileMinOrderByAggregateInput
  _sum: PostFileSumOrderByAggregateInput
}

input PostFileCountOrderByAggregateInput {
  id: SortOrder
  postId: SortOrder
  fileId: SortOrder
  status: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
}

input PostFileAvgOrderByAggregateInput {
  id: SortOrder
  postId: SortOrder
  fileId: SortOrder
}

input PostFileMaxOrderByAggregateInput {
  id: SortOrder
  postId: SortOrder
  fileId: SortOrder
  status: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
}

input PostFileMinOrderByAggregateInput {
  id: SortOrder
  postId: SortOrder
  fileId: SortOrder
  status: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
}

input PostFileSumOrderByAggregateInput {
  id: SortOrder
  postId: SortOrder
  fileId: SortOrder
}

input PostFileScalarWhereWithAggregatesInput {
  AND: [PostFileScalarWhereWithAggregatesInput!]
  OR: [PostFileScalarWhereWithAggregatesInput!]
  NOT: [PostFileScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  postId: IntWithAggregatesFilter
  fileId: IntWithAggregatesFilter
  status: EnumActiveStatusWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

input EnumActiveStatusWithAggregatesFilter {
  equals: ActiveStatus
  in: [ActiveStatus!]
  notIn: [ActiveStatus!]
  not: NestedEnumActiveStatusWithAggregatesFilter
  _count: NestedIntFilter
  _min: NestedEnumActiveStatusFilter
  _max: NestedEnumActiveStatusFilter
}

input NestedEnumActiveStatusWithAggregatesFilter {
  equals: ActiveStatus
  in: [ActiveStatus!]
  notIn: [ActiveStatus!]
  not: NestedEnumActiveStatusWithAggregatesFilter
  _count: NestedIntFilter
  _min: NestedEnumActiveStatusFilter
  _max: NestedEnumActiveStatusFilter
}

type AggregateSession {
  _count: SessionCountAggregate
  _avg: SessionAvgAggregate
  _sum: SessionSumAggregate
  _min: SessionMinAggregate
  _max: SessionMaxAggregate
}

type SessionCountAggregate {
  sessionToken: Int!
  expires: Int!
  createdAt: Int!
  updatedAt: Int!
  userId: Int!
  _all: Int!
}

type SessionAvgAggregate {
  userId: Float
}

type SessionSumAggregate {
  userId: Int
}

type SessionMinAggregate {
  sessionToken: String
  expires: DateTimeISO
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  userId: Int
}

type SessionMaxAggregate {
  sessionToken: String
  expires: DateTimeISO
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  userId: Int
}

type SessionGroupBy {
  sessionToken: String!
  expires: DateTimeISO!
  createdAt: DateTimeISO!
  updatedAt: DateTimeISO!
  userId: Int!
  _count: SessionCountAggregate
  _avg: SessionAvgAggregate
  _sum: SessionSumAggregate
  _min: SessionMinAggregate
  _max: SessionMaxAggregate
}

input SessionOrderByWithAggregationInput {
  sessionToken: SortOrder
  expires: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
  _count: SessionCountOrderByAggregateInput
  _avg: SessionAvgOrderByAggregateInput
  _max: SessionMaxOrderByAggregateInput
  _min: SessionMinOrderByAggregateInput
  _sum: SessionSumOrderByAggregateInput
}

input SessionCountOrderByAggregateInput {
  sessionToken: SortOrder
  expires: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input SessionAvgOrderByAggregateInput {
  userId: SortOrder
}

input SessionMaxOrderByAggregateInput {
  sessionToken: SortOrder
  expires: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input SessionMinOrderByAggregateInput {
  sessionToken: SortOrder
  expires: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input SessionSumOrderByAggregateInput {
  userId: SortOrder
}

input SessionScalarWhereWithAggregatesInput {
  AND: [SessionScalarWhereWithAggregatesInput!]
  OR: [SessionScalarWhereWithAggregatesInput!]
  NOT: [SessionScalarWhereWithAggregatesInput!]
  sessionToken: StringWithAggregatesFilter
  expires: DateTimeWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  userId: IntWithAggregatesFilter
}

type AggregateSpatial_ref_sys {
  _count: Spatial_ref_sysCountAggregate
  _avg: Spatial_ref_sysAvgAggregate
  _sum: Spatial_ref_sysSumAggregate
  _min: Spatial_ref_sysMinAggregate
  _max: Spatial_ref_sysMaxAggregate
}

type Spatial_ref_sysCountAggregate {
  srid: Int!
  auth_name: Int!
  auth_srid: Int!
  srtext: Int!
  proj4text: Int!
  _all: Int!
}

type Spatial_ref_sysAvgAggregate {
  srid: Float
  auth_srid: Float
}

type Spatial_ref_sysSumAggregate {
  srid: Int
  auth_srid: Int
}

type Spatial_ref_sysMinAggregate {
  srid: Int
  auth_name: String
  auth_srid: Int
  srtext: String
  proj4text: String
}

type Spatial_ref_sysMaxAggregate {
  srid: Int
  auth_name: String
  auth_srid: Int
  srtext: String
  proj4text: String
}

input Spatial_ref_sysWhereInput {
  AND: [Spatial_ref_sysWhereInput!]
  OR: [Spatial_ref_sysWhereInput!]
  NOT: [Spatial_ref_sysWhereInput!]
  srid: IntFilter
  auth_name: StringNullableFilter
  auth_srid: IntNullableFilter
  srtext: StringNullableFilter
  proj4text: StringNullableFilter
}

input Spatial_ref_sysOrderByWithRelationInput {
  srid: SortOrder
  auth_name: SortOrderInput
  auth_srid: SortOrderInput
  srtext: SortOrderInput
  proj4text: SortOrderInput
}

input Spatial_ref_sysWhereUniqueInput {
  srid: Int
  AND: [Spatial_ref_sysWhereInput!]
  OR: [Spatial_ref_sysWhereInput!]
  NOT: [Spatial_ref_sysWhereInput!]
  auth_name: StringNullableFilter
  auth_srid: IntNullableFilter
  srtext: StringNullableFilter
  proj4text: StringNullableFilter
}

"""
This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
"""
type Spatial_ref_sys {
  srid: ID!
  auth_name: String
  auth_srid: Int
  srtext: String
  proj4text: String
}

enum Spatial_ref_sysScalarFieldEnum {
  srid
  auth_name
  auth_srid
  srtext
  proj4text
}

type Spatial_ref_sysGroupBy {
  srid: Int!
  auth_name: String
  auth_srid: Int
  srtext: String
  proj4text: String
  _count: Spatial_ref_sysCountAggregate
  _avg: Spatial_ref_sysAvgAggregate
  _sum: Spatial_ref_sysSumAggregate
  _min: Spatial_ref_sysMinAggregate
  _max: Spatial_ref_sysMaxAggregate
}

input Spatial_ref_sysOrderByWithAggregationInput {
  srid: SortOrder
  auth_name: SortOrderInput
  auth_srid: SortOrderInput
  srtext: SortOrderInput
  proj4text: SortOrderInput
  _count: Spatial_ref_sysCountOrderByAggregateInput
  _avg: Spatial_ref_sysAvgOrderByAggregateInput
  _max: Spatial_ref_sysMaxOrderByAggregateInput
  _min: Spatial_ref_sysMinOrderByAggregateInput
  _sum: Spatial_ref_sysSumOrderByAggregateInput
}

input Spatial_ref_sysCountOrderByAggregateInput {
  srid: SortOrder
  auth_name: SortOrder
  auth_srid: SortOrder
  srtext: SortOrder
  proj4text: SortOrder
}

input Spatial_ref_sysAvgOrderByAggregateInput {
  srid: SortOrder
  auth_srid: SortOrder
}

input Spatial_ref_sysMaxOrderByAggregateInput {
  srid: SortOrder
  auth_name: SortOrder
  auth_srid: SortOrder
  srtext: SortOrder
  proj4text: SortOrder
}

input Spatial_ref_sysMinOrderByAggregateInput {
  srid: SortOrder
  auth_name: SortOrder
  auth_srid: SortOrder
  srtext: SortOrder
  proj4text: SortOrder
}

input Spatial_ref_sysSumOrderByAggregateInput {
  srid: SortOrder
  auth_srid: SortOrder
}

input Spatial_ref_sysScalarWhereWithAggregatesInput {
  AND: [Spatial_ref_sysScalarWhereWithAggregatesInput!]
  OR: [Spatial_ref_sysScalarWhereWithAggregatesInput!]
  NOT: [Spatial_ref_sysScalarWhereWithAggregatesInput!]
  srid: IntWithAggregatesFilter
  auth_name: StringNullableWithAggregatesFilter
  auth_srid: IntNullableWithAggregatesFilter
  srtext: StringNullableWithAggregatesFilter
  proj4text: StringNullableWithAggregatesFilter
}

type AggregateUser {
  _count: UserCountAggregate
  _avg: UserAvgAggregate
  _sum: UserSumAggregate
  _min: UserMinAggregate
  _max: UserMaxAggregate
}

type UserCountAggregate {
  id: Int!
  content: Int!
  babyBirth: Int!
  createdAt: Int!
  updatedAt: Int!
  email: Int!
  emailVerified: Int!
  image: Int!
  name: Int!
  username: Int!
  role: Int!
  _all: Int!
}

type UserAvgAggregate {
  id: Float
}

type UserSumAggregate {
  id: Int
}

type UserMinAggregate {
  id: Int
  content: String
  babyBirth: DateTimeISO
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  email: String
  emailVerified: DateTimeISO
  image: String
  name: String
  username: String
  role: Role
}

type UserMaxAggregate {
  id: Int
  content: String
  babyBirth: DateTimeISO
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  email: String
  emailVerified: DateTimeISO
  image: String
  name: String
  username: String
  role: Role
}

input UserWhereUniqueInput {
  id: Int
  email: String
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
  content: StringNullableFilter
  babyBirth: DateTimeNullableFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  emailVerified: DateTimeNullableFilter
  image: StringNullableFilter
  name: StringNullableFilter
  username: StringNullableFilter
  role: EnumRoleFilter
  accounts: AccountListRelationFilter
  chats: ChatUserListRelationFilter
  comments: CommentListRelationFilter
  posts: PostListRelationFilter
  sessions: SessionListRelationFilter
  addresses: UserAddressListRelationFilter
  files: UserFileListRelationFilter
  chatMessages: ChatMessageListRelationFilter
}

enum UserScalarFieldEnum {
  id
  content
  babyBirth
  createdAt
  updatedAt
  email
  emailVerified
  image
  name
  username
  role
}

type UserGroupBy {
  id: Int!
  content: String
  babyBirth: DateTimeISO
  createdAt: DateTimeISO!
  updatedAt: DateTimeISO!
  email: String!
  emailVerified: DateTimeISO
  image: String
  name: String
  username: String
  role: Role!
  _count: UserCountAggregate
  _avg: UserAvgAggregate
  _sum: UserSumAggregate
  _min: UserMinAggregate
  _max: UserMaxAggregate
}

input UserOrderByWithAggregationInput {
  id: SortOrder
  content: SortOrderInput
  babyBirth: SortOrderInput
  createdAt: SortOrder
  updatedAt: SortOrder
  email: SortOrder
  emailVerified: SortOrderInput
  image: SortOrderInput
  name: SortOrderInput
  username: SortOrderInput
  role: SortOrder
  _count: UserCountOrderByAggregateInput
  _avg: UserAvgOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  _sum: UserSumOrderByAggregateInput
}

input UserCountOrderByAggregateInput {
  id: SortOrder
  content: SortOrder
  babyBirth: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  email: SortOrder
  emailVerified: SortOrder
  image: SortOrder
  name: SortOrder
  username: SortOrder
  role: SortOrder
}

input UserAvgOrderByAggregateInput {
  id: SortOrder
}

input UserMaxOrderByAggregateInput {
  id: SortOrder
  content: SortOrder
  babyBirth: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  email: SortOrder
  emailVerified: SortOrder
  image: SortOrder
  name: SortOrder
  username: SortOrder
  role: SortOrder
}

input UserMinOrderByAggregateInput {
  id: SortOrder
  content: SortOrder
  babyBirth: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  email: SortOrder
  emailVerified: SortOrder
  image: SortOrder
  name: SortOrder
  username: SortOrder
  role: SortOrder
}

input UserSumOrderByAggregateInput {
  id: SortOrder
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  content: StringNullableWithAggregatesFilter
  babyBirth: DateTimeNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  email: StringWithAggregatesFilter
  emailVerified: DateTimeNullableWithAggregatesFilter
  image: StringNullableWithAggregatesFilter
  name: StringNullableWithAggregatesFilter
  username: StringNullableWithAggregatesFilter
  role: EnumRoleWithAggregatesFilter
}

input DateTimeNullableWithAggregatesFilter {
  equals: DateTimeISO
  in: [DateTimeISO!]
  notIn: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  not: NestedDateTimeNullableWithAggregatesFilter
  _count: NestedIntNullableFilter
  _min: NestedDateTimeNullableFilter
  _max: NestedDateTimeNullableFilter
}

input NestedDateTimeNullableWithAggregatesFilter {
  equals: DateTimeISO
  in: [DateTimeISO!]
  notIn: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  not: NestedDateTimeNullableWithAggregatesFilter
  _count: NestedIntNullableFilter
  _min: NestedDateTimeNullableFilter
  _max: NestedDateTimeNullableFilter
}

input EnumRoleWithAggregatesFilter {
  equals: Role
  in: [Role!]
  notIn: [Role!]
  not: NestedEnumRoleWithAggregatesFilter
  _count: NestedIntFilter
  _min: NestedEnumRoleFilter
  _max: NestedEnumRoleFilter
}

input NestedEnumRoleWithAggregatesFilter {
  equals: Role
  in: [Role!]
  notIn: [Role!]
  not: NestedEnumRoleWithAggregatesFilter
  _count: NestedIntFilter
  _min: NestedEnumRoleFilter
  _max: NestedEnumRoleFilter
}

type AggregateUserAddress {
  _count: UserAddressCountAggregate
  _avg: UserAddressAvgAggregate
  _sum: UserAddressSumAggregate
  _min: UserAddressMinAggregate
  _max: UserAddressMaxAggregate
}

type UserAddressCountAggregate {
  id: Int!
  userId: Int!
  addressId: Int!
  status: Int!
  createdAt: Int!
  updatedAt: Int!
  _all: Int!
}

type UserAddressAvgAggregate {
  id: Float
  userId: Float
  addressId: Float
}

type UserAddressSumAggregate {
  id: Int
  userId: Int
  addressId: Int
}

type UserAddressMinAggregate {
  id: Int
  userId: Int
  addressId: Int
  status: ActiveStatus
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
}

type UserAddressMaxAggregate {
  id: Int
  userId: Int
  addressId: Int
  status: ActiveStatus
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
}

type UserAddressGroupBy {
  id: Int!
  userId: Int!
  addressId: Int!
  status: ActiveStatus!
  createdAt: DateTimeISO!
  updatedAt: DateTimeISO!
  _count: UserAddressCountAggregate
  _avg: UserAddressAvgAggregate
  _sum: UserAddressSumAggregate
  _min: UserAddressMinAggregate
  _max: UserAddressMaxAggregate
}

input UserAddressOrderByWithAggregationInput {
  id: SortOrder
  userId: SortOrder
  addressId: SortOrder
  status: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  _count: UserAddressCountOrderByAggregateInput
  _avg: UserAddressAvgOrderByAggregateInput
  _max: UserAddressMaxOrderByAggregateInput
  _min: UserAddressMinOrderByAggregateInput
  _sum: UserAddressSumOrderByAggregateInput
}

input UserAddressCountOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
  addressId: SortOrder
  status: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
}

input UserAddressAvgOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
  addressId: SortOrder
}

input UserAddressMaxOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
  addressId: SortOrder
  status: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
}

input UserAddressMinOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
  addressId: SortOrder
  status: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
}

input UserAddressSumOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
  addressId: SortOrder
}

input UserAddressScalarWhereWithAggregatesInput {
  AND: [UserAddressScalarWhereWithAggregatesInput!]
  OR: [UserAddressScalarWhereWithAggregatesInput!]
  NOT: [UserAddressScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  userId: IntWithAggregatesFilter
  addressId: IntWithAggregatesFilter
  status: EnumActiveStatusWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type AggregateUserFile {
  _count: UserFileCountAggregate
  _avg: UserFileAvgAggregate
  _sum: UserFileSumAggregate
  _min: UserFileMinAggregate
  _max: UserFileMaxAggregate
}

type UserFileCountAggregate {
  id: Int!
  userId: Int!
  fileId: Int!
  status: Int!
  createdAt: Int!
  updatedAt: Int!
  _all: Int!
}

type UserFileAvgAggregate {
  id: Float
  userId: Float
  fileId: Float
}

type UserFileSumAggregate {
  id: Int
  userId: Int
  fileId: Int
}

type UserFileMinAggregate {
  id: Int
  userId: Int
  fileId: Int
  status: ActiveStatus
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
}

type UserFileMaxAggregate {
  id: Int
  userId: Int
  fileId: Int
  status: ActiveStatus
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
}

type UserFileGroupBy {
  id: Int!
  userId: Int!
  fileId: Int!
  status: ActiveStatus!
  createdAt: DateTimeISO!
  updatedAt: DateTimeISO!
  _count: UserFileCountAggregate
  _avg: UserFileAvgAggregate
  _sum: UserFileSumAggregate
  _min: UserFileMinAggregate
  _max: UserFileMaxAggregate
}

input UserFileOrderByWithAggregationInput {
  id: SortOrder
  userId: SortOrder
  fileId: SortOrder
  status: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  _count: UserFileCountOrderByAggregateInput
  _avg: UserFileAvgOrderByAggregateInput
  _max: UserFileMaxOrderByAggregateInput
  _min: UserFileMinOrderByAggregateInput
  _sum: UserFileSumOrderByAggregateInput
}

input UserFileCountOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
  fileId: SortOrder
  status: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
}

input UserFileAvgOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
  fileId: SortOrder
}

input UserFileMaxOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
  fileId: SortOrder
  status: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
}

input UserFileMinOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
  fileId: SortOrder
  status: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
}

input UserFileSumOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
  fileId: SortOrder
}

input UserFileScalarWhereWithAggregatesInput {
  AND: [UserFileScalarWhereWithAggregatesInput!]
  OR: [UserFileScalarWhereWithAggregatesInput!]
  NOT: [UserFileScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  userId: IntWithAggregatesFilter
  fileId: IntWithAggregatesFilter
  status: EnumActiveStatusWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type AggregateVerificationToken {
  _count: VerificationTokenCountAggregate
  _min: VerificationTokenMinAggregate
  _max: VerificationTokenMaxAggregate
}

type VerificationTokenCountAggregate {
  identifier: Int!
  token: Int!
  expires: Int!
  _all: Int!
}

type VerificationTokenMinAggregate {
  identifier: String
  token: String
  expires: DateTimeISO
}

type VerificationTokenMaxAggregate {
  identifier: String
  token: String
  expires: DateTimeISO
}

input VerificationTokenWhereInput {
  AND: [VerificationTokenWhereInput!]
  OR: [VerificationTokenWhereInput!]
  NOT: [VerificationTokenWhereInput!]
  identifier: StringFilter
  token: StringFilter
  expires: DateTimeFilter
}

input VerificationTokenOrderByWithRelationInput {
  identifier: SortOrder
  token: SortOrder
  expires: SortOrder
}

input VerificationTokenWhereUniqueInput {
  identifier_token: VerificationTokenIdentifierTokenCompoundUniqueInput
  AND: [VerificationTokenWhereInput!]
  OR: [VerificationTokenWhereInput!]
  NOT: [VerificationTokenWhereInput!]
  identifier: StringFilter
  token: StringFilter
  expires: DateTimeFilter
}

input VerificationTokenIdentifierTokenCompoundUniqueInput {
  identifier: String!
  token: String!
}

type VerificationToken {
  identifier: String!
  token: String!
  expires: DateTimeISO!
}

enum VerificationTokenScalarFieldEnum {
  identifier
  token
  expires
}

type VerificationTokenGroupBy {
  identifier: String!
  token: String!
  expires: DateTimeISO!
  _count: VerificationTokenCountAggregate
  _min: VerificationTokenMinAggregate
  _max: VerificationTokenMaxAggregate
}

input VerificationTokenOrderByWithAggregationInput {
  identifier: SortOrder
  token: SortOrder
  expires: SortOrder
  _count: VerificationTokenCountOrderByAggregateInput
  _max: VerificationTokenMaxOrderByAggregateInput
  _min: VerificationTokenMinOrderByAggregateInput
}

input VerificationTokenCountOrderByAggregateInput {
  identifier: SortOrder
  token: SortOrder
  expires: SortOrder
}

input VerificationTokenMaxOrderByAggregateInput {
  identifier: SortOrder
  token: SortOrder
  expires: SortOrder
}

input VerificationTokenMinOrderByAggregateInput {
  identifier: SortOrder
  token: SortOrder
  expires: SortOrder
}

input VerificationTokenScalarWhereWithAggregatesInput {
  AND: [VerificationTokenScalarWhereWithAggregatesInput!]
  OR: [VerificationTokenScalarWhereWithAggregatesInput!]
  NOT: [VerificationTokenScalarWhereWithAggregatesInput!]
  identifier: StringWithAggregatesFilter
  token: StringWithAggregatesFilter
  expires: DateTimeWithAggregatesFilter
}

type Mutation {
  createManyAccount(data: [AccountCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOneAccount(data: AccountCreateInput!, relationLoadStrategy: RelationLoadStrategy): Account!
  deleteManyAccount(where: AccountWhereInput): AffectedRowsOutput!
  deleteOneAccount(where: AccountWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): Account
  updateManyAccount(data: AccountUpdateManyMutationInput!, where: AccountWhereInput): AffectedRowsOutput!
  updateOneAccount(
    data: AccountUpdateInput!
    where: AccountWhereUniqueInput!
    relationLoadStrategy: RelationLoadStrategy
  ): Account
  upsertOneAccount(
    where: AccountWhereUniqueInput!
    create: AccountCreateInput!
    update: AccountUpdateInput!
    relationLoadStrategy: RelationLoadStrategy
  ): Account!
  deleteManyAddress(where: AddressWhereInput): AffectedRowsOutput!
  deleteOneAddress(where: AddressWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): Address
  updateManyAddress(data: AddressUpdateManyMutationInput!, where: AddressWhereInput): AffectedRowsOutput!
  updateOneAddress(
    data: AddressUpdateInput!
    where: AddressWhereUniqueInput!
    relationLoadStrategy: RelationLoadStrategy
  ): Address
  createManyChat(data: [ChatCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOneChat(data: ChatCreateInput!, relationLoadStrategy: RelationLoadStrategy): Chat!
  deleteManyChat(where: ChatWhereInput): AffectedRowsOutput!
  deleteOneChat(where: ChatWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): Chat
  updateManyChat(data: ChatUpdateManyMutationInput!, where: ChatWhereInput): AffectedRowsOutput!
  updateOneChat(data: ChatUpdateInput!, where: ChatWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): Chat
  upsertOneChat(
    where: ChatWhereUniqueInput!
    create: ChatCreateInput!
    update: ChatUpdateInput!
    relationLoadStrategy: RelationLoadStrategy
  ): Chat!
  createManyChatMessage(data: [ChatMessageCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOneChatMessage(data: ChatMessageCreateInput!, relationLoadStrategy: RelationLoadStrategy): ChatMessage!
  deleteManyChatMessage(where: ChatMessageWhereInput): AffectedRowsOutput!
  deleteOneChatMessage(where: ChatMessageWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): ChatMessage
  updateManyChatMessage(data: ChatMessageUpdateManyMutationInput!, where: ChatMessageWhereInput): AffectedRowsOutput!
  updateOneChatMessage(
    data: ChatMessageUpdateInput!
    where: ChatMessageWhereUniqueInput!
    relationLoadStrategy: RelationLoadStrategy
  ): ChatMessage
  upsertOneChatMessage(
    where: ChatMessageWhereUniqueInput!
    create: ChatMessageCreateInput!
    update: ChatMessageUpdateInput!
    relationLoadStrategy: RelationLoadStrategy
  ): ChatMessage!
  createManyChatUser(data: [ChatUserCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOneChatUser(data: ChatUserCreateInput!, relationLoadStrategy: RelationLoadStrategy): ChatUser!
  deleteManyChatUser(where: ChatUserWhereInput): AffectedRowsOutput!
  deleteOneChatUser(where: ChatUserWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): ChatUser
  updateManyChatUser(data: ChatUserUpdateManyMutationInput!, where: ChatUserWhereInput): AffectedRowsOutput!
  updateOneChatUser(
    data: ChatUserUpdateInput!
    where: ChatUserWhereUniqueInput!
    relationLoadStrategy: RelationLoadStrategy
  ): ChatUser
  upsertOneChatUser(
    where: ChatUserWhereUniqueInput!
    create: ChatUserCreateInput!
    update: ChatUserUpdateInput!
    relationLoadStrategy: RelationLoadStrategy
  ): ChatUser!
  createManyComment(data: [CommentCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOneComment(data: CommentCreateInput!, relationLoadStrategy: RelationLoadStrategy): Comment!
  deleteManyComment(where: CommentWhereInput): AffectedRowsOutput!
  deleteOneComment(where: CommentWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): Comment
  updateManyComment(data: CommentUpdateManyMutationInput!, where: CommentWhereInput): AffectedRowsOutput!
  updateOneComment(
    data: CommentUpdateInput!
    where: CommentWhereUniqueInput!
    relationLoadStrategy: RelationLoadStrategy
  ): Comment
  upsertOneComment(
    where: CommentWhereUniqueInput!
    create: CommentCreateInput!
    update: CommentUpdateInput!
    relationLoadStrategy: RelationLoadStrategy
  ): Comment!
  createManyFile(data: [FileCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOneFile(data: FileCreateInput!, relationLoadStrategy: RelationLoadStrategy): File!
  deleteManyFile(where: FileWhereInput): AffectedRowsOutput!
  deleteOneFile(where: FileWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): File
  updateManyFile(data: FileUpdateManyMutationInput!, where: FileWhereInput): AffectedRowsOutput!
  updateOneFile(data: FileUpdateInput!, where: FileWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): File
  upsertOneFile(
    where: FileWhereUniqueInput!
    create: FileCreateInput!
    update: FileUpdateInput!
    relationLoadStrategy: RelationLoadStrategy
  ): File!
  createManyPost(data: [PostCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOnePost(data: PostCreateInput!, relationLoadStrategy: RelationLoadStrategy): Post!
  deleteManyPost(where: PostWhereInput): AffectedRowsOutput!
  deleteOnePost(where: PostWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): Post
  updateManyPost(data: PostUpdateManyMutationInput!, where: PostWhereInput): AffectedRowsOutput!
  updateOnePost(data: PostUpdateInput!, where: PostWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): Post
  upsertOnePost(
    where: PostWhereUniqueInput!
    create: PostCreateInput!
    update: PostUpdateInput!
    relationLoadStrategy: RelationLoadStrategy
  ): Post!
  createManyPostFile(data: [PostFileCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOnePostFile(data: PostFileCreateInput!, relationLoadStrategy: RelationLoadStrategy): PostFile!
  deleteManyPostFile(where: PostFileWhereInput): AffectedRowsOutput!
  deleteOnePostFile(where: PostFileWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): PostFile
  updateManyPostFile(data: PostFileUpdateManyMutationInput!, where: PostFileWhereInput): AffectedRowsOutput!
  updateOnePostFile(
    data: PostFileUpdateInput!
    where: PostFileWhereUniqueInput!
    relationLoadStrategy: RelationLoadStrategy
  ): PostFile
  upsertOnePostFile(
    where: PostFileWhereUniqueInput!
    create: PostFileCreateInput!
    update: PostFileUpdateInput!
    relationLoadStrategy: RelationLoadStrategy
  ): PostFile!
  createManySession(data: [SessionCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOneSession(data: SessionCreateInput!, relationLoadStrategy: RelationLoadStrategy): Session!
  deleteManySession(where: SessionWhereInput): AffectedRowsOutput!
  deleteOneSession(where: SessionWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): Session
  updateManySession(data: SessionUpdateManyMutationInput!, where: SessionWhereInput): AffectedRowsOutput!
  updateOneSession(
    data: SessionUpdateInput!
    where: SessionWhereUniqueInput!
    relationLoadStrategy: RelationLoadStrategy
  ): Session
  upsertOneSession(
    where: SessionWhereUniqueInput!
    create: SessionCreateInput!
    update: SessionUpdateInput!
    relationLoadStrategy: RelationLoadStrategy
  ): Session!
  createManySpatial_ref_sys(data: [Spatial_ref_sysCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOneSpatial_ref_sys(
    data: Spatial_ref_sysCreateInput!
    relationLoadStrategy: RelationLoadStrategy
  ): Spatial_ref_sys!
  deleteManySpatial_ref_sys(where: Spatial_ref_sysWhereInput): AffectedRowsOutput!
  deleteOneSpatial_ref_sys(
    where: Spatial_ref_sysWhereUniqueInput!
    relationLoadStrategy: RelationLoadStrategy
  ): Spatial_ref_sys
  updateManySpatial_ref_sys(
    data: Spatial_ref_sysUpdateManyMutationInput!
    where: Spatial_ref_sysWhereInput
  ): AffectedRowsOutput!
  updateOneSpatial_ref_sys(
    data: Spatial_ref_sysUpdateInput!
    where: Spatial_ref_sysWhereUniqueInput!
    relationLoadStrategy: RelationLoadStrategy
  ): Spatial_ref_sys
  upsertOneSpatial_ref_sys(
    where: Spatial_ref_sysWhereUniqueInput!
    create: Spatial_ref_sysCreateInput!
    update: Spatial_ref_sysUpdateInput!
    relationLoadStrategy: RelationLoadStrategy
  ): Spatial_ref_sys!
  createManyUser(data: [UserCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOneUser(data: UserCreateInput!, relationLoadStrategy: RelationLoadStrategy): User!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteOneUser(where: UserWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): User
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): User
  upsertOneUser(
    where: UserWhereUniqueInput!
    create: UserCreateInput!
    update: UserUpdateInput!
    relationLoadStrategy: RelationLoadStrategy
  ): User!
  createManyUserAddress(data: [UserAddressCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOneUserAddress(data: UserAddressCreateInput!, relationLoadStrategy: RelationLoadStrategy): UserAddress!
  deleteManyUserAddress(where: UserAddressWhereInput): AffectedRowsOutput!
  deleteOneUserAddress(where: UserAddressWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): UserAddress
  updateManyUserAddress(data: UserAddressUpdateManyMutationInput!, where: UserAddressWhereInput): AffectedRowsOutput!
  updateOneUserAddress(
    data: UserAddressUpdateInput!
    where: UserAddressWhereUniqueInput!
    relationLoadStrategy: RelationLoadStrategy
  ): UserAddress
  upsertOneUserAddress(
    where: UserAddressWhereUniqueInput!
    create: UserAddressCreateInput!
    update: UserAddressUpdateInput!
    relationLoadStrategy: RelationLoadStrategy
  ): UserAddress!
  createManyUserFile(data: [UserFileCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOneUserFile(data: UserFileCreateInput!, relationLoadStrategy: RelationLoadStrategy): UserFile!
  deleteManyUserFile(where: UserFileWhereInput): AffectedRowsOutput!
  deleteOneUserFile(where: UserFileWhereUniqueInput!, relationLoadStrategy: RelationLoadStrategy): UserFile
  updateManyUserFile(data: UserFileUpdateManyMutationInput!, where: UserFileWhereInput): AffectedRowsOutput!
  updateOneUserFile(
    data: UserFileUpdateInput!
    where: UserFileWhereUniqueInput!
    relationLoadStrategy: RelationLoadStrategy
  ): UserFile
  upsertOneUserFile(
    where: UserFileWhereUniqueInput!
    create: UserFileCreateInput!
    update: UserFileUpdateInput!
    relationLoadStrategy: RelationLoadStrategy
  ): UserFile!
  createManyVerificationToken(data: [VerificationTokenCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOneVerificationToken(
    data: VerificationTokenCreateInput!
    relationLoadStrategy: RelationLoadStrategy
  ): VerificationToken!
  deleteManyVerificationToken(where: VerificationTokenWhereInput): AffectedRowsOutput!
  deleteOneVerificationToken(
    where: VerificationTokenWhereUniqueInput!
    relationLoadStrategy: RelationLoadStrategy
  ): VerificationToken
  updateManyVerificationToken(
    data: VerificationTokenUpdateManyMutationInput!
    where: VerificationTokenWhereInput
  ): AffectedRowsOutput!
  updateOneVerificationToken(
    data: VerificationTokenUpdateInput!
    where: VerificationTokenWhereUniqueInput!
    relationLoadStrategy: RelationLoadStrategy
  ): VerificationToken
  upsertOneVerificationToken(
    where: VerificationTokenWhereUniqueInput!
    create: VerificationTokenCreateInput!
    update: VerificationTokenUpdateInput!
    relationLoadStrategy: RelationLoadStrategy
  ): VerificationToken!
}

type AffectedRowsOutput {
  count: Int!
}

input AccountCreateManyInput {
  type: String!
  provider: String!
  providerAccountId: String!
  refresh_token: String
  access_token: String
  expires_at: Int
  token_type: String
  scope: String
  id_token: String
  session_state: String
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  userId: Int!
}

input AccountCreateInput {
  type: String!
  provider: String!
  providerAccountId: String!
  refresh_token: String
  access_token: String
  expires_at: Int
  token_type: String
  scope: String
  id_token: String
  session_state: String
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  user: UserCreateNestedOneWithoutAccountsInput!
}

input UserCreateNestedOneWithoutAccountsInput {
  create: UserCreateWithoutAccountsInput
  connectOrCreate: UserCreateOrConnectWithoutAccountsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutAccountsInput {
  content: String
  babyBirth: DateTimeISO
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  email: String!
  emailVerified: DateTimeISO
  image: String
  name: String
  username: String
  role: Role
  chats: ChatUserCreateNestedManyWithoutUserInput
  comments: CommentCreateNestedManyWithoutUserInput
  posts: PostCreateNestedManyWithoutUserInput
  sessions: SessionCreateNestedManyWithoutUserInput
  addresses: UserAddressCreateNestedManyWithoutUserInput
  files: UserFileCreateNestedManyWithoutUserInput
  chatMessages: ChatMessageCreateNestedManyWithoutUserInput
}

input ChatUserCreateNestedManyWithoutUserInput {
  create: [ChatUserCreateWithoutUserInput!]
  connectOrCreate: [ChatUserCreateOrConnectWithoutUserInput!]
  createMany: ChatUserCreateManyUserInputEnvelope
  connect: [ChatUserWhereUniqueInput!]
}

input ChatUserCreateWithoutUserInput {
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  chat: ChatCreateNestedOneWithoutUsersInput!
}

input ChatCreateNestedOneWithoutUsersInput {
  create: ChatCreateWithoutUsersInput
  connectOrCreate: ChatCreateOrConnectWithoutUsersInput
  connect: ChatWhereUniqueInput
}

input ChatCreateWithoutUsersInput {
  name: String
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  messages: ChatMessageCreateNestedManyWithoutChatInput
}

input ChatMessageCreateNestedManyWithoutChatInput {
  create: [ChatMessageCreateWithoutChatInput!]
  connectOrCreate: [ChatMessageCreateOrConnectWithoutChatInput!]
  createMany: ChatMessageCreateManyChatInputEnvelope
  connect: [ChatMessageWhereUniqueInput!]
}

input ChatMessageCreateWithoutChatInput {
  message: String!
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  user: UserCreateNestedOneWithoutChatMessagesInput!
}

input UserCreateNestedOneWithoutChatMessagesInput {
  create: UserCreateWithoutChatMessagesInput
  connectOrCreate: UserCreateOrConnectWithoutChatMessagesInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutChatMessagesInput {
  content: String
  babyBirth: DateTimeISO
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  email: String!
  emailVerified: DateTimeISO
  image: String
  name: String
  username: String
  role: Role
  accounts: AccountCreateNestedManyWithoutUserInput
  chats: ChatUserCreateNestedManyWithoutUserInput
  comments: CommentCreateNestedManyWithoutUserInput
  posts: PostCreateNestedManyWithoutUserInput
  sessions: SessionCreateNestedManyWithoutUserInput
  addresses: UserAddressCreateNestedManyWithoutUserInput
  files: UserFileCreateNestedManyWithoutUserInput
}

input AccountCreateNestedManyWithoutUserInput {
  create: [AccountCreateWithoutUserInput!]
  connectOrCreate: [AccountCreateOrConnectWithoutUserInput!]
  createMany: AccountCreateManyUserInputEnvelope
  connect: [AccountWhereUniqueInput!]
}

input AccountCreateWithoutUserInput {
  type: String!
  provider: String!
  providerAccountId: String!
  refresh_token: String
  access_token: String
  expires_at: Int
  token_type: String
  scope: String
  id_token: String
  session_state: String
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
}

input AccountCreateOrConnectWithoutUserInput {
  where: AccountWhereUniqueInput!
  create: AccountCreateWithoutUserInput!
}

input AccountCreateManyUserInputEnvelope {
  data: [AccountCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input AccountCreateManyUserInput {
  type: String!
  provider: String!
  providerAccountId: String!
  refresh_token: String
  access_token: String
  expires_at: Int
  token_type: String
  scope: String
  id_token: String
  session_state: String
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
}

input CommentCreateNestedManyWithoutUserInput {
  create: [CommentCreateWithoutUserInput!]
  connectOrCreate: [CommentCreateOrConnectWithoutUserInput!]
  createMany: CommentCreateManyUserInputEnvelope
  connect: [CommentWhereUniqueInput!]
}

input CommentCreateWithoutUserInput {
  content: String!
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  post: PostCreateNestedOneWithoutCommentsInput!
}

input PostCreateNestedOneWithoutCommentsInput {
  create: PostCreateWithoutCommentsInput
  connectOrCreate: PostCreateOrConnectWithoutCommentsInput
  connect: PostWhereUniqueInput
}

input PostCreateWithoutCommentsInput {
  content: String!
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  files: PostFileCreateNestedManyWithoutPostInput
  address: AddressCreateNestedOneWithoutPostsInput!
  user: UserCreateNestedOneWithoutPostsInput!
}

input PostFileCreateNestedManyWithoutPostInput {
  create: [PostFileCreateWithoutPostInput!]
  connectOrCreate: [PostFileCreateOrConnectWithoutPostInput!]
  createMany: PostFileCreateManyPostInputEnvelope
  connect: [PostFileWhereUniqueInput!]
}

input PostFileCreateWithoutPostInput {
  status: ActiveStatus
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  file: FileCreateNestedOneWithoutPostsInput!
}

input FileCreateNestedOneWithoutPostsInput {
  create: FileCreateWithoutPostsInput
  connectOrCreate: FileCreateOrConnectWithoutPostsInput
  connect: FileWhereUniqueInput
}

input FileCreateWithoutPostsInput {
  location: String!
  type: FileStorageType
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  files: UserFileCreateNestedManyWithoutFileInput
}

input UserFileCreateNestedManyWithoutFileInput {
  create: [UserFileCreateWithoutFileInput!]
  connectOrCreate: [UserFileCreateOrConnectWithoutFileInput!]
  createMany: UserFileCreateManyFileInputEnvelope
  connect: [UserFileWhereUniqueInput!]
}

input UserFileCreateWithoutFileInput {
  status: ActiveStatus
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  user: UserCreateNestedOneWithoutFilesInput!
}

input UserCreateNestedOneWithoutFilesInput {
  create: UserCreateWithoutFilesInput
  connectOrCreate: UserCreateOrConnectWithoutFilesInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutFilesInput {
  content: String
  babyBirth: DateTimeISO
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  email: String!
  emailVerified: DateTimeISO
  image: String
  name: String
  username: String
  role: Role
  accounts: AccountCreateNestedManyWithoutUserInput
  chats: ChatUserCreateNestedManyWithoutUserInput
  comments: CommentCreateNestedManyWithoutUserInput
  posts: PostCreateNestedManyWithoutUserInput
  sessions: SessionCreateNestedManyWithoutUserInput
  addresses: UserAddressCreateNestedManyWithoutUserInput
  chatMessages: ChatMessageCreateNestedManyWithoutUserInput
}

input PostCreateNestedManyWithoutUserInput {
  create: [PostCreateWithoutUserInput!]
  connectOrCreate: [PostCreateOrConnectWithoutUserInput!]
  createMany: PostCreateManyUserInputEnvelope
  connect: [PostWhereUniqueInput!]
}

input PostCreateWithoutUserInput {
  content: String!
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  comments: CommentCreateNestedManyWithoutPostInput
  files: PostFileCreateNestedManyWithoutPostInput
  address: AddressCreateNestedOneWithoutPostsInput!
}

input CommentCreateNestedManyWithoutPostInput {
  create: [CommentCreateWithoutPostInput!]
  connectOrCreate: [CommentCreateOrConnectWithoutPostInput!]
  createMany: CommentCreateManyPostInputEnvelope
  connect: [CommentWhereUniqueInput!]
}

input CommentCreateWithoutPostInput {
  content: String!
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  user: UserCreateNestedOneWithoutCommentsInput!
}

input UserCreateNestedOneWithoutCommentsInput {
  create: UserCreateWithoutCommentsInput
  connectOrCreate: UserCreateOrConnectWithoutCommentsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutCommentsInput {
  content: String
  babyBirth: DateTimeISO
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  email: String!
  emailVerified: DateTimeISO
  image: String
  name: String
  username: String
  role: Role
  accounts: AccountCreateNestedManyWithoutUserInput
  chats: ChatUserCreateNestedManyWithoutUserInput
  posts: PostCreateNestedManyWithoutUserInput
  sessions: SessionCreateNestedManyWithoutUserInput
  addresses: UserAddressCreateNestedManyWithoutUserInput
  files: UserFileCreateNestedManyWithoutUserInput
  chatMessages: ChatMessageCreateNestedManyWithoutUserInput
}

input SessionCreateNestedManyWithoutUserInput {
  create: [SessionCreateWithoutUserInput!]
  connectOrCreate: [SessionCreateOrConnectWithoutUserInput!]
  createMany: SessionCreateManyUserInputEnvelope
  connect: [SessionWhereUniqueInput!]
}

input SessionCreateWithoutUserInput {
  sessionToken: String!
  expires: DateTimeISO!
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
}

input SessionCreateOrConnectWithoutUserInput {
  where: SessionWhereUniqueInput!
  create: SessionCreateWithoutUserInput!
}

input SessionCreateManyUserInputEnvelope {
  data: [SessionCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input SessionCreateManyUserInput {
  sessionToken: String!
  expires: DateTimeISO!
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
}

input UserAddressCreateNestedManyWithoutUserInput {
  create: [UserAddressCreateWithoutUserInput!]
  connectOrCreate: [UserAddressCreateOrConnectWithoutUserInput!]
  createMany: UserAddressCreateManyUserInputEnvelope
  connect: [UserAddressWhereUniqueInput!]
}

input UserAddressCreateWithoutUserInput {
  status: ActiveStatus
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  address: AddressCreateNestedOneWithoutUsersInput!
}

input AddressCreateNestedOneWithoutUsersInput {
  connect: AddressWhereUniqueInput
}

input UserAddressCreateOrConnectWithoutUserInput {
  where: UserAddressWhereUniqueInput!
  create: UserAddressCreateWithoutUserInput!
}

input UserAddressCreateManyUserInputEnvelope {
  data: [UserAddressCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input UserAddressCreateManyUserInput {
  id: Int
  addressId: Int!
  status: ActiveStatus
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
}

input UserFileCreateNestedManyWithoutUserInput {
  create: [UserFileCreateWithoutUserInput!]
  connectOrCreate: [UserFileCreateOrConnectWithoutUserInput!]
  createMany: UserFileCreateManyUserInputEnvelope
  connect: [UserFileWhereUniqueInput!]
}

input UserFileCreateWithoutUserInput {
  status: ActiveStatus
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  file: FileCreateNestedOneWithoutFilesInput!
}

input FileCreateNestedOneWithoutFilesInput {
  create: FileCreateWithoutFilesInput
  connectOrCreate: FileCreateOrConnectWithoutFilesInput
  connect: FileWhereUniqueInput
}

input FileCreateWithoutFilesInput {
  location: String!
  type: FileStorageType
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  posts: PostFileCreateNestedManyWithoutFileInput
}

input PostFileCreateNestedManyWithoutFileInput {
  create: [PostFileCreateWithoutFileInput!]
  connectOrCreate: [PostFileCreateOrConnectWithoutFileInput!]
  createMany: PostFileCreateManyFileInputEnvelope
  connect: [PostFileWhereUniqueInput!]
}

input PostFileCreateWithoutFileInput {
  status: ActiveStatus
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  post: PostCreateNestedOneWithoutFilesInput!
}

input PostCreateNestedOneWithoutFilesInput {
  create: PostCreateWithoutFilesInput
  connectOrCreate: PostCreateOrConnectWithoutFilesInput
  connect: PostWhereUniqueInput
}

input PostCreateWithoutFilesInput {
  content: String!
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  comments: CommentCreateNestedManyWithoutPostInput
  address: AddressCreateNestedOneWithoutPostsInput!
  user: UserCreateNestedOneWithoutPostsInput!
}

input AddressCreateNestedOneWithoutPostsInput {
  connect: AddressWhereUniqueInput
}

input UserCreateNestedOneWithoutPostsInput {
  create: UserCreateWithoutPostsInput
  connectOrCreate: UserCreateOrConnectWithoutPostsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutPostsInput {
  content: String
  babyBirth: DateTimeISO
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  email: String!
  emailVerified: DateTimeISO
  image: String
  name: String
  username: String
  role: Role
  accounts: AccountCreateNestedManyWithoutUserInput
  chats: ChatUserCreateNestedManyWithoutUserInput
  comments: CommentCreateNestedManyWithoutUserInput
  sessions: SessionCreateNestedManyWithoutUserInput
  addresses: UserAddressCreateNestedManyWithoutUserInput
  files: UserFileCreateNestedManyWithoutUserInput
  chatMessages: ChatMessageCreateNestedManyWithoutUserInput
}

input ChatMessageCreateNestedManyWithoutUserInput {
  create: [ChatMessageCreateWithoutUserInput!]
  connectOrCreate: [ChatMessageCreateOrConnectWithoutUserInput!]
  createMany: ChatMessageCreateManyUserInputEnvelope
  connect: [ChatMessageWhereUniqueInput!]
}

input ChatMessageCreateWithoutUserInput {
  message: String!
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  chat: ChatCreateNestedOneWithoutMessagesInput!
}

input ChatCreateNestedOneWithoutMessagesInput {
  create: ChatCreateWithoutMessagesInput
  connectOrCreate: ChatCreateOrConnectWithoutMessagesInput
  connect: ChatWhereUniqueInput
}

input ChatCreateWithoutMessagesInput {
  name: String
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  users: ChatUserCreateNestedManyWithoutChatInput
}

input ChatUserCreateNestedManyWithoutChatInput {
  create: [ChatUserCreateWithoutChatInput!]
  connectOrCreate: [ChatUserCreateOrConnectWithoutChatInput!]
  createMany: ChatUserCreateManyChatInputEnvelope
  connect: [ChatUserWhereUniqueInput!]
}

input ChatUserCreateWithoutChatInput {
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  user: UserCreateNestedOneWithoutChatsInput!
}

input UserCreateNestedOneWithoutChatsInput {
  create: UserCreateWithoutChatsInput
  connectOrCreate: UserCreateOrConnectWithoutChatsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutChatsInput {
  content: String
  babyBirth: DateTimeISO
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  email: String!
  emailVerified: DateTimeISO
  image: String
  name: String
  username: String
  role: Role
  accounts: AccountCreateNestedManyWithoutUserInput
  comments: CommentCreateNestedManyWithoutUserInput
  posts: PostCreateNestedManyWithoutUserInput
  sessions: SessionCreateNestedManyWithoutUserInput
  addresses: UserAddressCreateNestedManyWithoutUserInput
  files: UserFileCreateNestedManyWithoutUserInput
  chatMessages: ChatMessageCreateNestedManyWithoutUserInput
}

input UserCreateOrConnectWithoutChatsInput {
  where: UserWhereUniqueInput!
  create: UserCreateWithoutChatsInput!
}

input ChatUserCreateOrConnectWithoutChatInput {
  where: ChatUserWhereUniqueInput!
  create: ChatUserCreateWithoutChatInput!
}

input ChatUserCreateManyChatInputEnvelope {
  data: [ChatUserCreateManyChatInput!]!
  skipDuplicates: Boolean
}

input ChatUserCreateManyChatInput {
  id: Int
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  userId: Int!
}

input ChatCreateOrConnectWithoutMessagesInput {
  where: ChatWhereUniqueInput!
  create: ChatCreateWithoutMessagesInput!
}

input ChatMessageCreateOrConnectWithoutUserInput {
  where: ChatMessageWhereUniqueInput!
  create: ChatMessageCreateWithoutUserInput!
}

input ChatMessageCreateManyUserInputEnvelope {
  data: [ChatMessageCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input ChatMessageCreateManyUserInput {
  id: Int
  message: String!
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  chatId: Int!
}

input UserCreateOrConnectWithoutPostsInput {
  where: UserWhereUniqueInput!
  create: UserCreateWithoutPostsInput!
}

input PostCreateOrConnectWithoutFilesInput {
  where: PostWhereUniqueInput!
  create: PostCreateWithoutFilesInput!
}

input PostFileCreateOrConnectWithoutFileInput {
  where: PostFileWhereUniqueInput!
  create: PostFileCreateWithoutFileInput!
}

input PostFileCreateManyFileInputEnvelope {
  data: [PostFileCreateManyFileInput!]!
  skipDuplicates: Boolean
}

input PostFileCreateManyFileInput {
  id: Int
  postId: Int!
  status: ActiveStatus
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
}

input FileCreateOrConnectWithoutFilesInput {
  where: FileWhereUniqueInput!
  create: FileCreateWithoutFilesInput!
}

input UserFileCreateOrConnectWithoutUserInput {
  where: UserFileWhereUniqueInput!
  create: UserFileCreateWithoutUserInput!
}

input UserFileCreateManyUserInputEnvelope {
  data: [UserFileCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input UserFileCreateManyUserInput {
  id: Int
  fileId: Int!
  status: ActiveStatus
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
}

input UserCreateOrConnectWithoutCommentsInput {
  where: UserWhereUniqueInput!
  create: UserCreateWithoutCommentsInput!
}

input CommentCreateOrConnectWithoutPostInput {
  where: CommentWhereUniqueInput!
  create: CommentCreateWithoutPostInput!
}

input CommentCreateManyPostInputEnvelope {
  data: [CommentCreateManyPostInput!]!
  skipDuplicates: Boolean
}

input CommentCreateManyPostInput {
  id: Int
  content: String!
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  userId: Int!
}

input PostCreateOrConnectWithoutUserInput {
  where: PostWhereUniqueInput!
  create: PostCreateWithoutUserInput!
}

input PostCreateManyUserInputEnvelope {
  data: [PostCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input PostCreateManyUserInput {
  id: Int
  content: String!
  addressId: Int!
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
}

input UserCreateOrConnectWithoutFilesInput {
  where: UserWhereUniqueInput!
  create: UserCreateWithoutFilesInput!
}

input UserFileCreateOrConnectWithoutFileInput {
  where: UserFileWhereUniqueInput!
  create: UserFileCreateWithoutFileInput!
}

input UserFileCreateManyFileInputEnvelope {
  data: [UserFileCreateManyFileInput!]!
  skipDuplicates: Boolean
}

input UserFileCreateManyFileInput {
  id: Int
  userId: Int!
  status: ActiveStatus
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
}

input FileCreateOrConnectWithoutPostsInput {
  where: FileWhereUniqueInput!
  create: FileCreateWithoutPostsInput!
}

input PostFileCreateOrConnectWithoutPostInput {
  where: PostFileWhereUniqueInput!
  create: PostFileCreateWithoutPostInput!
}

input PostFileCreateManyPostInputEnvelope {
  data: [PostFileCreateManyPostInput!]!
  skipDuplicates: Boolean
}

input PostFileCreateManyPostInput {
  id: Int
  fileId: Int!
  status: ActiveStatus
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
}

input PostCreateOrConnectWithoutCommentsInput {
  where: PostWhereUniqueInput!
  create: PostCreateWithoutCommentsInput!
}

input CommentCreateOrConnectWithoutUserInput {
  where: CommentWhereUniqueInput!
  create: CommentCreateWithoutUserInput!
}

input CommentCreateManyUserInputEnvelope {
  data: [CommentCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input CommentCreateManyUserInput {
  id: Int
  content: String!
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  postId: Int!
}

input UserCreateOrConnectWithoutChatMessagesInput {
  where: UserWhereUniqueInput!
  create: UserCreateWithoutChatMessagesInput!
}

input ChatMessageCreateOrConnectWithoutChatInput {
  where: ChatMessageWhereUniqueInput!
  create: ChatMessageCreateWithoutChatInput!
}

input ChatMessageCreateManyChatInputEnvelope {
  data: [ChatMessageCreateManyChatInput!]!
  skipDuplicates: Boolean
}

input ChatMessageCreateManyChatInput {
  id: Int
  message: String!
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  userId: Int!
}

input ChatCreateOrConnectWithoutUsersInput {
  where: ChatWhereUniqueInput!
  create: ChatCreateWithoutUsersInput!
}

input ChatUserCreateOrConnectWithoutUserInput {
  where: ChatUserWhereUniqueInput!
  create: ChatUserCreateWithoutUserInput!
}

input ChatUserCreateManyUserInputEnvelope {
  data: [ChatUserCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input ChatUserCreateManyUserInput {
  id: Int
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  chatId: Int!
}

input UserCreateOrConnectWithoutAccountsInput {
  where: UserWhereUniqueInput!
  create: UserCreateWithoutAccountsInput!
}

input AccountUpdateManyMutationInput {
  type: StringFieldUpdateOperationsInput
  provider: StringFieldUpdateOperationsInput
  providerAccountId: StringFieldUpdateOperationsInput
  refresh_token: NullableStringFieldUpdateOperationsInput
  access_token: NullableStringFieldUpdateOperationsInput
  expires_at: NullableIntFieldUpdateOperationsInput
  token_type: NullableStringFieldUpdateOperationsInput
  scope: NullableStringFieldUpdateOperationsInput
  id_token: NullableStringFieldUpdateOperationsInput
  session_state: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input StringFieldUpdateOperationsInput {
  set: String
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

input NullableIntFieldUpdateOperationsInput {
  set: Int
  increment: Int
  decrement: Int
  multiply: Int
  divide: Int
}

input DateTimeFieldUpdateOperationsInput {
  set: DateTimeISO
}

input AccountUpdateInput {
  type: StringFieldUpdateOperationsInput
  provider: StringFieldUpdateOperationsInput
  providerAccountId: StringFieldUpdateOperationsInput
  refresh_token: NullableStringFieldUpdateOperationsInput
  access_token: NullableStringFieldUpdateOperationsInput
  expires_at: NullableIntFieldUpdateOperationsInput
  token_type: NullableStringFieldUpdateOperationsInput
  scope: NullableStringFieldUpdateOperationsInput
  id_token: NullableStringFieldUpdateOperationsInput
  session_state: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutAccountsNestedInput
}

input UserUpdateOneRequiredWithoutAccountsNestedInput {
  create: UserCreateWithoutAccountsInput
  connectOrCreate: UserCreateOrConnectWithoutAccountsInput
  upsert: UserUpsertWithoutAccountsInput
  connect: UserWhereUniqueInput
  update: UserUpdateToOneWithWhereWithoutAccountsInput
}

input UserUpsertWithoutAccountsInput {
  update: UserUpdateWithoutAccountsInput!
  create: UserCreateWithoutAccountsInput!
  where: UserWhereInput
}

input UserUpdateWithoutAccountsInput {
  content: NullableStringFieldUpdateOperationsInput
  babyBirth: NullableDateTimeFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  username: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  chats: ChatUserUpdateManyWithoutUserNestedInput
  comments: CommentUpdateManyWithoutUserNestedInput
  posts: PostUpdateManyWithoutUserNestedInput
  sessions: SessionUpdateManyWithoutUserNestedInput
  addresses: UserAddressUpdateManyWithoutUserNestedInput
  files: UserFileUpdateManyWithoutUserNestedInput
  chatMessages: ChatMessageUpdateManyWithoutUserNestedInput
}

input NullableDateTimeFieldUpdateOperationsInput {
  set: DateTimeISO
}

input EnumRoleFieldUpdateOperationsInput {
  set: Role
}

input ChatUserUpdateManyWithoutUserNestedInput {
  create: [ChatUserCreateWithoutUserInput!]
  connectOrCreate: [ChatUserCreateOrConnectWithoutUserInput!]
  upsert: [ChatUserUpsertWithWhereUniqueWithoutUserInput!]
  createMany: ChatUserCreateManyUserInputEnvelope
  set: [ChatUserWhereUniqueInput!]
  disconnect: [ChatUserWhereUniqueInput!]
  delete: [ChatUserWhereUniqueInput!]
  connect: [ChatUserWhereUniqueInput!]
  update: [ChatUserUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [ChatUserUpdateManyWithWhereWithoutUserInput!]
  deleteMany: [ChatUserScalarWhereInput!]
}

input ChatUserUpsertWithWhereUniqueWithoutUserInput {
  where: ChatUserWhereUniqueInput!
  update: ChatUserUpdateWithoutUserInput!
  create: ChatUserCreateWithoutUserInput!
}

input ChatUserUpdateWithoutUserInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  chat: ChatUpdateOneRequiredWithoutUsersNestedInput
}

input ChatUpdateOneRequiredWithoutUsersNestedInput {
  create: ChatCreateWithoutUsersInput
  connectOrCreate: ChatCreateOrConnectWithoutUsersInput
  upsert: ChatUpsertWithoutUsersInput
  connect: ChatWhereUniqueInput
  update: ChatUpdateToOneWithWhereWithoutUsersInput
}

input ChatUpsertWithoutUsersInput {
  update: ChatUpdateWithoutUsersInput!
  create: ChatCreateWithoutUsersInput!
  where: ChatWhereInput
}

input ChatUpdateWithoutUsersInput {
  name: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  messages: ChatMessageUpdateManyWithoutChatNestedInput
}

input ChatMessageUpdateManyWithoutChatNestedInput {
  create: [ChatMessageCreateWithoutChatInput!]
  connectOrCreate: [ChatMessageCreateOrConnectWithoutChatInput!]
  upsert: [ChatMessageUpsertWithWhereUniqueWithoutChatInput!]
  createMany: ChatMessageCreateManyChatInputEnvelope
  set: [ChatMessageWhereUniqueInput!]
  disconnect: [ChatMessageWhereUniqueInput!]
  delete: [ChatMessageWhereUniqueInput!]
  connect: [ChatMessageWhereUniqueInput!]
  update: [ChatMessageUpdateWithWhereUniqueWithoutChatInput!]
  updateMany: [ChatMessageUpdateManyWithWhereWithoutChatInput!]
  deleteMany: [ChatMessageScalarWhereInput!]
}

input ChatMessageUpsertWithWhereUniqueWithoutChatInput {
  where: ChatMessageWhereUniqueInput!
  update: ChatMessageUpdateWithoutChatInput!
  create: ChatMessageCreateWithoutChatInput!
}

input ChatMessageUpdateWithoutChatInput {
  message: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutChatMessagesNestedInput
}

input UserUpdateOneRequiredWithoutChatMessagesNestedInput {
  create: UserCreateWithoutChatMessagesInput
  connectOrCreate: UserCreateOrConnectWithoutChatMessagesInput
  upsert: UserUpsertWithoutChatMessagesInput
  connect: UserWhereUniqueInput
  update: UserUpdateToOneWithWhereWithoutChatMessagesInput
}

input UserUpsertWithoutChatMessagesInput {
  update: UserUpdateWithoutChatMessagesInput!
  create: UserCreateWithoutChatMessagesInput!
  where: UserWhereInput
}

input UserUpdateWithoutChatMessagesInput {
  content: NullableStringFieldUpdateOperationsInput
  babyBirth: NullableDateTimeFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  username: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  accounts: AccountUpdateManyWithoutUserNestedInput
  chats: ChatUserUpdateManyWithoutUserNestedInput
  comments: CommentUpdateManyWithoutUserNestedInput
  posts: PostUpdateManyWithoutUserNestedInput
  sessions: SessionUpdateManyWithoutUserNestedInput
  addresses: UserAddressUpdateManyWithoutUserNestedInput
  files: UserFileUpdateManyWithoutUserNestedInput
}

input AccountUpdateManyWithoutUserNestedInput {
  create: [AccountCreateWithoutUserInput!]
  connectOrCreate: [AccountCreateOrConnectWithoutUserInput!]
  upsert: [AccountUpsertWithWhereUniqueWithoutUserInput!]
  createMany: AccountCreateManyUserInputEnvelope
  set: [AccountWhereUniqueInput!]
  disconnect: [AccountWhereUniqueInput!]
  delete: [AccountWhereUniqueInput!]
  connect: [AccountWhereUniqueInput!]
  update: [AccountUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [AccountUpdateManyWithWhereWithoutUserInput!]
  deleteMany: [AccountScalarWhereInput!]
}

input AccountUpsertWithWhereUniqueWithoutUserInput {
  where: AccountWhereUniqueInput!
  update: AccountUpdateWithoutUserInput!
  create: AccountCreateWithoutUserInput!
}

input AccountUpdateWithoutUserInput {
  type: StringFieldUpdateOperationsInput
  provider: StringFieldUpdateOperationsInput
  providerAccountId: StringFieldUpdateOperationsInput
  refresh_token: NullableStringFieldUpdateOperationsInput
  access_token: NullableStringFieldUpdateOperationsInput
  expires_at: NullableIntFieldUpdateOperationsInput
  token_type: NullableStringFieldUpdateOperationsInput
  scope: NullableStringFieldUpdateOperationsInput
  id_token: NullableStringFieldUpdateOperationsInput
  session_state: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AccountUpdateWithWhereUniqueWithoutUserInput {
  where: AccountWhereUniqueInput!
  data: AccountUpdateWithoutUserInput!
}

input AccountUpdateManyWithWhereWithoutUserInput {
  where: AccountScalarWhereInput!
  data: AccountUpdateManyMutationInput!
}

input AccountScalarWhereInput {
  AND: [AccountScalarWhereInput!]
  OR: [AccountScalarWhereInput!]
  NOT: [AccountScalarWhereInput!]
  type: StringFilter
  provider: StringFilter
  providerAccountId: StringFilter
  refresh_token: StringNullableFilter
  access_token: StringNullableFilter
  expires_at: IntNullableFilter
  token_type: StringNullableFilter
  scope: StringNullableFilter
  id_token: StringNullableFilter
  session_state: StringNullableFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  userId: IntFilter
}

input CommentUpdateManyWithoutUserNestedInput {
  create: [CommentCreateWithoutUserInput!]
  connectOrCreate: [CommentCreateOrConnectWithoutUserInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutUserInput!]
  createMany: CommentCreateManyUserInputEnvelope
  set: [CommentWhereUniqueInput!]
  disconnect: [CommentWhereUniqueInput!]
  delete: [CommentWhereUniqueInput!]
  connect: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [CommentUpdateManyWithWhereWithoutUserInput!]
  deleteMany: [CommentScalarWhereInput!]
}

input CommentUpsertWithWhereUniqueWithoutUserInput {
  where: CommentWhereUniqueInput!
  update: CommentUpdateWithoutUserInput!
  create: CommentCreateWithoutUserInput!
}

input CommentUpdateWithoutUserInput {
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  post: PostUpdateOneRequiredWithoutCommentsNestedInput
}

input PostUpdateOneRequiredWithoutCommentsNestedInput {
  create: PostCreateWithoutCommentsInput
  connectOrCreate: PostCreateOrConnectWithoutCommentsInput
  upsert: PostUpsertWithoutCommentsInput
  connect: PostWhereUniqueInput
  update: PostUpdateToOneWithWhereWithoutCommentsInput
}

input PostUpsertWithoutCommentsInput {
  update: PostUpdateWithoutCommentsInput!
  create: PostCreateWithoutCommentsInput!
  where: PostWhereInput
}

input PostUpdateWithoutCommentsInput {
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  files: PostFileUpdateManyWithoutPostNestedInput
  address: AddressUpdateOneRequiredWithoutPostsNestedInput
  user: UserUpdateOneRequiredWithoutPostsNestedInput
}

input PostFileUpdateManyWithoutPostNestedInput {
  create: [PostFileCreateWithoutPostInput!]
  connectOrCreate: [PostFileCreateOrConnectWithoutPostInput!]
  upsert: [PostFileUpsertWithWhereUniqueWithoutPostInput!]
  createMany: PostFileCreateManyPostInputEnvelope
  set: [PostFileWhereUniqueInput!]
  disconnect: [PostFileWhereUniqueInput!]
  delete: [PostFileWhereUniqueInput!]
  connect: [PostFileWhereUniqueInput!]
  update: [PostFileUpdateWithWhereUniqueWithoutPostInput!]
  updateMany: [PostFileUpdateManyWithWhereWithoutPostInput!]
  deleteMany: [PostFileScalarWhereInput!]
}

input PostFileUpsertWithWhereUniqueWithoutPostInput {
  where: PostFileWhereUniqueInput!
  update: PostFileUpdateWithoutPostInput!
  create: PostFileCreateWithoutPostInput!
}

input PostFileUpdateWithoutPostInput {
  status: EnumActiveStatusFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  file: FileUpdateOneRequiredWithoutPostsNestedInput
}

input EnumActiveStatusFieldUpdateOperationsInput {
  set: ActiveStatus
}

input FileUpdateOneRequiredWithoutPostsNestedInput {
  create: FileCreateWithoutPostsInput
  connectOrCreate: FileCreateOrConnectWithoutPostsInput
  upsert: FileUpsertWithoutPostsInput
  connect: FileWhereUniqueInput
  update: FileUpdateToOneWithWhereWithoutPostsInput
}

input FileUpsertWithoutPostsInput {
  update: FileUpdateWithoutPostsInput!
  create: FileCreateWithoutPostsInput!
  where: FileWhereInput
}

input FileUpdateWithoutPostsInput {
  location: StringFieldUpdateOperationsInput
  type: EnumFileStorageTypeFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  files: UserFileUpdateManyWithoutFileNestedInput
}

input EnumFileStorageTypeFieldUpdateOperationsInput {
  set: FileStorageType
}

input UserFileUpdateManyWithoutFileNestedInput {
  create: [UserFileCreateWithoutFileInput!]
  connectOrCreate: [UserFileCreateOrConnectWithoutFileInput!]
  upsert: [UserFileUpsertWithWhereUniqueWithoutFileInput!]
  createMany: UserFileCreateManyFileInputEnvelope
  set: [UserFileWhereUniqueInput!]
  disconnect: [UserFileWhereUniqueInput!]
  delete: [UserFileWhereUniqueInput!]
  connect: [UserFileWhereUniqueInput!]
  update: [UserFileUpdateWithWhereUniqueWithoutFileInput!]
  updateMany: [UserFileUpdateManyWithWhereWithoutFileInput!]
  deleteMany: [UserFileScalarWhereInput!]
}

input UserFileUpsertWithWhereUniqueWithoutFileInput {
  where: UserFileWhereUniqueInput!
  update: UserFileUpdateWithoutFileInput!
  create: UserFileCreateWithoutFileInput!
}

input UserFileUpdateWithoutFileInput {
  status: EnumActiveStatusFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutFilesNestedInput
}

input UserUpdateOneRequiredWithoutFilesNestedInput {
  create: UserCreateWithoutFilesInput
  connectOrCreate: UserCreateOrConnectWithoutFilesInput
  upsert: UserUpsertWithoutFilesInput
  connect: UserWhereUniqueInput
  update: UserUpdateToOneWithWhereWithoutFilesInput
}

input UserUpsertWithoutFilesInput {
  update: UserUpdateWithoutFilesInput!
  create: UserCreateWithoutFilesInput!
  where: UserWhereInput
}

input UserUpdateWithoutFilesInput {
  content: NullableStringFieldUpdateOperationsInput
  babyBirth: NullableDateTimeFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  username: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  accounts: AccountUpdateManyWithoutUserNestedInput
  chats: ChatUserUpdateManyWithoutUserNestedInput
  comments: CommentUpdateManyWithoutUserNestedInput
  posts: PostUpdateManyWithoutUserNestedInput
  sessions: SessionUpdateManyWithoutUserNestedInput
  addresses: UserAddressUpdateManyWithoutUserNestedInput
  chatMessages: ChatMessageUpdateManyWithoutUserNestedInput
}

input PostUpdateManyWithoutUserNestedInput {
  create: [PostCreateWithoutUserInput!]
  connectOrCreate: [PostCreateOrConnectWithoutUserInput!]
  upsert: [PostUpsertWithWhereUniqueWithoutUserInput!]
  createMany: PostCreateManyUserInputEnvelope
  set: [PostWhereUniqueInput!]
  disconnect: [PostWhereUniqueInput!]
  delete: [PostWhereUniqueInput!]
  connect: [PostWhereUniqueInput!]
  update: [PostUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [PostUpdateManyWithWhereWithoutUserInput!]
  deleteMany: [PostScalarWhereInput!]
}

input PostUpsertWithWhereUniqueWithoutUserInput {
  where: PostWhereUniqueInput!
  update: PostUpdateWithoutUserInput!
  create: PostCreateWithoutUserInput!
}

input PostUpdateWithoutUserInput {
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  comments: CommentUpdateManyWithoutPostNestedInput
  files: PostFileUpdateManyWithoutPostNestedInput
  address: AddressUpdateOneRequiredWithoutPostsNestedInput
}

input CommentUpdateManyWithoutPostNestedInput {
  create: [CommentCreateWithoutPostInput!]
  connectOrCreate: [CommentCreateOrConnectWithoutPostInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutPostInput!]
  createMany: CommentCreateManyPostInputEnvelope
  set: [CommentWhereUniqueInput!]
  disconnect: [CommentWhereUniqueInput!]
  delete: [CommentWhereUniqueInput!]
  connect: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutPostInput!]
  updateMany: [CommentUpdateManyWithWhereWithoutPostInput!]
  deleteMany: [CommentScalarWhereInput!]
}

input CommentUpsertWithWhereUniqueWithoutPostInput {
  where: CommentWhereUniqueInput!
  update: CommentUpdateWithoutPostInput!
  create: CommentCreateWithoutPostInput!
}

input CommentUpdateWithoutPostInput {
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutCommentsNestedInput
}

input UserUpdateOneRequiredWithoutCommentsNestedInput {
  create: UserCreateWithoutCommentsInput
  connectOrCreate: UserCreateOrConnectWithoutCommentsInput
  upsert: UserUpsertWithoutCommentsInput
  connect: UserWhereUniqueInput
  update: UserUpdateToOneWithWhereWithoutCommentsInput
}

input UserUpsertWithoutCommentsInput {
  update: UserUpdateWithoutCommentsInput!
  create: UserCreateWithoutCommentsInput!
  where: UserWhereInput
}

input UserUpdateWithoutCommentsInput {
  content: NullableStringFieldUpdateOperationsInput
  babyBirth: NullableDateTimeFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  username: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  accounts: AccountUpdateManyWithoutUserNestedInput
  chats: ChatUserUpdateManyWithoutUserNestedInput
  posts: PostUpdateManyWithoutUserNestedInput
  sessions: SessionUpdateManyWithoutUserNestedInput
  addresses: UserAddressUpdateManyWithoutUserNestedInput
  files: UserFileUpdateManyWithoutUserNestedInput
  chatMessages: ChatMessageUpdateManyWithoutUserNestedInput
}

input SessionUpdateManyWithoutUserNestedInput {
  create: [SessionCreateWithoutUserInput!]
  connectOrCreate: [SessionCreateOrConnectWithoutUserInput!]
  upsert: [SessionUpsertWithWhereUniqueWithoutUserInput!]
  createMany: SessionCreateManyUserInputEnvelope
  set: [SessionWhereUniqueInput!]
  disconnect: [SessionWhereUniqueInput!]
  delete: [SessionWhereUniqueInput!]
  connect: [SessionWhereUniqueInput!]
  update: [SessionUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [SessionUpdateManyWithWhereWithoutUserInput!]
  deleteMany: [SessionScalarWhereInput!]
}

input SessionUpsertWithWhereUniqueWithoutUserInput {
  where: SessionWhereUniqueInput!
  update: SessionUpdateWithoutUserInput!
  create: SessionCreateWithoutUserInput!
}

input SessionUpdateWithoutUserInput {
  sessionToken: StringFieldUpdateOperationsInput
  expires: DateTimeFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SessionUpdateWithWhereUniqueWithoutUserInput {
  where: SessionWhereUniqueInput!
  data: SessionUpdateWithoutUserInput!
}

input SessionUpdateManyWithWhereWithoutUserInput {
  where: SessionScalarWhereInput!
  data: SessionUpdateManyMutationInput!
}

input SessionScalarWhereInput {
  AND: [SessionScalarWhereInput!]
  OR: [SessionScalarWhereInput!]
  NOT: [SessionScalarWhereInput!]
  sessionToken: StringFilter
  expires: DateTimeFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  userId: IntFilter
}

input SessionUpdateManyMutationInput {
  sessionToken: StringFieldUpdateOperationsInput
  expires: DateTimeFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserAddressUpdateManyWithoutUserNestedInput {
  create: [UserAddressCreateWithoutUserInput!]
  connectOrCreate: [UserAddressCreateOrConnectWithoutUserInput!]
  upsert: [UserAddressUpsertWithWhereUniqueWithoutUserInput!]
  createMany: UserAddressCreateManyUserInputEnvelope
  set: [UserAddressWhereUniqueInput!]
  disconnect: [UserAddressWhereUniqueInput!]
  delete: [UserAddressWhereUniqueInput!]
  connect: [UserAddressWhereUniqueInput!]
  update: [UserAddressUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [UserAddressUpdateManyWithWhereWithoutUserInput!]
  deleteMany: [UserAddressScalarWhereInput!]
}

input UserAddressUpsertWithWhereUniqueWithoutUserInput {
  where: UserAddressWhereUniqueInput!
  update: UserAddressUpdateWithoutUserInput!
  create: UserAddressCreateWithoutUserInput!
}

input UserAddressUpdateWithoutUserInput {
  status: EnumActiveStatusFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  address: AddressUpdateOneRequiredWithoutUsersNestedInput
}

input AddressUpdateOneRequiredWithoutUsersNestedInput {
  connect: AddressWhereUniqueInput
  update: AddressUpdateToOneWithWhereWithoutUsersInput
}

input AddressUpdateToOneWithWhereWithoutUsersInput {
  where: AddressWhereInput
  data: AddressUpdateWithoutUsersInput!
}

input AddressUpdateWithoutUsersInput {
  code: StringFieldUpdateOperationsInput
  c1: StringFieldUpdateOperationsInput
  c2: NullableStringFieldUpdateOperationsInput
  c3: NullableStringFieldUpdateOperationsInput
  c4: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  posts: PostUpdateManyWithoutAddressNestedInput
}

input PostUpdateManyWithoutAddressNestedInput {
  create: [PostCreateWithoutAddressInput!]
  connectOrCreate: [PostCreateOrConnectWithoutAddressInput!]
  upsert: [PostUpsertWithWhereUniqueWithoutAddressInput!]
  createMany: PostCreateManyAddressInputEnvelope
  set: [PostWhereUniqueInput!]
  disconnect: [PostWhereUniqueInput!]
  delete: [PostWhereUniqueInput!]
  connect: [PostWhereUniqueInput!]
  update: [PostUpdateWithWhereUniqueWithoutAddressInput!]
  updateMany: [PostUpdateManyWithWhereWithoutAddressInput!]
  deleteMany: [PostScalarWhereInput!]
}

input PostCreateWithoutAddressInput {
  content: String!
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  comments: CommentCreateNestedManyWithoutPostInput
  files: PostFileCreateNestedManyWithoutPostInput
  user: UserCreateNestedOneWithoutPostsInput!
}

input PostCreateOrConnectWithoutAddressInput {
  where: PostWhereUniqueInput!
  create: PostCreateWithoutAddressInput!
}

input PostUpsertWithWhereUniqueWithoutAddressInput {
  where: PostWhereUniqueInput!
  update: PostUpdateWithoutAddressInput!
  create: PostCreateWithoutAddressInput!
}

input PostUpdateWithoutAddressInput {
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  comments: CommentUpdateManyWithoutPostNestedInput
  files: PostFileUpdateManyWithoutPostNestedInput
  user: UserUpdateOneRequiredWithoutPostsNestedInput
}

input UserUpdateOneRequiredWithoutPostsNestedInput {
  create: UserCreateWithoutPostsInput
  connectOrCreate: UserCreateOrConnectWithoutPostsInput
  upsert: UserUpsertWithoutPostsInput
  connect: UserWhereUniqueInput
  update: UserUpdateToOneWithWhereWithoutPostsInput
}

input UserUpsertWithoutPostsInput {
  update: UserUpdateWithoutPostsInput!
  create: UserCreateWithoutPostsInput!
  where: UserWhereInput
}

input UserUpdateWithoutPostsInput {
  content: NullableStringFieldUpdateOperationsInput
  babyBirth: NullableDateTimeFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  username: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  accounts: AccountUpdateManyWithoutUserNestedInput
  chats: ChatUserUpdateManyWithoutUserNestedInput
  comments: CommentUpdateManyWithoutUserNestedInput
  sessions: SessionUpdateManyWithoutUserNestedInput
  addresses: UserAddressUpdateManyWithoutUserNestedInput
  files: UserFileUpdateManyWithoutUserNestedInput
  chatMessages: ChatMessageUpdateManyWithoutUserNestedInput
}

input UserFileUpdateManyWithoutUserNestedInput {
  create: [UserFileCreateWithoutUserInput!]
  connectOrCreate: [UserFileCreateOrConnectWithoutUserInput!]
  upsert: [UserFileUpsertWithWhereUniqueWithoutUserInput!]
  createMany: UserFileCreateManyUserInputEnvelope
  set: [UserFileWhereUniqueInput!]
  disconnect: [UserFileWhereUniqueInput!]
  delete: [UserFileWhereUniqueInput!]
  connect: [UserFileWhereUniqueInput!]
  update: [UserFileUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [UserFileUpdateManyWithWhereWithoutUserInput!]
  deleteMany: [UserFileScalarWhereInput!]
}

input UserFileUpsertWithWhereUniqueWithoutUserInput {
  where: UserFileWhereUniqueInput!
  update: UserFileUpdateWithoutUserInput!
  create: UserFileCreateWithoutUserInput!
}

input UserFileUpdateWithoutUserInput {
  status: EnumActiveStatusFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  file: FileUpdateOneRequiredWithoutFilesNestedInput
}

input FileUpdateOneRequiredWithoutFilesNestedInput {
  create: FileCreateWithoutFilesInput
  connectOrCreate: FileCreateOrConnectWithoutFilesInput
  upsert: FileUpsertWithoutFilesInput
  connect: FileWhereUniqueInput
  update: FileUpdateToOneWithWhereWithoutFilesInput
}

input FileUpsertWithoutFilesInput {
  update: FileUpdateWithoutFilesInput!
  create: FileCreateWithoutFilesInput!
  where: FileWhereInput
}

input FileUpdateWithoutFilesInput {
  location: StringFieldUpdateOperationsInput
  type: EnumFileStorageTypeFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  posts: PostFileUpdateManyWithoutFileNestedInput
}

input PostFileUpdateManyWithoutFileNestedInput {
  create: [PostFileCreateWithoutFileInput!]
  connectOrCreate: [PostFileCreateOrConnectWithoutFileInput!]
  upsert: [PostFileUpsertWithWhereUniqueWithoutFileInput!]
  createMany: PostFileCreateManyFileInputEnvelope
  set: [PostFileWhereUniqueInput!]
  disconnect: [PostFileWhereUniqueInput!]
  delete: [PostFileWhereUniqueInput!]
  connect: [PostFileWhereUniqueInput!]
  update: [PostFileUpdateWithWhereUniqueWithoutFileInput!]
  updateMany: [PostFileUpdateManyWithWhereWithoutFileInput!]
  deleteMany: [PostFileScalarWhereInput!]
}

input PostFileUpsertWithWhereUniqueWithoutFileInput {
  where: PostFileWhereUniqueInput!
  update: PostFileUpdateWithoutFileInput!
  create: PostFileCreateWithoutFileInput!
}

input PostFileUpdateWithoutFileInput {
  status: EnumActiveStatusFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  post: PostUpdateOneRequiredWithoutFilesNestedInput
}

input PostUpdateOneRequiredWithoutFilesNestedInput {
  create: PostCreateWithoutFilesInput
  connectOrCreate: PostCreateOrConnectWithoutFilesInput
  upsert: PostUpsertWithoutFilesInput
  connect: PostWhereUniqueInput
  update: PostUpdateToOneWithWhereWithoutFilesInput
}

input PostUpsertWithoutFilesInput {
  update: PostUpdateWithoutFilesInput!
  create: PostCreateWithoutFilesInput!
  where: PostWhereInput
}

input PostUpdateWithoutFilesInput {
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  comments: CommentUpdateManyWithoutPostNestedInput
  address: AddressUpdateOneRequiredWithoutPostsNestedInput
  user: UserUpdateOneRequiredWithoutPostsNestedInput
}

input AddressUpdateOneRequiredWithoutPostsNestedInput {
  connect: AddressWhereUniqueInput
  update: AddressUpdateToOneWithWhereWithoutPostsInput
}

input AddressUpdateToOneWithWhereWithoutPostsInput {
  where: AddressWhereInput
  data: AddressUpdateWithoutPostsInput!
}

input AddressUpdateWithoutPostsInput {
  code: StringFieldUpdateOperationsInput
  c1: StringFieldUpdateOperationsInput
  c2: NullableStringFieldUpdateOperationsInput
  c3: NullableStringFieldUpdateOperationsInput
  c4: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  users: UserAddressUpdateManyWithoutAddressNestedInput
}

input UserAddressUpdateManyWithoutAddressNestedInput {
  create: [UserAddressCreateWithoutAddressInput!]
  connectOrCreate: [UserAddressCreateOrConnectWithoutAddressInput!]
  upsert: [UserAddressUpsertWithWhereUniqueWithoutAddressInput!]
  createMany: UserAddressCreateManyAddressInputEnvelope
  set: [UserAddressWhereUniqueInput!]
  disconnect: [UserAddressWhereUniqueInput!]
  delete: [UserAddressWhereUniqueInput!]
  connect: [UserAddressWhereUniqueInput!]
  update: [UserAddressUpdateWithWhereUniqueWithoutAddressInput!]
  updateMany: [UserAddressUpdateManyWithWhereWithoutAddressInput!]
  deleteMany: [UserAddressScalarWhereInput!]
}

input UserAddressCreateWithoutAddressInput {
  status: ActiveStatus
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  user: UserCreateNestedOneWithoutAddressesInput!
}

input UserCreateNestedOneWithoutAddressesInput {
  create: UserCreateWithoutAddressesInput
  connectOrCreate: UserCreateOrConnectWithoutAddressesInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutAddressesInput {
  content: String
  babyBirth: DateTimeISO
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  email: String!
  emailVerified: DateTimeISO
  image: String
  name: String
  username: String
  role: Role
  accounts: AccountCreateNestedManyWithoutUserInput
  chats: ChatUserCreateNestedManyWithoutUserInput
  comments: CommentCreateNestedManyWithoutUserInput
  posts: PostCreateNestedManyWithoutUserInput
  sessions: SessionCreateNestedManyWithoutUserInput
  files: UserFileCreateNestedManyWithoutUserInput
  chatMessages: ChatMessageCreateNestedManyWithoutUserInput
}

input UserCreateOrConnectWithoutAddressesInput {
  where: UserWhereUniqueInput!
  create: UserCreateWithoutAddressesInput!
}

input UserAddressCreateOrConnectWithoutAddressInput {
  where: UserAddressWhereUniqueInput!
  create: UserAddressCreateWithoutAddressInput!
}

input UserAddressUpsertWithWhereUniqueWithoutAddressInput {
  where: UserAddressWhereUniqueInput!
  update: UserAddressUpdateWithoutAddressInput!
  create: UserAddressCreateWithoutAddressInput!
}

input UserAddressUpdateWithoutAddressInput {
  status: EnumActiveStatusFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutAddressesNestedInput
}

input UserUpdateOneRequiredWithoutAddressesNestedInput {
  create: UserCreateWithoutAddressesInput
  connectOrCreate: UserCreateOrConnectWithoutAddressesInput
  upsert: UserUpsertWithoutAddressesInput
  connect: UserWhereUniqueInput
  update: UserUpdateToOneWithWhereWithoutAddressesInput
}

input UserUpsertWithoutAddressesInput {
  update: UserUpdateWithoutAddressesInput!
  create: UserCreateWithoutAddressesInput!
  where: UserWhereInput
}

input UserUpdateWithoutAddressesInput {
  content: NullableStringFieldUpdateOperationsInput
  babyBirth: NullableDateTimeFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  username: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  accounts: AccountUpdateManyWithoutUserNestedInput
  chats: ChatUserUpdateManyWithoutUserNestedInput
  comments: CommentUpdateManyWithoutUserNestedInput
  posts: PostUpdateManyWithoutUserNestedInput
  sessions: SessionUpdateManyWithoutUserNestedInput
  files: UserFileUpdateManyWithoutUserNestedInput
  chatMessages: ChatMessageUpdateManyWithoutUserNestedInput
}

input ChatMessageUpdateManyWithoutUserNestedInput {
  create: [ChatMessageCreateWithoutUserInput!]
  connectOrCreate: [ChatMessageCreateOrConnectWithoutUserInput!]
  upsert: [ChatMessageUpsertWithWhereUniqueWithoutUserInput!]
  createMany: ChatMessageCreateManyUserInputEnvelope
  set: [ChatMessageWhereUniqueInput!]
  disconnect: [ChatMessageWhereUniqueInput!]
  delete: [ChatMessageWhereUniqueInput!]
  connect: [ChatMessageWhereUniqueInput!]
  update: [ChatMessageUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [ChatMessageUpdateManyWithWhereWithoutUserInput!]
  deleteMany: [ChatMessageScalarWhereInput!]
}

input ChatMessageUpsertWithWhereUniqueWithoutUserInput {
  where: ChatMessageWhereUniqueInput!
  update: ChatMessageUpdateWithoutUserInput!
  create: ChatMessageCreateWithoutUserInput!
}

input ChatMessageUpdateWithoutUserInput {
  message: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  chat: ChatUpdateOneRequiredWithoutMessagesNestedInput
}

input ChatUpdateOneRequiredWithoutMessagesNestedInput {
  create: ChatCreateWithoutMessagesInput
  connectOrCreate: ChatCreateOrConnectWithoutMessagesInput
  upsert: ChatUpsertWithoutMessagesInput
  connect: ChatWhereUniqueInput
  update: ChatUpdateToOneWithWhereWithoutMessagesInput
}

input ChatUpsertWithoutMessagesInput {
  update: ChatUpdateWithoutMessagesInput!
  create: ChatCreateWithoutMessagesInput!
  where: ChatWhereInput
}

input ChatUpdateWithoutMessagesInput {
  name: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  users: ChatUserUpdateManyWithoutChatNestedInput
}

input ChatUserUpdateManyWithoutChatNestedInput {
  create: [ChatUserCreateWithoutChatInput!]
  connectOrCreate: [ChatUserCreateOrConnectWithoutChatInput!]
  upsert: [ChatUserUpsertWithWhereUniqueWithoutChatInput!]
  createMany: ChatUserCreateManyChatInputEnvelope
  set: [ChatUserWhereUniqueInput!]
  disconnect: [ChatUserWhereUniqueInput!]
  delete: [ChatUserWhereUniqueInput!]
  connect: [ChatUserWhereUniqueInput!]
  update: [ChatUserUpdateWithWhereUniqueWithoutChatInput!]
  updateMany: [ChatUserUpdateManyWithWhereWithoutChatInput!]
  deleteMany: [ChatUserScalarWhereInput!]
}

input ChatUserUpsertWithWhereUniqueWithoutChatInput {
  where: ChatUserWhereUniqueInput!
  update: ChatUserUpdateWithoutChatInput!
  create: ChatUserCreateWithoutChatInput!
}

input ChatUserUpdateWithoutChatInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutChatsNestedInput
}

input UserUpdateOneRequiredWithoutChatsNestedInput {
  create: UserCreateWithoutChatsInput
  connectOrCreate: UserCreateOrConnectWithoutChatsInput
  upsert: UserUpsertWithoutChatsInput
  connect: UserWhereUniqueInput
  update: UserUpdateToOneWithWhereWithoutChatsInput
}

input UserUpsertWithoutChatsInput {
  update: UserUpdateWithoutChatsInput!
  create: UserCreateWithoutChatsInput!
  where: UserWhereInput
}

input UserUpdateWithoutChatsInput {
  content: NullableStringFieldUpdateOperationsInput
  babyBirth: NullableDateTimeFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  username: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  accounts: AccountUpdateManyWithoutUserNestedInput
  comments: CommentUpdateManyWithoutUserNestedInput
  posts: PostUpdateManyWithoutUserNestedInput
  sessions: SessionUpdateManyWithoutUserNestedInput
  addresses: UserAddressUpdateManyWithoutUserNestedInput
  files: UserFileUpdateManyWithoutUserNestedInput
  chatMessages: ChatMessageUpdateManyWithoutUserNestedInput
}

input UserUpdateToOneWithWhereWithoutChatsInput {
  where: UserWhereInput
  data: UserUpdateWithoutChatsInput!
}

input ChatUserUpdateWithWhereUniqueWithoutChatInput {
  where: ChatUserWhereUniqueInput!
  data: ChatUserUpdateWithoutChatInput!
}

input ChatUserUpdateManyWithWhereWithoutChatInput {
  where: ChatUserScalarWhereInput!
  data: ChatUserUpdateManyMutationInput!
}

input ChatUserScalarWhereInput {
  AND: [ChatUserScalarWhereInput!]
  OR: [ChatUserScalarWhereInput!]
  NOT: [ChatUserScalarWhereInput!]
  id: IntFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  chatId: IntFilter
  userId: IntFilter
}

input ChatUserUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ChatUpdateToOneWithWhereWithoutMessagesInput {
  where: ChatWhereInput
  data: ChatUpdateWithoutMessagesInput!
}

input ChatMessageUpdateWithWhereUniqueWithoutUserInput {
  where: ChatMessageWhereUniqueInput!
  data: ChatMessageUpdateWithoutUserInput!
}

input ChatMessageUpdateManyWithWhereWithoutUserInput {
  where: ChatMessageScalarWhereInput!
  data: ChatMessageUpdateManyMutationInput!
}

input ChatMessageScalarWhereInput {
  AND: [ChatMessageScalarWhereInput!]
  OR: [ChatMessageScalarWhereInput!]
  NOT: [ChatMessageScalarWhereInput!]
  id: IntFilter
  message: StringFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  chatId: IntFilter
  userId: IntFilter
}

input ChatMessageUpdateManyMutationInput {
  message: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateToOneWithWhereWithoutAddressesInput {
  where: UserWhereInput
  data: UserUpdateWithoutAddressesInput!
}

input UserAddressCreateManyAddressInputEnvelope {
  data: [UserAddressCreateManyAddressInput!]!
  skipDuplicates: Boolean
}

input UserAddressCreateManyAddressInput {
  id: Int
  userId: Int!
  status: ActiveStatus
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
}

input UserAddressUpdateWithWhereUniqueWithoutAddressInput {
  where: UserAddressWhereUniqueInput!
  data: UserAddressUpdateWithoutAddressInput!
}

input UserAddressUpdateManyWithWhereWithoutAddressInput {
  where: UserAddressScalarWhereInput!
  data: UserAddressUpdateManyMutationInput!
}

input UserAddressScalarWhereInput {
  AND: [UserAddressScalarWhereInput!]
  OR: [UserAddressScalarWhereInput!]
  NOT: [UserAddressScalarWhereInput!]
  id: IntFilter
  userId: IntFilter
  addressId: IntFilter
  status: EnumActiveStatusFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
}

input UserAddressUpdateManyMutationInput {
  status: EnumActiveStatusFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PostUpdateToOneWithWhereWithoutFilesInput {
  where: PostWhereInput
  data: PostUpdateWithoutFilesInput!
}

input PostFileUpdateWithWhereUniqueWithoutFileInput {
  where: PostFileWhereUniqueInput!
  data: PostFileUpdateWithoutFileInput!
}

input PostFileUpdateManyWithWhereWithoutFileInput {
  where: PostFileScalarWhereInput!
  data: PostFileUpdateManyMutationInput!
}

input PostFileScalarWhereInput {
  AND: [PostFileScalarWhereInput!]
  OR: [PostFileScalarWhereInput!]
  NOT: [PostFileScalarWhereInput!]
  id: IntFilter
  postId: IntFilter
  fileId: IntFilter
  status: EnumActiveStatusFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
}

input PostFileUpdateManyMutationInput {
  status: EnumActiveStatusFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input FileUpdateToOneWithWhereWithoutFilesInput {
  where: FileWhereInput
  data: FileUpdateWithoutFilesInput!
}

input UserFileUpdateWithWhereUniqueWithoutUserInput {
  where: UserFileWhereUniqueInput!
  data: UserFileUpdateWithoutUserInput!
}

input UserFileUpdateManyWithWhereWithoutUserInput {
  where: UserFileScalarWhereInput!
  data: UserFileUpdateManyMutationInput!
}

input UserFileScalarWhereInput {
  AND: [UserFileScalarWhereInput!]
  OR: [UserFileScalarWhereInput!]
  NOT: [UserFileScalarWhereInput!]
  id: IntFilter
  userId: IntFilter
  fileId: IntFilter
  status: EnumActiveStatusFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
}

input UserFileUpdateManyMutationInput {
  status: EnumActiveStatusFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateToOneWithWhereWithoutPostsInput {
  where: UserWhereInput
  data: UserUpdateWithoutPostsInput!
}

input PostCreateManyAddressInputEnvelope {
  data: [PostCreateManyAddressInput!]!
  skipDuplicates: Boolean
}

input PostCreateManyAddressInput {
  id: Int
  content: String!
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  userId: Int!
}

input PostUpdateWithWhereUniqueWithoutAddressInput {
  where: PostWhereUniqueInput!
  data: PostUpdateWithoutAddressInput!
}

input PostUpdateManyWithWhereWithoutAddressInput {
  where: PostScalarWhereInput!
  data: PostUpdateManyMutationInput!
}

input PostScalarWhereInput {
  AND: [PostScalarWhereInput!]
  OR: [PostScalarWhereInput!]
  NOT: [PostScalarWhereInput!]
  id: IntFilter
  content: StringFilter
  addressId: IntFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  userId: IntFilter
}

input PostUpdateManyMutationInput {
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserAddressUpdateWithWhereUniqueWithoutUserInput {
  where: UserAddressWhereUniqueInput!
  data: UserAddressUpdateWithoutUserInput!
}

input UserAddressUpdateManyWithWhereWithoutUserInput {
  where: UserAddressScalarWhereInput!
  data: UserAddressUpdateManyMutationInput!
}

input UserUpdateToOneWithWhereWithoutCommentsInput {
  where: UserWhereInput
  data: UserUpdateWithoutCommentsInput!
}

input CommentUpdateWithWhereUniqueWithoutPostInput {
  where: CommentWhereUniqueInput!
  data: CommentUpdateWithoutPostInput!
}

input CommentUpdateManyWithWhereWithoutPostInput {
  where: CommentScalarWhereInput!
  data: CommentUpdateManyMutationInput!
}

input CommentScalarWhereInput {
  AND: [CommentScalarWhereInput!]
  OR: [CommentScalarWhereInput!]
  NOT: [CommentScalarWhereInput!]
  id: IntFilter
  content: StringFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  userId: IntFilter
  postId: IntFilter
}

input CommentUpdateManyMutationInput {
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PostUpdateWithWhereUniqueWithoutUserInput {
  where: PostWhereUniqueInput!
  data: PostUpdateWithoutUserInput!
}

input PostUpdateManyWithWhereWithoutUserInput {
  where: PostScalarWhereInput!
  data: PostUpdateManyMutationInput!
}

input UserUpdateToOneWithWhereWithoutFilesInput {
  where: UserWhereInput
  data: UserUpdateWithoutFilesInput!
}

input UserFileUpdateWithWhereUniqueWithoutFileInput {
  where: UserFileWhereUniqueInput!
  data: UserFileUpdateWithoutFileInput!
}

input UserFileUpdateManyWithWhereWithoutFileInput {
  where: UserFileScalarWhereInput!
  data: UserFileUpdateManyMutationInput!
}

input FileUpdateToOneWithWhereWithoutPostsInput {
  where: FileWhereInput
  data: FileUpdateWithoutPostsInput!
}

input PostFileUpdateWithWhereUniqueWithoutPostInput {
  where: PostFileWhereUniqueInput!
  data: PostFileUpdateWithoutPostInput!
}

input PostFileUpdateManyWithWhereWithoutPostInput {
  where: PostFileScalarWhereInput!
  data: PostFileUpdateManyMutationInput!
}

input PostUpdateToOneWithWhereWithoutCommentsInput {
  where: PostWhereInput
  data: PostUpdateWithoutCommentsInput!
}

input CommentUpdateWithWhereUniqueWithoutUserInput {
  where: CommentWhereUniqueInput!
  data: CommentUpdateWithoutUserInput!
}

input CommentUpdateManyWithWhereWithoutUserInput {
  where: CommentScalarWhereInput!
  data: CommentUpdateManyMutationInput!
}

input UserUpdateToOneWithWhereWithoutChatMessagesInput {
  where: UserWhereInput
  data: UserUpdateWithoutChatMessagesInput!
}

input ChatMessageUpdateWithWhereUniqueWithoutChatInput {
  where: ChatMessageWhereUniqueInput!
  data: ChatMessageUpdateWithoutChatInput!
}

input ChatMessageUpdateManyWithWhereWithoutChatInput {
  where: ChatMessageScalarWhereInput!
  data: ChatMessageUpdateManyMutationInput!
}

input ChatUpdateToOneWithWhereWithoutUsersInput {
  where: ChatWhereInput
  data: ChatUpdateWithoutUsersInput!
}

input ChatUserUpdateWithWhereUniqueWithoutUserInput {
  where: ChatUserWhereUniqueInput!
  data: ChatUserUpdateWithoutUserInput!
}

input ChatUserUpdateManyWithWhereWithoutUserInput {
  where: ChatUserScalarWhereInput!
  data: ChatUserUpdateManyMutationInput!
}

input UserUpdateToOneWithWhereWithoutAccountsInput {
  where: UserWhereInput
  data: UserUpdateWithoutAccountsInput!
}

input AddressUpdateManyMutationInput {
  code: StringFieldUpdateOperationsInput
  c1: StringFieldUpdateOperationsInput
  c2: NullableStringFieldUpdateOperationsInput
  c3: NullableStringFieldUpdateOperationsInput
  c4: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AddressUpdateInput {
  code: StringFieldUpdateOperationsInput
  c1: StringFieldUpdateOperationsInput
  c2: NullableStringFieldUpdateOperationsInput
  c3: NullableStringFieldUpdateOperationsInput
  c4: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  posts: PostUpdateManyWithoutAddressNestedInput
  users: UserAddressUpdateManyWithoutAddressNestedInput
}

input ChatCreateManyInput {
  id: Int
  name: String
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
}

input ChatCreateInput {
  name: String
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  messages: ChatMessageCreateNestedManyWithoutChatInput
  users: ChatUserCreateNestedManyWithoutChatInput
}

input ChatUpdateManyMutationInput {
  name: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ChatUpdateInput {
  name: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  messages: ChatMessageUpdateManyWithoutChatNestedInput
  users: ChatUserUpdateManyWithoutChatNestedInput
}

input ChatMessageCreateManyInput {
  id: Int
  message: String!
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  chatId: Int!
  userId: Int!
}

input ChatMessageCreateInput {
  message: String!
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  user: UserCreateNestedOneWithoutChatMessagesInput!
  chat: ChatCreateNestedOneWithoutMessagesInput!
}

input ChatMessageUpdateInput {
  message: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutChatMessagesNestedInput
  chat: ChatUpdateOneRequiredWithoutMessagesNestedInput
}

input ChatUserCreateManyInput {
  id: Int
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  chatId: Int!
  userId: Int!
}

input ChatUserCreateInput {
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  chat: ChatCreateNestedOneWithoutUsersInput!
  user: UserCreateNestedOneWithoutChatsInput!
}

input ChatUserUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  chat: ChatUpdateOneRequiredWithoutUsersNestedInput
  user: UserUpdateOneRequiredWithoutChatsNestedInput
}

input CommentCreateManyInput {
  id: Int
  content: String!
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  userId: Int!
  postId: Int!
}

input CommentCreateInput {
  content: String!
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  post: PostCreateNestedOneWithoutCommentsInput!
  user: UserCreateNestedOneWithoutCommentsInput!
}

input CommentUpdateInput {
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  post: PostUpdateOneRequiredWithoutCommentsNestedInput
  user: UserUpdateOneRequiredWithoutCommentsNestedInput
}

input FileCreateManyInput {
  id: Int
  location: String!
  type: FileStorageType
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
}

input FileCreateInput {
  location: String!
  type: FileStorageType
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  posts: PostFileCreateNestedManyWithoutFileInput
  files: UserFileCreateNestedManyWithoutFileInput
}

input FileUpdateManyMutationInput {
  location: StringFieldUpdateOperationsInput
  type: EnumFileStorageTypeFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input FileUpdateInput {
  location: StringFieldUpdateOperationsInput
  type: EnumFileStorageTypeFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  posts: PostFileUpdateManyWithoutFileNestedInput
  files: UserFileUpdateManyWithoutFileNestedInput
}

input PostCreateManyInput {
  id: Int
  content: String!
  addressId: Int!
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  userId: Int!
}

input PostCreateInput {
  content: String!
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  comments: CommentCreateNestedManyWithoutPostInput
  files: PostFileCreateNestedManyWithoutPostInput
  address: AddressCreateNestedOneWithoutPostsInput!
  user: UserCreateNestedOneWithoutPostsInput!
}

input PostUpdateInput {
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  comments: CommentUpdateManyWithoutPostNestedInput
  files: PostFileUpdateManyWithoutPostNestedInput
  address: AddressUpdateOneRequiredWithoutPostsNestedInput
  user: UserUpdateOneRequiredWithoutPostsNestedInput
}

input PostFileCreateManyInput {
  id: Int
  postId: Int!
  fileId: Int!
  status: ActiveStatus
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
}

input PostFileCreateInput {
  status: ActiveStatus
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  file: FileCreateNestedOneWithoutPostsInput!
  post: PostCreateNestedOneWithoutFilesInput!
}

input PostFileUpdateInput {
  status: EnumActiveStatusFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  file: FileUpdateOneRequiredWithoutPostsNestedInput
  post: PostUpdateOneRequiredWithoutFilesNestedInput
}

input SessionCreateManyInput {
  sessionToken: String!
  expires: DateTimeISO!
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  userId: Int!
}

input SessionCreateInput {
  sessionToken: String!
  expires: DateTimeISO!
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  user: UserCreateNestedOneWithoutSessionsInput!
}

input UserCreateNestedOneWithoutSessionsInput {
  create: UserCreateWithoutSessionsInput
  connectOrCreate: UserCreateOrConnectWithoutSessionsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutSessionsInput {
  content: String
  babyBirth: DateTimeISO
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  email: String!
  emailVerified: DateTimeISO
  image: String
  name: String
  username: String
  role: Role
  accounts: AccountCreateNestedManyWithoutUserInput
  chats: ChatUserCreateNestedManyWithoutUserInput
  comments: CommentCreateNestedManyWithoutUserInput
  posts: PostCreateNestedManyWithoutUserInput
  addresses: UserAddressCreateNestedManyWithoutUserInput
  files: UserFileCreateNestedManyWithoutUserInput
  chatMessages: ChatMessageCreateNestedManyWithoutUserInput
}

input UserCreateOrConnectWithoutSessionsInput {
  where: UserWhereUniqueInput!
  create: UserCreateWithoutSessionsInput!
}

input SessionUpdateInput {
  sessionToken: StringFieldUpdateOperationsInput
  expires: DateTimeFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutSessionsNestedInput
}

input UserUpdateOneRequiredWithoutSessionsNestedInput {
  create: UserCreateWithoutSessionsInput
  connectOrCreate: UserCreateOrConnectWithoutSessionsInput
  upsert: UserUpsertWithoutSessionsInput
  connect: UserWhereUniqueInput
  update: UserUpdateToOneWithWhereWithoutSessionsInput
}

input UserUpsertWithoutSessionsInput {
  update: UserUpdateWithoutSessionsInput!
  create: UserCreateWithoutSessionsInput!
  where: UserWhereInput
}

input UserUpdateWithoutSessionsInput {
  content: NullableStringFieldUpdateOperationsInput
  babyBirth: NullableDateTimeFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  username: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  accounts: AccountUpdateManyWithoutUserNestedInput
  chats: ChatUserUpdateManyWithoutUserNestedInput
  comments: CommentUpdateManyWithoutUserNestedInput
  posts: PostUpdateManyWithoutUserNestedInput
  addresses: UserAddressUpdateManyWithoutUserNestedInput
  files: UserFileUpdateManyWithoutUserNestedInput
  chatMessages: ChatMessageUpdateManyWithoutUserNestedInput
}

input UserUpdateToOneWithWhereWithoutSessionsInput {
  where: UserWhereInput
  data: UserUpdateWithoutSessionsInput!
}

input Spatial_ref_sysCreateManyInput {
  srid: Int!
  auth_name: String
  auth_srid: Int
  srtext: String
  proj4text: String
}

input Spatial_ref_sysCreateInput {
  srid: Int!
  auth_name: String
  auth_srid: Int
  srtext: String
  proj4text: String
}

input Spatial_ref_sysUpdateManyMutationInput {
  srid: IntFieldUpdateOperationsInput
  auth_name: NullableStringFieldUpdateOperationsInput
  auth_srid: NullableIntFieldUpdateOperationsInput
  srtext: NullableStringFieldUpdateOperationsInput
  proj4text: NullableStringFieldUpdateOperationsInput
}

input IntFieldUpdateOperationsInput {
  set: Int
  increment: Int
  decrement: Int
  multiply: Int
  divide: Int
}

input Spatial_ref_sysUpdateInput {
  srid: IntFieldUpdateOperationsInput
  auth_name: NullableStringFieldUpdateOperationsInput
  auth_srid: NullableIntFieldUpdateOperationsInput
  srtext: NullableStringFieldUpdateOperationsInput
  proj4text: NullableStringFieldUpdateOperationsInput
}

input UserCreateManyInput {
  id: Int
  content: String
  babyBirth: DateTimeISO
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  email: String!
  emailVerified: DateTimeISO
  image: String
  name: String
  username: String
  role: Role
}

input UserCreateInput {
  content: String
  babyBirth: DateTimeISO
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  email: String!
  emailVerified: DateTimeISO
  image: String
  name: String
  username: String
  role: Role
  accounts: AccountCreateNestedManyWithoutUserInput
  chats: ChatUserCreateNestedManyWithoutUserInput
  comments: CommentCreateNestedManyWithoutUserInput
  posts: PostCreateNestedManyWithoutUserInput
  sessions: SessionCreateNestedManyWithoutUserInput
  addresses: UserAddressCreateNestedManyWithoutUserInput
  files: UserFileCreateNestedManyWithoutUserInput
  chatMessages: ChatMessageCreateNestedManyWithoutUserInput
}

input UserUpdateManyMutationInput {
  content: NullableStringFieldUpdateOperationsInput
  babyBirth: NullableDateTimeFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  username: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
}

input UserUpdateInput {
  content: NullableStringFieldUpdateOperationsInput
  babyBirth: NullableDateTimeFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  username: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  accounts: AccountUpdateManyWithoutUserNestedInput
  chats: ChatUserUpdateManyWithoutUserNestedInput
  comments: CommentUpdateManyWithoutUserNestedInput
  posts: PostUpdateManyWithoutUserNestedInput
  sessions: SessionUpdateManyWithoutUserNestedInput
  addresses: UserAddressUpdateManyWithoutUserNestedInput
  files: UserFileUpdateManyWithoutUserNestedInput
  chatMessages: ChatMessageUpdateManyWithoutUserNestedInput
}

input UserAddressCreateManyInput {
  id: Int
  userId: Int!
  addressId: Int!
  status: ActiveStatus
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
}

input UserAddressCreateInput {
  status: ActiveStatus
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  address: AddressCreateNestedOneWithoutUsersInput!
  user: UserCreateNestedOneWithoutAddressesInput!
}

input UserAddressUpdateInput {
  status: EnumActiveStatusFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  address: AddressUpdateOneRequiredWithoutUsersNestedInput
  user: UserUpdateOneRequiredWithoutAddressesNestedInput
}

input UserFileCreateManyInput {
  id: Int
  userId: Int!
  fileId: Int!
  status: ActiveStatus
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
}

input UserFileCreateInput {
  status: ActiveStatus
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  file: FileCreateNestedOneWithoutFilesInput!
  user: UserCreateNestedOneWithoutFilesInput!
}

input UserFileUpdateInput {
  status: EnumActiveStatusFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  file: FileUpdateOneRequiredWithoutFilesNestedInput
  user: UserUpdateOneRequiredWithoutFilesNestedInput
}

input VerificationTokenCreateManyInput {
  identifier: String!
  token: String!
  expires: DateTimeISO!
}

input VerificationTokenCreateInput {
  identifier: String!
  token: String!
  expires: DateTimeISO!
}

input VerificationTokenUpdateManyMutationInput {
  identifier: StringFieldUpdateOperationsInput
  token: StringFieldUpdateOperationsInput
  expires: DateTimeFieldUpdateOperationsInput
}

input VerificationTokenUpdateInput {
  identifier: StringFieldUpdateOperationsInput
  token: StringFieldUpdateOperationsInput
  expires: DateTimeFieldUpdateOperationsInput
}

type Subscription {
  chat(chatId: Int!): ChatMessage!
}
