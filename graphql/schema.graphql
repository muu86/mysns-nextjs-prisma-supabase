# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type Account {
  access_token: String
  createdAt: DateTimeISO!
  expires_at: Int
  id_token: String
  provider: String!
  providerAccountId: String!
  refresh_token: String
  scope: String
  session_state: String
  token_type: String
  type: String!
  updatedAt: DateTimeISO!
  user: User!
  userId: Int!
}

type AccountAvgAggregate {
  expires_at: Float
  userId: Float
}

input AccountAvgOrderByAggregateInput {
  expires_at: SortOrder
  userId: SortOrder
}

type AccountCountAggregate {
  _all: Int!
  access_token: Int!
  createdAt: Int!
  expires_at: Int!
  id_token: Int!
  provider: Int!
  providerAccountId: Int!
  refresh_token: Int!
  scope: Int!
  session_state: Int!
  token_type: Int!
  type: Int!
  updatedAt: Int!
  userId: Int!
}

input AccountCountOrderByAggregateInput {
  access_token: SortOrder
  createdAt: SortOrder
  expires_at: SortOrder
  id_token: SortOrder
  provider: SortOrder
  providerAccountId: SortOrder
  refresh_token: SortOrder
  scope: SortOrder
  session_state: SortOrder
  token_type: SortOrder
  type: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input AccountCreateInput {
  access_token: String
  createdAt: DateTimeISO
  expires_at: Int
  id_token: String
  provider: String!
  providerAccountId: String!
  refresh_token: String
  scope: String
  session_state: String
  token_type: String
  type: String!
  updatedAt: DateTimeISO
  user: UserCreateNestedOneWithoutAccountInput!
}

input AccountCreateManyInput {
  access_token: String
  createdAt: DateTimeISO
  expires_at: Int
  id_token: String
  provider: String!
  providerAccountId: String!
  refresh_token: String
  scope: String
  session_state: String
  token_type: String
  type: String!
  updatedAt: DateTimeISO
  userId: Int!
}

input AccountCreateManyUserInput {
  access_token: String
  createdAt: DateTimeISO
  expires_at: Int
  id_token: String
  provider: String!
  providerAccountId: String!
  refresh_token: String
  scope: String
  session_state: String
  token_type: String
  type: String!
  updatedAt: DateTimeISO
}

input AccountCreateManyUserInputEnvelope {
  data: [AccountCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input AccountCreateNestedManyWithoutUserInput {
  connect: [AccountWhereUniqueInput!]
  connectOrCreate: [AccountCreateOrConnectWithoutUserInput!]
  create: [AccountCreateWithoutUserInput!]
  createMany: AccountCreateManyUserInputEnvelope
}

input AccountCreateOrConnectWithoutUserInput {
  create: AccountCreateWithoutUserInput!
  where: AccountWhereUniqueInput!
}

input AccountCreateWithoutUserInput {
  access_token: String
  createdAt: DateTimeISO
  expires_at: Int
  id_token: String
  provider: String!
  providerAccountId: String!
  refresh_token: String
  scope: String
  session_state: String
  token_type: String
  type: String!
  updatedAt: DateTimeISO
}

type AccountGroupBy {
  _avg: AccountAvgAggregate
  _count: AccountCountAggregate
  _max: AccountMaxAggregate
  _min: AccountMinAggregate
  _sum: AccountSumAggregate
  access_token: String
  createdAt: DateTimeISO!
  expires_at: Int
  id_token: String
  provider: String!
  providerAccountId: String!
  refresh_token: String
  scope: String
  session_state: String
  token_type: String
  type: String!
  updatedAt: DateTimeISO!
  userId: Int!
}

input AccountListRelationFilter {
  every: AccountWhereInput
  none: AccountWhereInput
  some: AccountWhereInput
}

type AccountMaxAggregate {
  access_token: String
  createdAt: DateTimeISO
  expires_at: Int
  id_token: String
  provider: String
  providerAccountId: String
  refresh_token: String
  scope: String
  session_state: String
  token_type: String
  type: String
  updatedAt: DateTimeISO
  userId: Int
}

input AccountMaxOrderByAggregateInput {
  access_token: SortOrder
  createdAt: SortOrder
  expires_at: SortOrder
  id_token: SortOrder
  provider: SortOrder
  providerAccountId: SortOrder
  refresh_token: SortOrder
  scope: SortOrder
  session_state: SortOrder
  token_type: SortOrder
  type: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

type AccountMinAggregate {
  access_token: String
  createdAt: DateTimeISO
  expires_at: Int
  id_token: String
  provider: String
  providerAccountId: String
  refresh_token: String
  scope: String
  session_state: String
  token_type: String
  type: String
  updatedAt: DateTimeISO
  userId: Int
}

input AccountMinOrderByAggregateInput {
  access_token: SortOrder
  createdAt: SortOrder
  expires_at: SortOrder
  id_token: SortOrder
  provider: SortOrder
  providerAccountId: SortOrder
  refresh_token: SortOrder
  scope: SortOrder
  session_state: SortOrder
  token_type: SortOrder
  type: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input AccountOrderByRelationAggregateInput {
  _count: SortOrder
}

input AccountOrderByWithAggregationInput {
  _avg: AccountAvgOrderByAggregateInput
  _count: AccountCountOrderByAggregateInput
  _max: AccountMaxOrderByAggregateInput
  _min: AccountMinOrderByAggregateInput
  _sum: AccountSumOrderByAggregateInput
  access_token: SortOrderInput
  createdAt: SortOrder
  expires_at: SortOrderInput
  id_token: SortOrderInput
  provider: SortOrder
  providerAccountId: SortOrder
  refresh_token: SortOrderInput
  scope: SortOrderInput
  session_state: SortOrderInput
  token_type: SortOrderInput
  type: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input AccountOrderByWithRelationInput {
  access_token: SortOrderInput
  createdAt: SortOrder
  expires_at: SortOrderInput
  id_token: SortOrderInput
  provider: SortOrder
  providerAccountId: SortOrder
  refresh_token: SortOrderInput
  scope: SortOrderInput
  session_state: SortOrderInput
  token_type: SortOrderInput
  type: SortOrder
  updatedAt: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

input AccountProviderProviderAccountIdCompoundUniqueInput {
  provider: String!
  providerAccountId: String!
}

enum AccountScalarFieldEnum {
  access_token
  createdAt
  expires_at
  id_token
  provider
  providerAccountId
  refresh_token
  scope
  session_state
  token_type
  type
  updatedAt
  userId
}

input AccountScalarWhereInput {
  AND: [AccountScalarWhereInput!]
  NOT: [AccountScalarWhereInput!]
  OR: [AccountScalarWhereInput!]
  access_token: StringNullableFilter
  createdAt: DateTimeFilter
  expires_at: IntNullableFilter
  id_token: StringNullableFilter
  provider: StringFilter
  providerAccountId: StringFilter
  refresh_token: StringNullableFilter
  scope: StringNullableFilter
  session_state: StringNullableFilter
  token_type: StringNullableFilter
  type: StringFilter
  updatedAt: DateTimeFilter
  userId: IntFilter
}

input AccountScalarWhereWithAggregatesInput {
  AND: [AccountScalarWhereWithAggregatesInput!]
  NOT: [AccountScalarWhereWithAggregatesInput!]
  OR: [AccountScalarWhereWithAggregatesInput!]
  access_token: StringNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  expires_at: IntNullableWithAggregatesFilter
  id_token: StringNullableWithAggregatesFilter
  provider: StringWithAggregatesFilter
  providerAccountId: StringWithAggregatesFilter
  refresh_token: StringNullableWithAggregatesFilter
  scope: StringNullableWithAggregatesFilter
  session_state: StringNullableWithAggregatesFilter
  token_type: StringNullableWithAggregatesFilter
  type: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  userId: IntWithAggregatesFilter
}

type AccountSumAggregate {
  expires_at: Int
  userId: Int
}

input AccountSumOrderByAggregateInput {
  expires_at: SortOrder
  userId: SortOrder
}

input AccountUpdateInput {
  access_token: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  expires_at: NullableIntFieldUpdateOperationsInput
  id_token: NullableStringFieldUpdateOperationsInput
  provider: StringFieldUpdateOperationsInput
  providerAccountId: StringFieldUpdateOperationsInput
  refresh_token: NullableStringFieldUpdateOperationsInput
  scope: NullableStringFieldUpdateOperationsInput
  session_state: NullableStringFieldUpdateOperationsInput
  token_type: NullableStringFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutAccountNestedInput
}

input AccountUpdateManyMutationInput {
  access_token: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  expires_at: NullableIntFieldUpdateOperationsInput
  id_token: NullableStringFieldUpdateOperationsInput
  provider: StringFieldUpdateOperationsInput
  providerAccountId: StringFieldUpdateOperationsInput
  refresh_token: NullableStringFieldUpdateOperationsInput
  scope: NullableStringFieldUpdateOperationsInput
  session_state: NullableStringFieldUpdateOperationsInput
  token_type: NullableStringFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AccountUpdateManyWithWhereWithoutUserInput {
  data: AccountUpdateManyMutationInput!
  where: AccountScalarWhereInput!
}

input AccountUpdateManyWithoutUserNestedInput {
  connect: [AccountWhereUniqueInput!]
  connectOrCreate: [AccountCreateOrConnectWithoutUserInput!]
  create: [AccountCreateWithoutUserInput!]
  createMany: AccountCreateManyUserInputEnvelope
  delete: [AccountWhereUniqueInput!]
  deleteMany: [AccountScalarWhereInput!]
  disconnect: [AccountWhereUniqueInput!]
  set: [AccountWhereUniqueInput!]
  update: [AccountUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [AccountUpdateManyWithWhereWithoutUserInput!]
  upsert: [AccountUpsertWithWhereUniqueWithoutUserInput!]
}

input AccountUpdateWithWhereUniqueWithoutUserInput {
  data: AccountUpdateWithoutUserInput!
  where: AccountWhereUniqueInput!
}

input AccountUpdateWithoutUserInput {
  access_token: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  expires_at: NullableIntFieldUpdateOperationsInput
  id_token: NullableStringFieldUpdateOperationsInput
  provider: StringFieldUpdateOperationsInput
  providerAccountId: StringFieldUpdateOperationsInput
  refresh_token: NullableStringFieldUpdateOperationsInput
  scope: NullableStringFieldUpdateOperationsInput
  session_state: NullableStringFieldUpdateOperationsInput
  token_type: NullableStringFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AccountUpsertWithWhereUniqueWithoutUserInput {
  create: AccountCreateWithoutUserInput!
  update: AccountUpdateWithoutUserInput!
  where: AccountWhereUniqueInput!
}

input AccountWhereInput {
  AND: [AccountWhereInput!]
  NOT: [AccountWhereInput!]
  OR: [AccountWhereInput!]
  access_token: StringNullableFilter
  createdAt: DateTimeFilter
  expires_at: IntNullableFilter
  id_token: StringNullableFilter
  provider: StringFilter
  providerAccountId: StringFilter
  refresh_token: StringNullableFilter
  scope: StringNullableFilter
  session_state: StringNullableFilter
  token_type: StringNullableFilter
  type: StringFilter
  updatedAt: DateTimeFilter
  user: UserRelationFilter
  userId: IntFilter
}

input AccountWhereUniqueInput {
  AND: [AccountWhereInput!]
  NOT: [AccountWhereInput!]
  OR: [AccountWhereInput!]
  access_token: StringNullableFilter
  createdAt: DateTimeFilter
  expires_at: IntNullableFilter
  id_token: StringNullableFilter
  provider: StringFilter
  providerAccountId: StringFilter
  provider_providerAccountId: AccountProviderProviderAccountIdCompoundUniqueInput
  refresh_token: StringNullableFilter
  scope: StringNullableFilter
  session_state: StringNullableFilter
  token_type: StringNullableFilter
  type: StringFilter
  updatedAt: DateTimeFilter
  user: UserRelationFilter
  userId: IntFilter
}

type Address {
  Post(cursor: PostWhereUniqueInput, distinct: [PostScalarFieldEnum!], orderBy: [PostOrderByWithRelationInput!], skip: Int, take: Int, where: PostWhereInput): [Post!]!
  _count: AddressCount
  c1: String!
  c2: String
  c3: String
  c4: String
  code: String!
  createdAt: DateTimeISO!
  id: ID!
  updatedAt: DateTimeISO!
  users(cursor: UserAddressWhereUniqueInput, distinct: [UserAddressScalarFieldEnum!], orderBy: [UserAddressOrderByWithRelationInput!], skip: Int, take: Int, where: UserAddressWhereInput): [UserAddress!]!
}

type AddressAvgAggregate {
  id: Float
}

input AddressAvgOrderByAggregateInput {
  id: SortOrder
}

type AddressCount {
  Post(where: PostWhereInput): Int!
  users(where: UserAddressWhereInput): Int!
}

type AddressCountAggregate {
  _all: Int!
  c1: Int!
  c2: Int!
  c3: Int!
  c4: Int!
  code: Int!
  createdAt: Int!
  id: Int!
  updatedAt: Int!
}

input AddressCountOrderByAggregateInput {
  c1: SortOrder
  c2: SortOrder
  c3: SortOrder
  c4: SortOrder
  code: SortOrder
  createdAt: SortOrder
  id: SortOrder
  updatedAt: SortOrder
}

input AddressCreateNestedOneWithoutPostInput {
  connect: AddressWhereUniqueInput
}

input AddressCreateNestedOneWithoutUsersInput {
  connect: AddressWhereUniqueInput
}

type AddressGroupBy {
  _avg: AddressAvgAggregate
  _count: AddressCountAggregate
  _max: AddressMaxAggregate
  _min: AddressMinAggregate
  _sum: AddressSumAggregate
  c1: String!
  c2: String
  c3: String
  c4: String
  code: String!
  createdAt: DateTimeISO!
  id: Int!
  updatedAt: DateTimeISO!
}

type AddressMaxAggregate {
  c1: String
  c2: String
  c3: String
  c4: String
  code: String
  createdAt: DateTimeISO
  id: Int
  updatedAt: DateTimeISO
}

input AddressMaxOrderByAggregateInput {
  c1: SortOrder
  c2: SortOrder
  c3: SortOrder
  c4: SortOrder
  code: SortOrder
  createdAt: SortOrder
  id: SortOrder
  updatedAt: SortOrder
}

type AddressMinAggregate {
  c1: String
  c2: String
  c3: String
  c4: String
  code: String
  createdAt: DateTimeISO
  id: Int
  updatedAt: DateTimeISO
}

input AddressMinOrderByAggregateInput {
  c1: SortOrder
  c2: SortOrder
  c3: SortOrder
  c4: SortOrder
  code: SortOrder
  createdAt: SortOrder
  id: SortOrder
  updatedAt: SortOrder
}

input AddressOrderByWithAggregationInput {
  _avg: AddressAvgOrderByAggregateInput
  _count: AddressCountOrderByAggregateInput
  _max: AddressMaxOrderByAggregateInput
  _min: AddressMinOrderByAggregateInput
  _sum: AddressSumOrderByAggregateInput
  c1: SortOrder
  c2: SortOrderInput
  c3: SortOrderInput
  c4: SortOrderInput
  code: SortOrder
  createdAt: SortOrder
  id: SortOrder
  updatedAt: SortOrder
}

input AddressOrderByWithRelationInput {
  Post: PostOrderByRelationAggregateInput
  c1: SortOrder
  c2: SortOrderInput
  c3: SortOrderInput
  c4: SortOrderInput
  code: SortOrder
  createdAt: SortOrder
  id: SortOrder
  updatedAt: SortOrder
  users: UserAddressOrderByRelationAggregateInput
}

input AddressRelationFilter {
  is: AddressWhereInput
  isNot: AddressWhereInput
}

enum AddressScalarFieldEnum {
  c1
  c2
  c3
  c4
  code
  createdAt
  id
  updatedAt
}

input AddressScalarWhereWithAggregatesInput {
  AND: [AddressScalarWhereWithAggregatesInput!]
  NOT: [AddressScalarWhereWithAggregatesInput!]
  OR: [AddressScalarWhereWithAggregatesInput!]
  c1: StringWithAggregatesFilter
  c2: StringNullableWithAggregatesFilter
  c3: StringNullableWithAggregatesFilter
  c4: StringNullableWithAggregatesFilter
  code: StringWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type AddressSumAggregate {
  id: Int
}

input AddressSumOrderByAggregateInput {
  id: SortOrder
}

input AddressUpdateInput {
  Post: PostUpdateManyWithoutAddressNestedInput
  c1: StringFieldUpdateOperationsInput
  c2: NullableStringFieldUpdateOperationsInput
  c3: NullableStringFieldUpdateOperationsInput
  c4: NullableStringFieldUpdateOperationsInput
  code: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  users: UserAddressUpdateManyWithoutAddressNestedInput
}

input AddressUpdateManyMutationInput {
  c1: StringFieldUpdateOperationsInput
  c2: NullableStringFieldUpdateOperationsInput
  c3: NullableStringFieldUpdateOperationsInput
  c4: NullableStringFieldUpdateOperationsInput
  code: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AddressUpdateOneRequiredWithoutPostNestedInput {
  connect: AddressWhereUniqueInput
  update: AddressUpdateToOneWithWhereWithoutPostInput
}

input AddressUpdateOneRequiredWithoutUsersNestedInput {
  connect: AddressWhereUniqueInput
  update: AddressUpdateToOneWithWhereWithoutUsersInput
}

input AddressUpdateToOneWithWhereWithoutPostInput {
  data: AddressUpdateWithoutPostInput!
  where: AddressWhereInput
}

input AddressUpdateToOneWithWhereWithoutUsersInput {
  data: AddressUpdateWithoutUsersInput!
  where: AddressWhereInput
}

input AddressUpdateWithoutPostInput {
  c1: StringFieldUpdateOperationsInput
  c2: NullableStringFieldUpdateOperationsInput
  c3: NullableStringFieldUpdateOperationsInput
  c4: NullableStringFieldUpdateOperationsInput
  code: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  users: UserAddressUpdateManyWithoutAddressNestedInput
}

input AddressUpdateWithoutUsersInput {
  Post: PostUpdateManyWithoutAddressNestedInput
  c1: StringFieldUpdateOperationsInput
  c2: NullableStringFieldUpdateOperationsInput
  c3: NullableStringFieldUpdateOperationsInput
  c4: NullableStringFieldUpdateOperationsInput
  code: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AddressWhereInput {
  AND: [AddressWhereInput!]
  NOT: [AddressWhereInput!]
  OR: [AddressWhereInput!]
  Post: PostListRelationFilter
  c1: StringFilter
  c2: StringNullableFilter
  c3: StringNullableFilter
  c4: StringNullableFilter
  code: StringFilter
  createdAt: DateTimeFilter
  id: IntFilter
  updatedAt: DateTimeFilter
  users: UserAddressListRelationFilter
}

input AddressWhereUniqueInput {
  AND: [AddressWhereInput!]
  NOT: [AddressWhereInput!]
  OR: [AddressWhereInput!]
  Post: PostListRelationFilter
  c1: StringFilter
  c2: StringNullableFilter
  c3: StringNullableFilter
  c4: StringNullableFilter
  code: String
  createdAt: DateTimeFilter
  id: Int
  updatedAt: DateTimeFilter
  users: UserAddressListRelationFilter
}

type AffectedRowsOutput {
  count: Int!
}

type AggregateAccount {
  _avg: AccountAvgAggregate
  _count: AccountCountAggregate
  _max: AccountMaxAggregate
  _min: AccountMinAggregate
  _sum: AccountSumAggregate
}

type AggregateAddress {
  _avg: AddressAvgAggregate
  _count: AddressCountAggregate
  _max: AddressMaxAggregate
  _min: AddressMinAggregate
  _sum: AddressSumAggregate
}

type AggregateChat {
  _avg: ChatAvgAggregate
  _count: ChatCountAggregate
  _max: ChatMaxAggregate
  _min: ChatMinAggregate
  _sum: ChatSumAggregate
}

type AggregateChatMessage {
  _avg: ChatMessageAvgAggregate
  _count: ChatMessageCountAggregate
  _max: ChatMessageMaxAggregate
  _min: ChatMessageMinAggregate
  _sum: ChatMessageSumAggregate
}

type AggregateChatUser {
  _avg: ChatUserAvgAggregate
  _count: ChatUserCountAggregate
  _max: ChatUserMaxAggregate
  _min: ChatUserMinAggregate
  _sum: ChatUserSumAggregate
}

type AggregateComment {
  _avg: CommentAvgAggregate
  _count: CommentCountAggregate
  _max: CommentMaxAggregate
  _min: CommentMinAggregate
  _sum: CommentSumAggregate
}

type AggregateFile {
  _avg: FileAvgAggregate
  _count: FileCountAggregate
  _max: FileMaxAggregate
  _min: FileMinAggregate
  _sum: FileSumAggregate
}

type AggregatePost {
  _avg: PostAvgAggregate
  _count: PostCountAggregate
  _max: PostMaxAggregate
  _min: PostMinAggregate
  _sum: PostSumAggregate
}

type AggregatePostFile {
  _avg: PostFileAvgAggregate
  _count: PostFileCountAggregate
  _max: PostFileMaxAggregate
  _min: PostFileMinAggregate
  _sum: PostFileSumAggregate
}

type AggregateSession {
  _avg: SessionAvgAggregate
  _count: SessionCountAggregate
  _max: SessionMaxAggregate
  _min: SessionMinAggregate
  _sum: SessionSumAggregate
}

type AggregateUser {
  _avg: UserAvgAggregate
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  _sum: UserSumAggregate
}

type AggregateUserAddress {
  _avg: UserAddressAvgAggregate
  _count: UserAddressCountAggregate
  _max: UserAddressMaxAggregate
  _min: UserAddressMinAggregate
  _sum: UserAddressSumAggregate
}

type AggregateUserFile {
  _avg: UserFileAvgAggregate
  _count: UserFileCountAggregate
  _max: UserFileMaxAggregate
  _min: UserFileMinAggregate
  _sum: UserFileSumAggregate
}

type AggregateVerificationToken {
  _count: VerificationTokenCountAggregate
  _max: VerificationTokenMaxAggregate
  _min: VerificationTokenMinAggregate
}

type Chat {
  ChatMessage(cursor: ChatMessageWhereUniqueInput, distinct: [ChatMessageScalarFieldEnum!], orderBy: [ChatMessageOrderByWithRelationInput!], skip: Int, take: Int, where: ChatMessageWhereInput): [ChatMessage!]!
  ChatUser(cursor: ChatUserWhereUniqueInput, distinct: [ChatUserScalarFieldEnum!], orderBy: [ChatUserOrderByWithRelationInput!], skip: Int, take: Int, where: ChatUserWhereInput): [ChatUser!]!
  _count: ChatCount
  createdAt: DateTimeISO!
  id: ID!
  name: String
  updatedAt: DateTimeISO!
}

type ChatAvgAggregate {
  id: Float
}

input ChatAvgOrderByAggregateInput {
  id: SortOrder
}

type ChatCount {
  ChatMessage(where: ChatMessageWhereInput): Int!
  ChatUser(where: ChatUserWhereInput): Int!
}

type ChatCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  name: Int!
  updatedAt: Int!
}

input ChatCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input ChatCreateInput {
  ChatMessage: ChatMessageCreateNestedManyWithoutChatInput
  ChatUser: ChatUserCreateNestedManyWithoutChatInput
  createdAt: DateTimeISO
  name: String
  updatedAt: DateTimeISO
}

input ChatCreateManyInput {
  createdAt: DateTimeISO
  id: Int
  name: String
  updatedAt: DateTimeISO
}

input ChatCreateNestedOneWithoutChatMessageInput {
  connect: ChatWhereUniqueInput
  connectOrCreate: ChatCreateOrConnectWithoutChatMessageInput
  create: ChatCreateWithoutChatMessageInput
}

input ChatCreateNestedOneWithoutChatUserInput {
  connect: ChatWhereUniqueInput
  connectOrCreate: ChatCreateOrConnectWithoutChatUserInput
  create: ChatCreateWithoutChatUserInput
}

input ChatCreateOrConnectWithoutChatMessageInput {
  create: ChatCreateWithoutChatMessageInput!
  where: ChatWhereUniqueInput!
}

input ChatCreateOrConnectWithoutChatUserInput {
  create: ChatCreateWithoutChatUserInput!
  where: ChatWhereUniqueInput!
}

input ChatCreateWithoutChatMessageInput {
  ChatUser: ChatUserCreateNestedManyWithoutChatInput
  createdAt: DateTimeISO
  name: String
  updatedAt: DateTimeISO
}

input ChatCreateWithoutChatUserInput {
  ChatMessage: ChatMessageCreateNestedManyWithoutChatInput
  createdAt: DateTimeISO
  name: String
  updatedAt: DateTimeISO
}

type ChatGroupBy {
  _avg: ChatAvgAggregate
  _count: ChatCountAggregate
  _max: ChatMaxAggregate
  _min: ChatMinAggregate
  _sum: ChatSumAggregate
  createdAt: DateTimeISO!
  id: Int!
  name: String
  updatedAt: DateTimeISO!
}

type ChatMaxAggregate {
  createdAt: DateTimeISO
  id: Int
  name: String
  updatedAt: DateTimeISO
}

input ChatMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

type ChatMessage {
  chat: Chat!
  chatId: Int!
  createdAt: DateTimeISO!
  id: ID!
  message: String!
  updatedAt: DateTimeISO!
  userId: Int!
  username: String!
}

type ChatMessageAvgAggregate {
  chatId: Float
  id: Float
  userId: Float
}

input ChatMessageAvgOrderByAggregateInput {
  chatId: SortOrder
  id: SortOrder
  userId: SortOrder
}

type ChatMessageCountAggregate {
  _all: Int!
  chatId: Int!
  createdAt: Int!
  id: Int!
  message: Int!
  updatedAt: Int!
  userId: Int!
  username: Int!
}

input ChatMessageCountOrderByAggregateInput {
  chatId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  message: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
  username: SortOrder
}

input ChatMessageCreateInput {
  chat: ChatCreateNestedOneWithoutChatMessageInput!
  createdAt: DateTimeISO
  message: String!
  updatedAt: DateTimeISO
  userId: Int!
  username: String!
}

input ChatMessageCreateManyChatInput {
  createdAt: DateTimeISO
  id: Int
  message: String!
  updatedAt: DateTimeISO
  userId: Int!
  username: String!
}

input ChatMessageCreateManyChatInputEnvelope {
  data: [ChatMessageCreateManyChatInput!]!
  skipDuplicates: Boolean
}

input ChatMessageCreateManyInput {
  chatId: Int!
  createdAt: DateTimeISO
  id: Int
  message: String!
  updatedAt: DateTimeISO
  userId: Int!
  username: String!
}

input ChatMessageCreateNestedManyWithoutChatInput {
  connect: [ChatMessageWhereUniqueInput!]
  connectOrCreate: [ChatMessageCreateOrConnectWithoutChatInput!]
  create: [ChatMessageCreateWithoutChatInput!]
  createMany: ChatMessageCreateManyChatInputEnvelope
}

input ChatMessageCreateOrConnectWithoutChatInput {
  create: ChatMessageCreateWithoutChatInput!
  where: ChatMessageWhereUniqueInput!
}

input ChatMessageCreateWithoutChatInput {
  createdAt: DateTimeISO
  message: String!
  updatedAt: DateTimeISO
  userId: Int!
  username: String!
}

type ChatMessageGroupBy {
  _avg: ChatMessageAvgAggregate
  _count: ChatMessageCountAggregate
  _max: ChatMessageMaxAggregate
  _min: ChatMessageMinAggregate
  _sum: ChatMessageSumAggregate
  chatId: Int!
  createdAt: DateTimeISO!
  id: Int!
  message: String!
  updatedAt: DateTimeISO!
  userId: Int!
  username: String!
}

input ChatMessageListRelationFilter {
  every: ChatMessageWhereInput
  none: ChatMessageWhereInput
  some: ChatMessageWhereInput
}

type ChatMessageMaxAggregate {
  chatId: Int
  createdAt: DateTimeISO
  id: Int
  message: String
  updatedAt: DateTimeISO
  userId: Int
  username: String
}

input ChatMessageMaxOrderByAggregateInput {
  chatId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  message: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
  username: SortOrder
}

type ChatMessageMinAggregate {
  chatId: Int
  createdAt: DateTimeISO
  id: Int
  message: String
  updatedAt: DateTimeISO
  userId: Int
  username: String
}

input ChatMessageMinOrderByAggregateInput {
  chatId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  message: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
  username: SortOrder
}

input ChatMessageOrderByRelationAggregateInput {
  _count: SortOrder
}

input ChatMessageOrderByWithAggregationInput {
  _avg: ChatMessageAvgOrderByAggregateInput
  _count: ChatMessageCountOrderByAggregateInput
  _max: ChatMessageMaxOrderByAggregateInput
  _min: ChatMessageMinOrderByAggregateInput
  _sum: ChatMessageSumOrderByAggregateInput
  chatId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  message: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
  username: SortOrder
}

input ChatMessageOrderByWithRelationInput {
  chat: ChatOrderByWithRelationInput
  chatId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  message: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
  username: SortOrder
}

enum ChatMessageScalarFieldEnum {
  chatId
  createdAt
  id
  message
  updatedAt
  userId
  username
}

input ChatMessageScalarWhereInput {
  AND: [ChatMessageScalarWhereInput!]
  NOT: [ChatMessageScalarWhereInput!]
  OR: [ChatMessageScalarWhereInput!]
  chatId: IntFilter
  createdAt: DateTimeFilter
  id: IntFilter
  message: StringFilter
  updatedAt: DateTimeFilter
  userId: IntFilter
  username: StringFilter
}

input ChatMessageScalarWhereWithAggregatesInput {
  AND: [ChatMessageScalarWhereWithAggregatesInput!]
  NOT: [ChatMessageScalarWhereWithAggregatesInput!]
  OR: [ChatMessageScalarWhereWithAggregatesInput!]
  chatId: IntWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  message: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  userId: IntWithAggregatesFilter
  username: StringWithAggregatesFilter
}

type ChatMessageSumAggregate {
  chatId: Int
  id: Int
  userId: Int
}

input ChatMessageSumOrderByAggregateInput {
  chatId: SortOrder
  id: SortOrder
  userId: SortOrder
}

input ChatMessageUpdateInput {
  chat: ChatUpdateOneRequiredWithoutChatMessageNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  message: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  userId: IntFieldUpdateOperationsInput
  username: StringFieldUpdateOperationsInput
}

input ChatMessageUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  message: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  userId: IntFieldUpdateOperationsInput
  username: StringFieldUpdateOperationsInput
}

input ChatMessageUpdateManyWithWhereWithoutChatInput {
  data: ChatMessageUpdateManyMutationInput!
  where: ChatMessageScalarWhereInput!
}

input ChatMessageUpdateManyWithoutChatNestedInput {
  connect: [ChatMessageWhereUniqueInput!]
  connectOrCreate: [ChatMessageCreateOrConnectWithoutChatInput!]
  create: [ChatMessageCreateWithoutChatInput!]
  createMany: ChatMessageCreateManyChatInputEnvelope
  delete: [ChatMessageWhereUniqueInput!]
  deleteMany: [ChatMessageScalarWhereInput!]
  disconnect: [ChatMessageWhereUniqueInput!]
  set: [ChatMessageWhereUniqueInput!]
  update: [ChatMessageUpdateWithWhereUniqueWithoutChatInput!]
  updateMany: [ChatMessageUpdateManyWithWhereWithoutChatInput!]
  upsert: [ChatMessageUpsertWithWhereUniqueWithoutChatInput!]
}

input ChatMessageUpdateWithWhereUniqueWithoutChatInput {
  data: ChatMessageUpdateWithoutChatInput!
  where: ChatMessageWhereUniqueInput!
}

input ChatMessageUpdateWithoutChatInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  message: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  userId: IntFieldUpdateOperationsInput
  username: StringFieldUpdateOperationsInput
}

input ChatMessageUpsertWithWhereUniqueWithoutChatInput {
  create: ChatMessageCreateWithoutChatInput!
  update: ChatMessageUpdateWithoutChatInput!
  where: ChatMessageWhereUniqueInput!
}

input ChatMessageWhereInput {
  AND: [ChatMessageWhereInput!]
  NOT: [ChatMessageWhereInput!]
  OR: [ChatMessageWhereInput!]
  chat: ChatRelationFilter
  chatId: IntFilter
  createdAt: DateTimeFilter
  id: IntFilter
  message: StringFilter
  updatedAt: DateTimeFilter
  userId: IntFilter
  username: StringFilter
}

input ChatMessageWhereUniqueInput {
  AND: [ChatMessageWhereInput!]
  NOT: [ChatMessageWhereInput!]
  OR: [ChatMessageWhereInput!]
  chat: ChatRelationFilter
  chatId: IntFilter
  createdAt: DateTimeFilter
  id: Int
  message: StringFilter
  updatedAt: DateTimeFilter
  userId: IntFilter
  username: StringFilter
}

type ChatMinAggregate {
  createdAt: DateTimeISO
  id: Int
  name: String
  updatedAt: DateTimeISO
}

input ChatMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input ChatOrderByWithAggregationInput {
  _avg: ChatAvgOrderByAggregateInput
  _count: ChatCountOrderByAggregateInput
  _max: ChatMaxOrderByAggregateInput
  _min: ChatMinOrderByAggregateInput
  _sum: ChatSumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  name: SortOrderInput
  updatedAt: SortOrder
}

input ChatOrderByWithRelationInput {
  ChatMessage: ChatMessageOrderByRelationAggregateInput
  ChatUser: ChatUserOrderByRelationAggregateInput
  createdAt: SortOrder
  id: SortOrder
  name: SortOrderInput
  updatedAt: SortOrder
}

input ChatRelationFilter {
  is: ChatWhereInput
  isNot: ChatWhereInput
}

enum ChatScalarFieldEnum {
  createdAt
  id
  name
  updatedAt
}

input ChatScalarWhereWithAggregatesInput {
  AND: [ChatScalarWhereWithAggregatesInput!]
  NOT: [ChatScalarWhereWithAggregatesInput!]
  OR: [ChatScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringNullableWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type ChatSumAggregate {
  id: Int
}

input ChatSumOrderByAggregateInput {
  id: SortOrder
}

input ChatUpdateInput {
  ChatMessage: ChatMessageUpdateManyWithoutChatNestedInput
  ChatUser: ChatUserUpdateManyWithoutChatNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ChatUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ChatUpdateOneRequiredWithoutChatMessageNestedInput {
  connect: ChatWhereUniqueInput
  connectOrCreate: ChatCreateOrConnectWithoutChatMessageInput
  create: ChatCreateWithoutChatMessageInput
  update: ChatUpdateToOneWithWhereWithoutChatMessageInput
  upsert: ChatUpsertWithoutChatMessageInput
}

input ChatUpdateOneRequiredWithoutChatUserNestedInput {
  connect: ChatWhereUniqueInput
  connectOrCreate: ChatCreateOrConnectWithoutChatUserInput
  create: ChatCreateWithoutChatUserInput
  update: ChatUpdateToOneWithWhereWithoutChatUserInput
  upsert: ChatUpsertWithoutChatUserInput
}

input ChatUpdateToOneWithWhereWithoutChatMessageInput {
  data: ChatUpdateWithoutChatMessageInput!
  where: ChatWhereInput
}

input ChatUpdateToOneWithWhereWithoutChatUserInput {
  data: ChatUpdateWithoutChatUserInput!
  where: ChatWhereInput
}

input ChatUpdateWithoutChatMessageInput {
  ChatUser: ChatUserUpdateManyWithoutChatNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ChatUpdateWithoutChatUserInput {
  ChatMessage: ChatMessageUpdateManyWithoutChatNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ChatUpsertWithoutChatMessageInput {
  create: ChatCreateWithoutChatMessageInput!
  update: ChatUpdateWithoutChatMessageInput!
  where: ChatWhereInput
}

input ChatUpsertWithoutChatUserInput {
  create: ChatCreateWithoutChatUserInput!
  update: ChatUpdateWithoutChatUserInput!
  where: ChatWhereInput
}

type ChatUser {
  chat: Chat!
  chatId: Int!
  createdAt: DateTimeISO!
  id: ID!
  updatedAt: DateTimeISO!
  user: User!
  userId: Int!
}

type ChatUserAvgAggregate {
  chatId: Float
  id: Float
  userId: Float
}

input ChatUserAvgOrderByAggregateInput {
  chatId: SortOrder
  id: SortOrder
  userId: SortOrder
}

type ChatUserCountAggregate {
  _all: Int!
  chatId: Int!
  createdAt: Int!
  id: Int!
  updatedAt: Int!
  userId: Int!
}

input ChatUserCountOrderByAggregateInput {
  chatId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input ChatUserCreateInput {
  chat: ChatCreateNestedOneWithoutChatUserInput!
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  user: UserCreateNestedOneWithoutChatUserInput!
}

input ChatUserCreateManyChatInput {
  createdAt: DateTimeISO
  id: Int
  updatedAt: DateTimeISO
  userId: Int!
}

input ChatUserCreateManyChatInputEnvelope {
  data: [ChatUserCreateManyChatInput!]!
  skipDuplicates: Boolean
}

input ChatUserCreateManyInput {
  chatId: Int!
  createdAt: DateTimeISO
  id: Int
  updatedAt: DateTimeISO
  userId: Int!
}

input ChatUserCreateManyUserInput {
  chatId: Int!
  createdAt: DateTimeISO
  id: Int
  updatedAt: DateTimeISO
}

input ChatUserCreateManyUserInputEnvelope {
  data: [ChatUserCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input ChatUserCreateNestedManyWithoutChatInput {
  connect: [ChatUserWhereUniqueInput!]
  connectOrCreate: [ChatUserCreateOrConnectWithoutChatInput!]
  create: [ChatUserCreateWithoutChatInput!]
  createMany: ChatUserCreateManyChatInputEnvelope
}

input ChatUserCreateNestedManyWithoutUserInput {
  connect: [ChatUserWhereUniqueInput!]
  connectOrCreate: [ChatUserCreateOrConnectWithoutUserInput!]
  create: [ChatUserCreateWithoutUserInput!]
  createMany: ChatUserCreateManyUserInputEnvelope
}

input ChatUserCreateOrConnectWithoutChatInput {
  create: ChatUserCreateWithoutChatInput!
  where: ChatUserWhereUniqueInput!
}

input ChatUserCreateOrConnectWithoutUserInput {
  create: ChatUserCreateWithoutUserInput!
  where: ChatUserWhereUniqueInput!
}

input ChatUserCreateWithoutChatInput {
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  user: UserCreateNestedOneWithoutChatUserInput!
}

input ChatUserCreateWithoutUserInput {
  chat: ChatCreateNestedOneWithoutChatUserInput!
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
}

type ChatUserGroupBy {
  _avg: ChatUserAvgAggregate
  _count: ChatUserCountAggregate
  _max: ChatUserMaxAggregate
  _min: ChatUserMinAggregate
  _sum: ChatUserSumAggregate
  chatId: Int!
  createdAt: DateTimeISO!
  id: Int!
  updatedAt: DateTimeISO!
  userId: Int!
}

input ChatUserListRelationFilter {
  every: ChatUserWhereInput
  none: ChatUserWhereInput
  some: ChatUserWhereInput
}

type ChatUserMaxAggregate {
  chatId: Int
  createdAt: DateTimeISO
  id: Int
  updatedAt: DateTimeISO
  userId: Int
}

input ChatUserMaxOrderByAggregateInput {
  chatId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

type ChatUserMinAggregate {
  chatId: Int
  createdAt: DateTimeISO
  id: Int
  updatedAt: DateTimeISO
  userId: Int
}

input ChatUserMinOrderByAggregateInput {
  chatId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input ChatUserOrderByRelationAggregateInput {
  _count: SortOrder
}

input ChatUserOrderByWithAggregationInput {
  _avg: ChatUserAvgOrderByAggregateInput
  _count: ChatUserCountOrderByAggregateInput
  _max: ChatUserMaxOrderByAggregateInput
  _min: ChatUserMinOrderByAggregateInput
  _sum: ChatUserSumOrderByAggregateInput
  chatId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input ChatUserOrderByWithRelationInput {
  chat: ChatOrderByWithRelationInput
  chatId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  updatedAt: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

enum ChatUserScalarFieldEnum {
  chatId
  createdAt
  id
  updatedAt
  userId
}

input ChatUserScalarWhereInput {
  AND: [ChatUserScalarWhereInput!]
  NOT: [ChatUserScalarWhereInput!]
  OR: [ChatUserScalarWhereInput!]
  chatId: IntFilter
  createdAt: DateTimeFilter
  id: IntFilter
  updatedAt: DateTimeFilter
  userId: IntFilter
}

input ChatUserScalarWhereWithAggregatesInput {
  AND: [ChatUserScalarWhereWithAggregatesInput!]
  NOT: [ChatUserScalarWhereWithAggregatesInput!]
  OR: [ChatUserScalarWhereWithAggregatesInput!]
  chatId: IntWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  userId: IntWithAggregatesFilter
}

type ChatUserSumAggregate {
  chatId: Int
  id: Int
  userId: Int
}

input ChatUserSumOrderByAggregateInput {
  chatId: SortOrder
  id: SortOrder
  userId: SortOrder
}

input ChatUserUpdateInput {
  chat: ChatUpdateOneRequiredWithoutChatUserNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutChatUserNestedInput
}

input ChatUserUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ChatUserUpdateManyWithWhereWithoutChatInput {
  data: ChatUserUpdateManyMutationInput!
  where: ChatUserScalarWhereInput!
}

input ChatUserUpdateManyWithWhereWithoutUserInput {
  data: ChatUserUpdateManyMutationInput!
  where: ChatUserScalarWhereInput!
}

input ChatUserUpdateManyWithoutChatNestedInput {
  connect: [ChatUserWhereUniqueInput!]
  connectOrCreate: [ChatUserCreateOrConnectWithoutChatInput!]
  create: [ChatUserCreateWithoutChatInput!]
  createMany: ChatUserCreateManyChatInputEnvelope
  delete: [ChatUserWhereUniqueInput!]
  deleteMany: [ChatUserScalarWhereInput!]
  disconnect: [ChatUserWhereUniqueInput!]
  set: [ChatUserWhereUniqueInput!]
  update: [ChatUserUpdateWithWhereUniqueWithoutChatInput!]
  updateMany: [ChatUserUpdateManyWithWhereWithoutChatInput!]
  upsert: [ChatUserUpsertWithWhereUniqueWithoutChatInput!]
}

input ChatUserUpdateManyWithoutUserNestedInput {
  connect: [ChatUserWhereUniqueInput!]
  connectOrCreate: [ChatUserCreateOrConnectWithoutUserInput!]
  create: [ChatUserCreateWithoutUserInput!]
  createMany: ChatUserCreateManyUserInputEnvelope
  delete: [ChatUserWhereUniqueInput!]
  deleteMany: [ChatUserScalarWhereInput!]
  disconnect: [ChatUserWhereUniqueInput!]
  set: [ChatUserWhereUniqueInput!]
  update: [ChatUserUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [ChatUserUpdateManyWithWhereWithoutUserInput!]
  upsert: [ChatUserUpsertWithWhereUniqueWithoutUserInput!]
}

input ChatUserUpdateWithWhereUniqueWithoutChatInput {
  data: ChatUserUpdateWithoutChatInput!
  where: ChatUserWhereUniqueInput!
}

input ChatUserUpdateWithWhereUniqueWithoutUserInput {
  data: ChatUserUpdateWithoutUserInput!
  where: ChatUserWhereUniqueInput!
}

input ChatUserUpdateWithoutChatInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutChatUserNestedInput
}

input ChatUserUpdateWithoutUserInput {
  chat: ChatUpdateOneRequiredWithoutChatUserNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ChatUserUpsertWithWhereUniqueWithoutChatInput {
  create: ChatUserCreateWithoutChatInput!
  update: ChatUserUpdateWithoutChatInput!
  where: ChatUserWhereUniqueInput!
}

input ChatUserUpsertWithWhereUniqueWithoutUserInput {
  create: ChatUserCreateWithoutUserInput!
  update: ChatUserUpdateWithoutUserInput!
  where: ChatUserWhereUniqueInput!
}

input ChatUserWhereInput {
  AND: [ChatUserWhereInput!]
  NOT: [ChatUserWhereInput!]
  OR: [ChatUserWhereInput!]
  chat: ChatRelationFilter
  chatId: IntFilter
  createdAt: DateTimeFilter
  id: IntFilter
  updatedAt: DateTimeFilter
  user: UserRelationFilter
  userId: IntFilter
}

input ChatUserWhereUniqueInput {
  AND: [ChatUserWhereInput!]
  NOT: [ChatUserWhereInput!]
  OR: [ChatUserWhereInput!]
  chat: ChatRelationFilter
  chatId: IntFilter
  createdAt: DateTimeFilter
  id: Int
  updatedAt: DateTimeFilter
  user: UserRelationFilter
  userId: IntFilter
}

input ChatWhereInput {
  AND: [ChatWhereInput!]
  ChatMessage: ChatMessageListRelationFilter
  ChatUser: ChatUserListRelationFilter
  NOT: [ChatWhereInput!]
  OR: [ChatWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  name: StringNullableFilter
  updatedAt: DateTimeFilter
}

input ChatWhereUniqueInput {
  AND: [ChatWhereInput!]
  ChatMessage: ChatMessageListRelationFilter
  ChatUser: ChatUserListRelationFilter
  NOT: [ChatWhereInput!]
  OR: [ChatWhereInput!]
  createdAt: DateTimeFilter
  id: Int
  name: StringNullableFilter
  updatedAt: DateTimeFilter
}

type Comment {
  content: String!
  createdAt: DateTimeISO!
  id: ID!
  post: Post!
  postId: Int!
  updatedAt: DateTimeISO!
  user: User!
  userId: Int!
}

type CommentAvgAggregate {
  id: Float
  postId: Float
  userId: Float
}

input CommentAvgOrderByAggregateInput {
  id: SortOrder
  postId: SortOrder
  userId: SortOrder
}

type CommentCountAggregate {
  _all: Int!
  content: Int!
  createdAt: Int!
  id: Int!
  postId: Int!
  updatedAt: Int!
  userId: Int!
}

input CommentCountOrderByAggregateInput {
  content: SortOrder
  createdAt: SortOrder
  id: SortOrder
  postId: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input CommentCreateInput {
  content: String!
  createdAt: DateTimeISO
  post: PostCreateNestedOneWithoutCommentInput!
  updatedAt: DateTimeISO
  user: UserCreateNestedOneWithoutCommentInput!
}

input CommentCreateManyInput {
  content: String!
  createdAt: DateTimeISO
  id: Int
  postId: Int!
  updatedAt: DateTimeISO
  userId: Int!
}

input CommentCreateManyPostInput {
  content: String!
  createdAt: DateTimeISO
  id: Int
  updatedAt: DateTimeISO
  userId: Int!
}

input CommentCreateManyPostInputEnvelope {
  data: [CommentCreateManyPostInput!]!
  skipDuplicates: Boolean
}

input CommentCreateManyUserInput {
  content: String!
  createdAt: DateTimeISO
  id: Int
  postId: Int!
  updatedAt: DateTimeISO
}

input CommentCreateManyUserInputEnvelope {
  data: [CommentCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input CommentCreateNestedManyWithoutPostInput {
  connect: [CommentWhereUniqueInput!]
  connectOrCreate: [CommentCreateOrConnectWithoutPostInput!]
  create: [CommentCreateWithoutPostInput!]
  createMany: CommentCreateManyPostInputEnvelope
}

input CommentCreateNestedManyWithoutUserInput {
  connect: [CommentWhereUniqueInput!]
  connectOrCreate: [CommentCreateOrConnectWithoutUserInput!]
  create: [CommentCreateWithoutUserInput!]
  createMany: CommentCreateManyUserInputEnvelope
}

input CommentCreateOrConnectWithoutPostInput {
  create: CommentCreateWithoutPostInput!
  where: CommentWhereUniqueInput!
}

input CommentCreateOrConnectWithoutUserInput {
  create: CommentCreateWithoutUserInput!
  where: CommentWhereUniqueInput!
}

input CommentCreateWithoutPostInput {
  content: String!
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  user: UserCreateNestedOneWithoutCommentInput!
}

input CommentCreateWithoutUserInput {
  content: String!
  createdAt: DateTimeISO
  post: PostCreateNestedOneWithoutCommentInput!
  updatedAt: DateTimeISO
}

type CommentGroupBy {
  _avg: CommentAvgAggregate
  _count: CommentCountAggregate
  _max: CommentMaxAggregate
  _min: CommentMinAggregate
  _sum: CommentSumAggregate
  content: String!
  createdAt: DateTimeISO!
  id: Int!
  postId: Int!
  updatedAt: DateTimeISO!
  userId: Int!
}

input CommentListRelationFilter {
  every: CommentWhereInput
  none: CommentWhereInput
  some: CommentWhereInput
}

type CommentMaxAggregate {
  content: String
  createdAt: DateTimeISO
  id: Int
  postId: Int
  updatedAt: DateTimeISO
  userId: Int
}

input CommentMaxOrderByAggregateInput {
  content: SortOrder
  createdAt: SortOrder
  id: SortOrder
  postId: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

type CommentMinAggregate {
  content: String
  createdAt: DateTimeISO
  id: Int
  postId: Int
  updatedAt: DateTimeISO
  userId: Int
}

input CommentMinOrderByAggregateInput {
  content: SortOrder
  createdAt: SortOrder
  id: SortOrder
  postId: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input CommentOrderByRelationAggregateInput {
  _count: SortOrder
}

input CommentOrderByWithAggregationInput {
  _avg: CommentAvgOrderByAggregateInput
  _count: CommentCountOrderByAggregateInput
  _max: CommentMaxOrderByAggregateInput
  _min: CommentMinOrderByAggregateInput
  _sum: CommentSumOrderByAggregateInput
  content: SortOrder
  createdAt: SortOrder
  id: SortOrder
  postId: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input CommentOrderByWithRelationInput {
  content: SortOrder
  createdAt: SortOrder
  id: SortOrder
  post: PostOrderByWithRelationInput
  postId: SortOrder
  updatedAt: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

enum CommentScalarFieldEnum {
  content
  createdAt
  id
  postId
  updatedAt
  userId
}

input CommentScalarWhereInput {
  AND: [CommentScalarWhereInput!]
  NOT: [CommentScalarWhereInput!]
  OR: [CommentScalarWhereInput!]
  content: StringFilter
  createdAt: DateTimeFilter
  id: IntFilter
  postId: IntFilter
  updatedAt: DateTimeFilter
  userId: IntFilter
}

input CommentScalarWhereWithAggregatesInput {
  AND: [CommentScalarWhereWithAggregatesInput!]
  NOT: [CommentScalarWhereWithAggregatesInput!]
  OR: [CommentScalarWhereWithAggregatesInput!]
  content: StringWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  postId: IntWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  userId: IntWithAggregatesFilter
}

type CommentSumAggregate {
  id: Int
  postId: Int
  userId: Int
}

input CommentSumOrderByAggregateInput {
  id: SortOrder
  postId: SortOrder
  userId: SortOrder
}

input CommentUpdateInput {
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  post: PostUpdateOneRequiredWithoutCommentNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutCommentNestedInput
}

input CommentUpdateManyMutationInput {
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CommentUpdateManyWithWhereWithoutPostInput {
  data: CommentUpdateManyMutationInput!
  where: CommentScalarWhereInput!
}

input CommentUpdateManyWithWhereWithoutUserInput {
  data: CommentUpdateManyMutationInput!
  where: CommentScalarWhereInput!
}

input CommentUpdateManyWithoutPostNestedInput {
  connect: [CommentWhereUniqueInput!]
  connectOrCreate: [CommentCreateOrConnectWithoutPostInput!]
  create: [CommentCreateWithoutPostInput!]
  createMany: CommentCreateManyPostInputEnvelope
  delete: [CommentWhereUniqueInput!]
  deleteMany: [CommentScalarWhereInput!]
  disconnect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutPostInput!]
  updateMany: [CommentUpdateManyWithWhereWithoutPostInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutPostInput!]
}

input CommentUpdateManyWithoutUserNestedInput {
  connect: [CommentWhereUniqueInput!]
  connectOrCreate: [CommentCreateOrConnectWithoutUserInput!]
  create: [CommentCreateWithoutUserInput!]
  createMany: CommentCreateManyUserInputEnvelope
  delete: [CommentWhereUniqueInput!]
  deleteMany: [CommentScalarWhereInput!]
  disconnect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [CommentUpdateManyWithWhereWithoutUserInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutUserInput!]
}

input CommentUpdateWithWhereUniqueWithoutPostInput {
  data: CommentUpdateWithoutPostInput!
  where: CommentWhereUniqueInput!
}

input CommentUpdateWithWhereUniqueWithoutUserInput {
  data: CommentUpdateWithoutUserInput!
  where: CommentWhereUniqueInput!
}

input CommentUpdateWithoutPostInput {
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutCommentNestedInput
}

input CommentUpdateWithoutUserInput {
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  post: PostUpdateOneRequiredWithoutCommentNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CommentUpsertWithWhereUniqueWithoutPostInput {
  create: CommentCreateWithoutPostInput!
  update: CommentUpdateWithoutPostInput!
  where: CommentWhereUniqueInput!
}

input CommentUpsertWithWhereUniqueWithoutUserInput {
  create: CommentCreateWithoutUserInput!
  update: CommentUpdateWithoutUserInput!
  where: CommentWhereUniqueInput!
}

input CommentWhereInput {
  AND: [CommentWhereInput!]
  NOT: [CommentWhereInput!]
  OR: [CommentWhereInput!]
  content: StringFilter
  createdAt: DateTimeFilter
  id: IntFilter
  post: PostRelationFilter
  postId: IntFilter
  updatedAt: DateTimeFilter
  user: UserRelationFilter
  userId: IntFilter
}

input CommentWhereUniqueInput {
  AND: [CommentWhereInput!]
  NOT: [CommentWhereInput!]
  OR: [CommentWhereInput!]
  content: StringFilter
  createdAt: DateTimeFilter
  id: Int
  post: PostRelationFilter
  postId: IntFilter
  updatedAt: DateTimeFilter
  user: UserRelationFilter
  userId: IntFilter
}

input DateTimeFieldUpdateOperationsInput {
  set: DateTimeISO
}

input DateTimeFilter {
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeFilter
  notIn: [DateTimeISO!]
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.This scalar is serialized to a string in ISO 8601 format and parsed from a string in ISO 8601 format.
"""
scalar DateTimeISO

input DateTimeNullableFilter {
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeNullableFilter
  notIn: [DateTimeISO!]
}

input DateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTimeISO!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTimeISO!]
}

input EnumFileStorageTypeFieldUpdateOperationsInput {
  set: FileStorageType
}

input EnumFileStorageTypeFilter {
  equals: FileStorageType
  in: [FileStorageType!]
  not: NestedEnumFileStorageTypeFilter
  notIn: [FileStorageType!]
}

input EnumFileStorageTypeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumFileStorageTypeFilter
  _min: NestedEnumFileStorageTypeFilter
  equals: FileStorageType
  in: [FileStorageType!]
  not: NestedEnumFileStorageTypeWithAggregatesFilter
  notIn: [FileStorageType!]
}

input EnumRoleFieldUpdateOperationsInput {
  set: Role
}

input EnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input EnumRoleWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumRoleFilter
  _min: NestedEnumRoleFilter
  equals: Role
  in: [Role!]
  not: NestedEnumRoleWithAggregatesFilter
  notIn: [Role!]
}

type File {
  UserFile(cursor: UserFileWhereUniqueInput, distinct: [UserFileScalarFieldEnum!], orderBy: [UserFileOrderByWithRelationInput!], skip: Int, take: Int, where: UserFileWhereInput): [UserFile!]!
  _count: FileCount
  createdAt: DateTimeISO!
  id: ID!
  location: String!
  posts(cursor: PostFileWhereUniqueInput, distinct: [PostFileScalarFieldEnum!], orderBy: [PostFileOrderByWithRelationInput!], skip: Int, take: Int, where: PostFileWhereInput): [PostFile!]!
  type: FileStorageType!
  updatedAt: DateTimeISO!
}

type FileAvgAggregate {
  id: Float
}

input FileAvgOrderByAggregateInput {
  id: SortOrder
}

type FileCount {
  UserFile(where: UserFileWhereInput): Int!
  posts(where: PostFileWhereInput): Int!
}

type FileCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  location: Int!
  type: Int!
  updatedAt: Int!
}

input FileCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  location: SortOrder
  type: SortOrder
  updatedAt: SortOrder
}

input FileCreateInput {
  UserFile: UserFileCreateNestedManyWithoutFileInput
  createdAt: DateTimeISO
  location: String!
  posts: PostFileCreateNestedManyWithoutFileInput
  type: FileStorageType
  updatedAt: DateTimeISO
}

input FileCreateManyInput {
  createdAt: DateTimeISO
  id: Int
  location: String!
  type: FileStorageType
  updatedAt: DateTimeISO
}

input FileCreateNestedOneWithoutPostsInput {
  connect: FileWhereUniqueInput
  connectOrCreate: FileCreateOrConnectWithoutPostsInput
  create: FileCreateWithoutPostsInput
}

input FileCreateNestedOneWithoutUserFileInput {
  connect: FileWhereUniqueInput
  connectOrCreate: FileCreateOrConnectWithoutUserFileInput
  create: FileCreateWithoutUserFileInput
}

input FileCreateOrConnectWithoutPostsInput {
  create: FileCreateWithoutPostsInput!
  where: FileWhereUniqueInput!
}

input FileCreateOrConnectWithoutUserFileInput {
  create: FileCreateWithoutUserFileInput!
  where: FileWhereUniqueInput!
}

input FileCreateWithoutPostsInput {
  UserFile: UserFileCreateNestedManyWithoutFileInput
  createdAt: DateTimeISO
  location: String!
  type: FileStorageType
  updatedAt: DateTimeISO
}

input FileCreateWithoutUserFileInput {
  createdAt: DateTimeISO
  location: String!
  posts: PostFileCreateNestedManyWithoutFileInput
  type: FileStorageType
  updatedAt: DateTimeISO
}

type FileGroupBy {
  _avg: FileAvgAggregate
  _count: FileCountAggregate
  _max: FileMaxAggregate
  _min: FileMinAggregate
  _sum: FileSumAggregate
  createdAt: DateTimeISO!
  id: Int!
  location: String!
  type: FileStorageType!
  updatedAt: DateTimeISO!
}

type FileMaxAggregate {
  createdAt: DateTimeISO
  id: Int
  location: String
  type: FileStorageType
  updatedAt: DateTimeISO
}

input FileMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  location: SortOrder
  type: SortOrder
  updatedAt: SortOrder
}

type FileMinAggregate {
  createdAt: DateTimeISO
  id: Int
  location: String
  type: FileStorageType
  updatedAt: DateTimeISO
}

input FileMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  location: SortOrder
  type: SortOrder
  updatedAt: SortOrder
}

input FileOrderByWithAggregationInput {
  _avg: FileAvgOrderByAggregateInput
  _count: FileCountOrderByAggregateInput
  _max: FileMaxOrderByAggregateInput
  _min: FileMinOrderByAggregateInput
  _sum: FileSumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  location: SortOrder
  type: SortOrder
  updatedAt: SortOrder
}

input FileOrderByWithRelationInput {
  UserFile: UserFileOrderByRelationAggregateInput
  createdAt: SortOrder
  id: SortOrder
  location: SortOrder
  posts: PostFileOrderByRelationAggregateInput
  type: SortOrder
  updatedAt: SortOrder
}

input FileRelationFilter {
  is: FileWhereInput
  isNot: FileWhereInput
}

enum FileScalarFieldEnum {
  createdAt
  id
  location
  type
  updatedAt
}

input FileScalarWhereWithAggregatesInput {
  AND: [FileScalarWhereWithAggregatesInput!]
  NOT: [FileScalarWhereWithAggregatesInput!]
  OR: [FileScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  location: StringWithAggregatesFilter
  type: EnumFileStorageTypeWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

enum FileStorageType {
  S3
}

type FileSumAggregate {
  id: Int
}

input FileSumOrderByAggregateInput {
  id: SortOrder
}

input FileUpdateInput {
  UserFile: UserFileUpdateManyWithoutFileNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  location: StringFieldUpdateOperationsInput
  posts: PostFileUpdateManyWithoutFileNestedInput
  type: EnumFileStorageTypeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input FileUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  location: StringFieldUpdateOperationsInput
  type: EnumFileStorageTypeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input FileUpdateOneRequiredWithoutPostsNestedInput {
  connect: FileWhereUniqueInput
  connectOrCreate: FileCreateOrConnectWithoutPostsInput
  create: FileCreateWithoutPostsInput
  update: FileUpdateToOneWithWhereWithoutPostsInput
  upsert: FileUpsertWithoutPostsInput
}

input FileUpdateOneRequiredWithoutUserFileNestedInput {
  connect: FileWhereUniqueInput
  connectOrCreate: FileCreateOrConnectWithoutUserFileInput
  create: FileCreateWithoutUserFileInput
  update: FileUpdateToOneWithWhereWithoutUserFileInput
  upsert: FileUpsertWithoutUserFileInput
}

input FileUpdateToOneWithWhereWithoutPostsInput {
  data: FileUpdateWithoutPostsInput!
  where: FileWhereInput
}

input FileUpdateToOneWithWhereWithoutUserFileInput {
  data: FileUpdateWithoutUserFileInput!
  where: FileWhereInput
}

input FileUpdateWithoutPostsInput {
  UserFile: UserFileUpdateManyWithoutFileNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  location: StringFieldUpdateOperationsInput
  type: EnumFileStorageTypeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input FileUpdateWithoutUserFileInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  location: StringFieldUpdateOperationsInput
  posts: PostFileUpdateManyWithoutFileNestedInput
  type: EnumFileStorageTypeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input FileUpsertWithoutPostsInput {
  create: FileCreateWithoutPostsInput!
  update: FileUpdateWithoutPostsInput!
  where: FileWhereInput
}

input FileUpsertWithoutUserFileInput {
  create: FileCreateWithoutUserFileInput!
  update: FileUpdateWithoutUserFileInput!
  where: FileWhereInput
}

input FileWhereInput {
  AND: [FileWhereInput!]
  NOT: [FileWhereInput!]
  OR: [FileWhereInput!]
  UserFile: UserFileListRelationFilter
  createdAt: DateTimeFilter
  id: IntFilter
  location: StringFilter
  posts: PostFileListRelationFilter
  type: EnumFileStorageTypeFilter
  updatedAt: DateTimeFilter
}

input FileWhereUniqueInput {
  AND: [FileWhereInput!]
  NOT: [FileWhereInput!]
  OR: [FileWhereInput!]
  UserFile: UserFileListRelationFilter
  createdAt: DateTimeFilter
  id: Int
  location: StringFilter
  posts: PostFileListRelationFilter
  type: EnumFileStorageTypeFilter
  updatedAt: DateTimeFilter
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input IntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type Mutation {
  createManyAccount(data: [AccountCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyChat(data: [ChatCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyChatMessage(data: [ChatMessageCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyChatUser(data: [ChatUserCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyComment(data: [CommentCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyFile(data: [FileCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyPost(data: [PostCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyPostFile(data: [PostFileCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManySession(data: [SessionCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyUser(data: [UserCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyUserAddress(data: [UserAddressCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyUserFile(data: [UserFileCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyVerificationToken(data: [VerificationTokenCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOneAccount(data: AccountCreateInput!, relationLoadStrategy: RelationLoadStrategy): Account!
  createOneChat(data: ChatCreateInput!, relationLoadStrategy: RelationLoadStrategy): Chat!
  createOneChatMessage(data: ChatMessageCreateInput!, relationLoadStrategy: RelationLoadStrategy): ChatMessage!
  createOneChatUser(data: ChatUserCreateInput!, relationLoadStrategy: RelationLoadStrategy): ChatUser!
  createOneComment(data: CommentCreateInput!, relationLoadStrategy: RelationLoadStrategy): Comment!
  createOneFile(data: FileCreateInput!, relationLoadStrategy: RelationLoadStrategy): File!
  createOnePost(data: PostCreateInput!, relationLoadStrategy: RelationLoadStrategy): Post!
  createOnePostFile(data: PostFileCreateInput!, relationLoadStrategy: RelationLoadStrategy): PostFile!
  createOneSession(data: SessionCreateInput!, relationLoadStrategy: RelationLoadStrategy): Session!
  createOneUser(data: UserCreateInput!, relationLoadStrategy: RelationLoadStrategy): User!
  createOneUserAddress(data: UserAddressCreateInput!, relationLoadStrategy: RelationLoadStrategy): UserAddress!
  createOneUserFile(data: UserFileCreateInput!, relationLoadStrategy: RelationLoadStrategy): UserFile!
  createOneVerificationToken(data: VerificationTokenCreateInput!, relationLoadStrategy: RelationLoadStrategy): VerificationToken!
  deleteManyAccount(where: AccountWhereInput): AffectedRowsOutput!
  deleteManyAddress(where: AddressWhereInput): AffectedRowsOutput!
  deleteManyChat(where: ChatWhereInput): AffectedRowsOutput!
  deleteManyChatMessage(where: ChatMessageWhereInput): AffectedRowsOutput!
  deleteManyChatUser(where: ChatUserWhereInput): AffectedRowsOutput!
  deleteManyComment(where: CommentWhereInput): AffectedRowsOutput!
  deleteManyFile(where: FileWhereInput): AffectedRowsOutput!
  deleteManyPost(where: PostWhereInput): AffectedRowsOutput!
  deleteManyPostFile(where: PostFileWhereInput): AffectedRowsOutput!
  deleteManySession(where: SessionWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteManyUserAddress(where: UserAddressWhereInput): AffectedRowsOutput!
  deleteManyUserFile(where: UserFileWhereInput): AffectedRowsOutput!
  deleteManyVerificationToken(where: VerificationTokenWhereInput): AffectedRowsOutput!
  deleteOneAccount(relationLoadStrategy: RelationLoadStrategy, where: AccountWhereUniqueInput!): Account
  deleteOneAddress(relationLoadStrategy: RelationLoadStrategy, where: AddressWhereUniqueInput!): Address
  deleteOneChat(relationLoadStrategy: RelationLoadStrategy, where: ChatWhereUniqueInput!): Chat
  deleteOneChatMessage(relationLoadStrategy: RelationLoadStrategy, where: ChatMessageWhereUniqueInput!): ChatMessage
  deleteOneChatUser(relationLoadStrategy: RelationLoadStrategy, where: ChatUserWhereUniqueInput!): ChatUser
  deleteOneComment(relationLoadStrategy: RelationLoadStrategy, where: CommentWhereUniqueInput!): Comment
  deleteOneFile(relationLoadStrategy: RelationLoadStrategy, where: FileWhereUniqueInput!): File
  deleteOnePost(relationLoadStrategy: RelationLoadStrategy, where: PostWhereUniqueInput!): Post
  deleteOnePostFile(relationLoadStrategy: RelationLoadStrategy, where: PostFileWhereUniqueInput!): PostFile
  deleteOneSession(relationLoadStrategy: RelationLoadStrategy, where: SessionWhereUniqueInput!): Session
  deleteOneUser(relationLoadStrategy: RelationLoadStrategy, where: UserWhereUniqueInput!): User
  deleteOneUserAddress(relationLoadStrategy: RelationLoadStrategy, where: UserAddressWhereUniqueInput!): UserAddress
  deleteOneUserFile(relationLoadStrategy: RelationLoadStrategy, where: UserFileWhereUniqueInput!): UserFile
  deleteOneVerificationToken(relationLoadStrategy: RelationLoadStrategy, where: VerificationTokenWhereUniqueInput!): VerificationToken
  updateManyAccount(data: AccountUpdateManyMutationInput!, where: AccountWhereInput): AffectedRowsOutput!
  updateManyAddress(data: AddressUpdateManyMutationInput!, where: AddressWhereInput): AffectedRowsOutput!
  updateManyChat(data: ChatUpdateManyMutationInput!, where: ChatWhereInput): AffectedRowsOutput!
  updateManyChatMessage(data: ChatMessageUpdateManyMutationInput!, where: ChatMessageWhereInput): AffectedRowsOutput!
  updateManyChatUser(data: ChatUserUpdateManyMutationInput!, where: ChatUserWhereInput): AffectedRowsOutput!
  updateManyComment(data: CommentUpdateManyMutationInput!, where: CommentWhereInput): AffectedRowsOutput!
  updateManyFile(data: FileUpdateManyMutationInput!, where: FileWhereInput): AffectedRowsOutput!
  updateManyPost(data: PostUpdateManyMutationInput!, where: PostWhereInput): AffectedRowsOutput!
  updateManyPostFile(data: PostFileUpdateManyMutationInput!, where: PostFileWhereInput): AffectedRowsOutput!
  updateManySession(data: SessionUpdateManyMutationInput!, where: SessionWhereInput): AffectedRowsOutput!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updateManyUserAddress(data: UserAddressUpdateManyMutationInput!, where: UserAddressWhereInput): AffectedRowsOutput!
  updateManyUserFile(data: UserFileUpdateManyMutationInput!, where: UserFileWhereInput): AffectedRowsOutput!
  updateManyVerificationToken(data: VerificationTokenUpdateManyMutationInput!, where: VerificationTokenWhereInput): AffectedRowsOutput!
  updateOneAccount(data: AccountUpdateInput!, relationLoadStrategy: RelationLoadStrategy, where: AccountWhereUniqueInput!): Account
  updateOneAddress(data: AddressUpdateInput!, relationLoadStrategy: RelationLoadStrategy, where: AddressWhereUniqueInput!): Address
  updateOneChat(data: ChatUpdateInput!, relationLoadStrategy: RelationLoadStrategy, where: ChatWhereUniqueInput!): Chat
  updateOneChatMessage(data: ChatMessageUpdateInput!, relationLoadStrategy: RelationLoadStrategy, where: ChatMessageWhereUniqueInput!): ChatMessage
  updateOneChatUser(data: ChatUserUpdateInput!, relationLoadStrategy: RelationLoadStrategy, where: ChatUserWhereUniqueInput!): ChatUser
  updateOneComment(data: CommentUpdateInput!, relationLoadStrategy: RelationLoadStrategy, where: CommentWhereUniqueInput!): Comment
  updateOneFile(data: FileUpdateInput!, relationLoadStrategy: RelationLoadStrategy, where: FileWhereUniqueInput!): File
  updateOnePost(data: PostUpdateInput!, relationLoadStrategy: RelationLoadStrategy, where: PostWhereUniqueInput!): Post
  updateOnePostFile(data: PostFileUpdateInput!, relationLoadStrategy: RelationLoadStrategy, where: PostFileWhereUniqueInput!): PostFile
  updateOneSession(data: SessionUpdateInput!, relationLoadStrategy: RelationLoadStrategy, where: SessionWhereUniqueInput!): Session
  updateOneUser(data: UserUpdateInput!, relationLoadStrategy: RelationLoadStrategy, where: UserWhereUniqueInput!): User
  updateOneUserAddress(data: UserAddressUpdateInput!, relationLoadStrategy: RelationLoadStrategy, where: UserAddressWhereUniqueInput!): UserAddress
  updateOneUserFile(data: UserFileUpdateInput!, relationLoadStrategy: RelationLoadStrategy, where: UserFileWhereUniqueInput!): UserFile
  updateOneVerificationToken(data: VerificationTokenUpdateInput!, relationLoadStrategy: RelationLoadStrategy, where: VerificationTokenWhereUniqueInput!): VerificationToken
  upsertOneAccount(create: AccountCreateInput!, relationLoadStrategy: RelationLoadStrategy, update: AccountUpdateInput!, where: AccountWhereUniqueInput!): Account!
  upsertOneChat(create: ChatCreateInput!, relationLoadStrategy: RelationLoadStrategy, update: ChatUpdateInput!, where: ChatWhereUniqueInput!): Chat!
  upsertOneChatMessage(create: ChatMessageCreateInput!, relationLoadStrategy: RelationLoadStrategy, update: ChatMessageUpdateInput!, where: ChatMessageWhereUniqueInput!): ChatMessage!
  upsertOneChatUser(create: ChatUserCreateInput!, relationLoadStrategy: RelationLoadStrategy, update: ChatUserUpdateInput!, where: ChatUserWhereUniqueInput!): ChatUser!
  upsertOneComment(create: CommentCreateInput!, relationLoadStrategy: RelationLoadStrategy, update: CommentUpdateInput!, where: CommentWhereUniqueInput!): Comment!
  upsertOneFile(create: FileCreateInput!, relationLoadStrategy: RelationLoadStrategy, update: FileUpdateInput!, where: FileWhereUniqueInput!): File!
  upsertOnePost(create: PostCreateInput!, relationLoadStrategy: RelationLoadStrategy, update: PostUpdateInput!, where: PostWhereUniqueInput!): Post!
  upsertOnePostFile(create: PostFileCreateInput!, relationLoadStrategy: RelationLoadStrategy, update: PostFileUpdateInput!, where: PostFileWhereUniqueInput!): PostFile!
  upsertOneSession(create: SessionCreateInput!, relationLoadStrategy: RelationLoadStrategy, update: SessionUpdateInput!, where: SessionWhereUniqueInput!): Session!
  upsertOneUser(create: UserCreateInput!, relationLoadStrategy: RelationLoadStrategy, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
  upsertOneUserAddress(create: UserAddressCreateInput!, relationLoadStrategy: RelationLoadStrategy, update: UserAddressUpdateInput!, where: UserAddressWhereUniqueInput!): UserAddress!
  upsertOneUserFile(create: UserFileCreateInput!, relationLoadStrategy: RelationLoadStrategy, update: UserFileUpdateInput!, where: UserFileWhereUniqueInput!): UserFile!
  upsertOneVerificationToken(create: VerificationTokenCreateInput!, relationLoadStrategy: RelationLoadStrategy, update: VerificationTokenUpdateInput!, where: VerificationTokenWhereUniqueInput!): VerificationToken!
}

input NestedDateTimeFilter {
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeFilter
  notIn: [DateTimeISO!]
}

input NestedDateTimeNullableFilter {
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeNullableFilter
  notIn: [DateTimeISO!]
}

input NestedDateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTimeISO!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTimeISO!]
}

input NestedEnumFileStorageTypeFilter {
  equals: FileStorageType
  in: [FileStorageType!]
  not: NestedEnumFileStorageTypeFilter
  notIn: [FileStorageType!]
}

input NestedEnumFileStorageTypeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumFileStorageTypeFilter
  _min: NestedEnumFileStorageTypeFilter
  equals: FileStorageType
  in: [FileStorageType!]
  not: NestedEnumFileStorageTypeWithAggregatesFilter
  notIn: [FileStorageType!]
}

input NestedEnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input NestedEnumRoleWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumRoleFilter
  _min: NestedEnumRoleFilter
  equals: Role
  in: [Role!]
  not: NestedEnumRoleWithAggregatesFilter
  notIn: [Role!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableDateTimeFieldUpdateOperationsInput {
  set: DateTimeISO
}

input NullableIntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

enum NullsOrder {
  first
  last
}

type Post {
  Comment(cursor: CommentWhereUniqueInput, distinct: [CommentScalarFieldEnum!], orderBy: [CommentOrderByWithRelationInput!], skip: Int, take: Int, where: CommentWhereInput): [Comment!]!
  _count: PostCount
  address: Address!
  addressId: Int!
  content: String!
  createdAt: DateTimeISO!
  files(cursor: PostFileWhereUniqueInput, distinct: [PostFileScalarFieldEnum!], orderBy: [PostFileOrderByWithRelationInput!], skip: Int, take: Int, where: PostFileWhereInput): [PostFile!]!
  id: ID!
  updatedAt: DateTimeISO!
  user: User!
  userId: Int!
}

type PostAvgAggregate {
  addressId: Float
  id: Float
  userId: Float
}

input PostAvgOrderByAggregateInput {
  addressId: SortOrder
  id: SortOrder
  userId: SortOrder
}

type PostCount {
  Comment(where: CommentWhereInput): Int!
  files(where: PostFileWhereInput): Int!
}

type PostCountAggregate {
  _all: Int!
  addressId: Int!
  content: Int!
  createdAt: Int!
  id: Int!
  updatedAt: Int!
  userId: Int!
}

input PostCountOrderByAggregateInput {
  addressId: SortOrder
  content: SortOrder
  createdAt: SortOrder
  id: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input PostCreateInput {
  Comment: CommentCreateNestedManyWithoutPostInput
  address: AddressCreateNestedOneWithoutPostInput!
  content: String!
  createdAt: DateTimeISO
  files: PostFileCreateNestedManyWithoutPostInput
  updatedAt: DateTimeISO
  user: UserCreateNestedOneWithoutPostInput!
}

input PostCreateManyAddressInput {
  content: String!
  createdAt: DateTimeISO
  id: Int
  updatedAt: DateTimeISO
  userId: Int!
}

input PostCreateManyAddressInputEnvelope {
  data: [PostCreateManyAddressInput!]!
  skipDuplicates: Boolean
}

input PostCreateManyInput {
  addressId: Int!
  content: String!
  createdAt: DateTimeISO
  id: Int
  updatedAt: DateTimeISO
  userId: Int!
}

input PostCreateManyUserInput {
  addressId: Int!
  content: String!
  createdAt: DateTimeISO
  id: Int
  updatedAt: DateTimeISO
}

input PostCreateManyUserInputEnvelope {
  data: [PostCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input PostCreateNestedManyWithoutUserInput {
  connect: [PostWhereUniqueInput!]
  connectOrCreate: [PostCreateOrConnectWithoutUserInput!]
  create: [PostCreateWithoutUserInput!]
  createMany: PostCreateManyUserInputEnvelope
}

input PostCreateNestedOneWithoutCommentInput {
  connect: PostWhereUniqueInput
  connectOrCreate: PostCreateOrConnectWithoutCommentInput
  create: PostCreateWithoutCommentInput
}

input PostCreateNestedOneWithoutFilesInput {
  connect: PostWhereUniqueInput
  connectOrCreate: PostCreateOrConnectWithoutFilesInput
  create: PostCreateWithoutFilesInput
}

input PostCreateOrConnectWithoutAddressInput {
  create: PostCreateWithoutAddressInput!
  where: PostWhereUniqueInput!
}

input PostCreateOrConnectWithoutCommentInput {
  create: PostCreateWithoutCommentInput!
  where: PostWhereUniqueInput!
}

input PostCreateOrConnectWithoutFilesInput {
  create: PostCreateWithoutFilesInput!
  where: PostWhereUniqueInput!
}

input PostCreateOrConnectWithoutUserInput {
  create: PostCreateWithoutUserInput!
  where: PostWhereUniqueInput!
}

input PostCreateWithoutAddressInput {
  Comment: CommentCreateNestedManyWithoutPostInput
  content: String!
  createdAt: DateTimeISO
  files: PostFileCreateNestedManyWithoutPostInput
  updatedAt: DateTimeISO
  user: UserCreateNestedOneWithoutPostInput!
}

input PostCreateWithoutCommentInput {
  address: AddressCreateNestedOneWithoutPostInput!
  content: String!
  createdAt: DateTimeISO
  files: PostFileCreateNestedManyWithoutPostInput
  updatedAt: DateTimeISO
  user: UserCreateNestedOneWithoutPostInput!
}

input PostCreateWithoutFilesInput {
  Comment: CommentCreateNestedManyWithoutPostInput
  address: AddressCreateNestedOneWithoutPostInput!
  content: String!
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  user: UserCreateNestedOneWithoutPostInput!
}

input PostCreateWithoutUserInput {
  Comment: CommentCreateNestedManyWithoutPostInput
  address: AddressCreateNestedOneWithoutPostInput!
  content: String!
  createdAt: DateTimeISO
  files: PostFileCreateNestedManyWithoutPostInput
  updatedAt: DateTimeISO
}

type PostFile {
  createdAt: DateTimeISO!
  file: File!
  fileId: Int!
  id: ID!
  post: Post!
  postId: Int!
  updatedAt: DateTimeISO!
}

type PostFileAvgAggregate {
  fileId: Float
  id: Float
  postId: Float
}

input PostFileAvgOrderByAggregateInput {
  fileId: SortOrder
  id: SortOrder
  postId: SortOrder
}

type PostFileCountAggregate {
  _all: Int!
  createdAt: Int!
  fileId: Int!
  id: Int!
  postId: Int!
  updatedAt: Int!
}

input PostFileCountOrderByAggregateInput {
  createdAt: SortOrder
  fileId: SortOrder
  id: SortOrder
  postId: SortOrder
  updatedAt: SortOrder
}

input PostFileCreateInput {
  createdAt: DateTimeISO
  file: FileCreateNestedOneWithoutPostsInput!
  post: PostCreateNestedOneWithoutFilesInput!
  updatedAt: DateTimeISO
}

input PostFileCreateManyFileInput {
  createdAt: DateTimeISO
  id: Int
  postId: Int!
  updatedAt: DateTimeISO
}

input PostFileCreateManyFileInputEnvelope {
  data: [PostFileCreateManyFileInput!]!
  skipDuplicates: Boolean
}

input PostFileCreateManyInput {
  createdAt: DateTimeISO
  fileId: Int!
  id: Int
  postId: Int!
  updatedAt: DateTimeISO
}

input PostFileCreateManyPostInput {
  createdAt: DateTimeISO
  fileId: Int!
  id: Int
  updatedAt: DateTimeISO
}

input PostFileCreateManyPostInputEnvelope {
  data: [PostFileCreateManyPostInput!]!
  skipDuplicates: Boolean
}

input PostFileCreateNestedManyWithoutFileInput {
  connect: [PostFileWhereUniqueInput!]
  connectOrCreate: [PostFileCreateOrConnectWithoutFileInput!]
  create: [PostFileCreateWithoutFileInput!]
  createMany: PostFileCreateManyFileInputEnvelope
}

input PostFileCreateNestedManyWithoutPostInput {
  connect: [PostFileWhereUniqueInput!]
  connectOrCreate: [PostFileCreateOrConnectWithoutPostInput!]
  create: [PostFileCreateWithoutPostInput!]
  createMany: PostFileCreateManyPostInputEnvelope
}

input PostFileCreateOrConnectWithoutFileInput {
  create: PostFileCreateWithoutFileInput!
  where: PostFileWhereUniqueInput!
}

input PostFileCreateOrConnectWithoutPostInput {
  create: PostFileCreateWithoutPostInput!
  where: PostFileWhereUniqueInput!
}

input PostFileCreateWithoutFileInput {
  createdAt: DateTimeISO
  post: PostCreateNestedOneWithoutFilesInput!
  updatedAt: DateTimeISO
}

input PostFileCreateWithoutPostInput {
  createdAt: DateTimeISO
  file: FileCreateNestedOneWithoutPostsInput!
  updatedAt: DateTimeISO
}

type PostFileGroupBy {
  _avg: PostFileAvgAggregate
  _count: PostFileCountAggregate
  _max: PostFileMaxAggregate
  _min: PostFileMinAggregate
  _sum: PostFileSumAggregate
  createdAt: DateTimeISO!
  fileId: Int!
  id: Int!
  postId: Int!
  updatedAt: DateTimeISO!
}

input PostFileListRelationFilter {
  every: PostFileWhereInput
  none: PostFileWhereInput
  some: PostFileWhereInput
}

type PostFileMaxAggregate {
  createdAt: DateTimeISO
  fileId: Int
  id: Int
  postId: Int
  updatedAt: DateTimeISO
}

input PostFileMaxOrderByAggregateInput {
  createdAt: SortOrder
  fileId: SortOrder
  id: SortOrder
  postId: SortOrder
  updatedAt: SortOrder
}

type PostFileMinAggregate {
  createdAt: DateTimeISO
  fileId: Int
  id: Int
  postId: Int
  updatedAt: DateTimeISO
}

input PostFileMinOrderByAggregateInput {
  createdAt: SortOrder
  fileId: SortOrder
  id: SortOrder
  postId: SortOrder
  updatedAt: SortOrder
}

input PostFileOrderByRelationAggregateInput {
  _count: SortOrder
}

input PostFileOrderByWithAggregationInput {
  _avg: PostFileAvgOrderByAggregateInput
  _count: PostFileCountOrderByAggregateInput
  _max: PostFileMaxOrderByAggregateInput
  _min: PostFileMinOrderByAggregateInput
  _sum: PostFileSumOrderByAggregateInput
  createdAt: SortOrder
  fileId: SortOrder
  id: SortOrder
  postId: SortOrder
  updatedAt: SortOrder
}

input PostFileOrderByWithRelationInput {
  createdAt: SortOrder
  file: FileOrderByWithRelationInput
  fileId: SortOrder
  id: SortOrder
  post: PostOrderByWithRelationInput
  postId: SortOrder
  updatedAt: SortOrder
}

enum PostFileScalarFieldEnum {
  createdAt
  fileId
  id
  postId
  updatedAt
}

input PostFileScalarWhereInput {
  AND: [PostFileScalarWhereInput!]
  NOT: [PostFileScalarWhereInput!]
  OR: [PostFileScalarWhereInput!]
  createdAt: DateTimeFilter
  fileId: IntFilter
  id: IntFilter
  postId: IntFilter
  updatedAt: DateTimeFilter
}

input PostFileScalarWhereWithAggregatesInput {
  AND: [PostFileScalarWhereWithAggregatesInput!]
  NOT: [PostFileScalarWhereWithAggregatesInput!]
  OR: [PostFileScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  fileId: IntWithAggregatesFilter
  id: IntWithAggregatesFilter
  postId: IntWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type PostFileSumAggregate {
  fileId: Int
  id: Int
  postId: Int
}

input PostFileSumOrderByAggregateInput {
  fileId: SortOrder
  id: SortOrder
  postId: SortOrder
}

input PostFileUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  file: FileUpdateOneRequiredWithoutPostsNestedInput
  post: PostUpdateOneRequiredWithoutFilesNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PostFileUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PostFileUpdateManyWithWhereWithoutFileInput {
  data: PostFileUpdateManyMutationInput!
  where: PostFileScalarWhereInput!
}

input PostFileUpdateManyWithWhereWithoutPostInput {
  data: PostFileUpdateManyMutationInput!
  where: PostFileScalarWhereInput!
}

input PostFileUpdateManyWithoutFileNestedInput {
  connect: [PostFileWhereUniqueInput!]
  connectOrCreate: [PostFileCreateOrConnectWithoutFileInput!]
  create: [PostFileCreateWithoutFileInput!]
  createMany: PostFileCreateManyFileInputEnvelope
  delete: [PostFileWhereUniqueInput!]
  deleteMany: [PostFileScalarWhereInput!]
  disconnect: [PostFileWhereUniqueInput!]
  set: [PostFileWhereUniqueInput!]
  update: [PostFileUpdateWithWhereUniqueWithoutFileInput!]
  updateMany: [PostFileUpdateManyWithWhereWithoutFileInput!]
  upsert: [PostFileUpsertWithWhereUniqueWithoutFileInput!]
}

input PostFileUpdateManyWithoutPostNestedInput {
  connect: [PostFileWhereUniqueInput!]
  connectOrCreate: [PostFileCreateOrConnectWithoutPostInput!]
  create: [PostFileCreateWithoutPostInput!]
  createMany: PostFileCreateManyPostInputEnvelope
  delete: [PostFileWhereUniqueInput!]
  deleteMany: [PostFileScalarWhereInput!]
  disconnect: [PostFileWhereUniqueInput!]
  set: [PostFileWhereUniqueInput!]
  update: [PostFileUpdateWithWhereUniqueWithoutPostInput!]
  updateMany: [PostFileUpdateManyWithWhereWithoutPostInput!]
  upsert: [PostFileUpsertWithWhereUniqueWithoutPostInput!]
}

input PostFileUpdateWithWhereUniqueWithoutFileInput {
  data: PostFileUpdateWithoutFileInput!
  where: PostFileWhereUniqueInput!
}

input PostFileUpdateWithWhereUniqueWithoutPostInput {
  data: PostFileUpdateWithoutPostInput!
  where: PostFileWhereUniqueInput!
}

input PostFileUpdateWithoutFileInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  post: PostUpdateOneRequiredWithoutFilesNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PostFileUpdateWithoutPostInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  file: FileUpdateOneRequiredWithoutPostsNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PostFileUpsertWithWhereUniqueWithoutFileInput {
  create: PostFileCreateWithoutFileInput!
  update: PostFileUpdateWithoutFileInput!
  where: PostFileWhereUniqueInput!
}

input PostFileUpsertWithWhereUniqueWithoutPostInput {
  create: PostFileCreateWithoutPostInput!
  update: PostFileUpdateWithoutPostInput!
  where: PostFileWhereUniqueInput!
}

input PostFileWhereInput {
  AND: [PostFileWhereInput!]
  NOT: [PostFileWhereInput!]
  OR: [PostFileWhereInput!]
  createdAt: DateTimeFilter
  file: FileRelationFilter
  fileId: IntFilter
  id: IntFilter
  post: PostRelationFilter
  postId: IntFilter
  updatedAt: DateTimeFilter
}

input PostFileWhereUniqueInput {
  AND: [PostFileWhereInput!]
  NOT: [PostFileWhereInput!]
  OR: [PostFileWhereInput!]
  createdAt: DateTimeFilter
  file: FileRelationFilter
  fileId: IntFilter
  id: Int
  post: PostRelationFilter
  postId: IntFilter
  updatedAt: DateTimeFilter
}

type PostGroupBy {
  _avg: PostAvgAggregate
  _count: PostCountAggregate
  _max: PostMaxAggregate
  _min: PostMinAggregate
  _sum: PostSumAggregate
  addressId: Int!
  content: String!
  createdAt: DateTimeISO!
  id: Int!
  updatedAt: DateTimeISO!
  userId: Int!
}

input PostListRelationFilter {
  every: PostWhereInput
  none: PostWhereInput
  some: PostWhereInput
}

type PostMaxAggregate {
  addressId: Int
  content: String
  createdAt: DateTimeISO
  id: Int
  updatedAt: DateTimeISO
  userId: Int
}

input PostMaxOrderByAggregateInput {
  addressId: SortOrder
  content: SortOrder
  createdAt: SortOrder
  id: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

type PostMinAggregate {
  addressId: Int
  content: String
  createdAt: DateTimeISO
  id: Int
  updatedAt: DateTimeISO
  userId: Int
}

input PostMinOrderByAggregateInput {
  addressId: SortOrder
  content: SortOrder
  createdAt: SortOrder
  id: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input PostOrderByRelationAggregateInput {
  _count: SortOrder
}

input PostOrderByWithAggregationInput {
  _avg: PostAvgOrderByAggregateInput
  _count: PostCountOrderByAggregateInput
  _max: PostMaxOrderByAggregateInput
  _min: PostMinOrderByAggregateInput
  _sum: PostSumOrderByAggregateInput
  addressId: SortOrder
  content: SortOrder
  createdAt: SortOrder
  id: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input PostOrderByWithRelationInput {
  Comment: CommentOrderByRelationAggregateInput
  address: AddressOrderByWithRelationInput
  addressId: SortOrder
  content: SortOrder
  createdAt: SortOrder
  files: PostFileOrderByRelationAggregateInput
  id: SortOrder
  updatedAt: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

input PostRelationFilter {
  is: PostWhereInput
  isNot: PostWhereInput
}

enum PostScalarFieldEnum {
  addressId
  content
  createdAt
  id
  updatedAt
  userId
}

input PostScalarWhereInput {
  AND: [PostScalarWhereInput!]
  NOT: [PostScalarWhereInput!]
  OR: [PostScalarWhereInput!]
  addressId: IntFilter
  content: StringFilter
  createdAt: DateTimeFilter
  id: IntFilter
  updatedAt: DateTimeFilter
  userId: IntFilter
}

input PostScalarWhereWithAggregatesInput {
  AND: [PostScalarWhereWithAggregatesInput!]
  NOT: [PostScalarWhereWithAggregatesInput!]
  OR: [PostScalarWhereWithAggregatesInput!]
  addressId: IntWithAggregatesFilter
  content: StringWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  userId: IntWithAggregatesFilter
}

type PostSumAggregate {
  addressId: Int
  id: Int
  userId: Int
}

input PostSumOrderByAggregateInput {
  addressId: SortOrder
  id: SortOrder
  userId: SortOrder
}

input PostUpdateInput {
  Comment: CommentUpdateManyWithoutPostNestedInput
  address: AddressUpdateOneRequiredWithoutPostNestedInput
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  files: PostFileUpdateManyWithoutPostNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutPostNestedInput
}

input PostUpdateManyMutationInput {
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PostUpdateManyWithWhereWithoutAddressInput {
  data: PostUpdateManyMutationInput!
  where: PostScalarWhereInput!
}

input PostUpdateManyWithWhereWithoutUserInput {
  data: PostUpdateManyMutationInput!
  where: PostScalarWhereInput!
}

input PostUpdateManyWithoutAddressNestedInput {
  connect: [PostWhereUniqueInput!]
  connectOrCreate: [PostCreateOrConnectWithoutAddressInput!]
  create: [PostCreateWithoutAddressInput!]
  createMany: PostCreateManyAddressInputEnvelope
  delete: [PostWhereUniqueInput!]
  deleteMany: [PostScalarWhereInput!]
  disconnect: [PostWhereUniqueInput!]
  set: [PostWhereUniqueInput!]
  update: [PostUpdateWithWhereUniqueWithoutAddressInput!]
  updateMany: [PostUpdateManyWithWhereWithoutAddressInput!]
  upsert: [PostUpsertWithWhereUniqueWithoutAddressInput!]
}

input PostUpdateManyWithoutUserNestedInput {
  connect: [PostWhereUniqueInput!]
  connectOrCreate: [PostCreateOrConnectWithoutUserInput!]
  create: [PostCreateWithoutUserInput!]
  createMany: PostCreateManyUserInputEnvelope
  delete: [PostWhereUniqueInput!]
  deleteMany: [PostScalarWhereInput!]
  disconnect: [PostWhereUniqueInput!]
  set: [PostWhereUniqueInput!]
  update: [PostUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [PostUpdateManyWithWhereWithoutUserInput!]
  upsert: [PostUpsertWithWhereUniqueWithoutUserInput!]
}

input PostUpdateOneRequiredWithoutCommentNestedInput {
  connect: PostWhereUniqueInput
  connectOrCreate: PostCreateOrConnectWithoutCommentInput
  create: PostCreateWithoutCommentInput
  update: PostUpdateToOneWithWhereWithoutCommentInput
  upsert: PostUpsertWithoutCommentInput
}

input PostUpdateOneRequiredWithoutFilesNestedInput {
  connect: PostWhereUniqueInput
  connectOrCreate: PostCreateOrConnectWithoutFilesInput
  create: PostCreateWithoutFilesInput
  update: PostUpdateToOneWithWhereWithoutFilesInput
  upsert: PostUpsertWithoutFilesInput
}

input PostUpdateToOneWithWhereWithoutCommentInput {
  data: PostUpdateWithoutCommentInput!
  where: PostWhereInput
}

input PostUpdateToOneWithWhereWithoutFilesInput {
  data: PostUpdateWithoutFilesInput!
  where: PostWhereInput
}

input PostUpdateWithWhereUniqueWithoutAddressInput {
  data: PostUpdateWithoutAddressInput!
  where: PostWhereUniqueInput!
}

input PostUpdateWithWhereUniqueWithoutUserInput {
  data: PostUpdateWithoutUserInput!
  where: PostWhereUniqueInput!
}

input PostUpdateWithoutAddressInput {
  Comment: CommentUpdateManyWithoutPostNestedInput
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  files: PostFileUpdateManyWithoutPostNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutPostNestedInput
}

input PostUpdateWithoutCommentInput {
  address: AddressUpdateOneRequiredWithoutPostNestedInput
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  files: PostFileUpdateManyWithoutPostNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutPostNestedInput
}

input PostUpdateWithoutFilesInput {
  Comment: CommentUpdateManyWithoutPostNestedInput
  address: AddressUpdateOneRequiredWithoutPostNestedInput
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutPostNestedInput
}

input PostUpdateWithoutUserInput {
  Comment: CommentUpdateManyWithoutPostNestedInput
  address: AddressUpdateOneRequiredWithoutPostNestedInput
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  files: PostFileUpdateManyWithoutPostNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PostUpsertWithWhereUniqueWithoutAddressInput {
  create: PostCreateWithoutAddressInput!
  update: PostUpdateWithoutAddressInput!
  where: PostWhereUniqueInput!
}

input PostUpsertWithWhereUniqueWithoutUserInput {
  create: PostCreateWithoutUserInput!
  update: PostUpdateWithoutUserInput!
  where: PostWhereUniqueInput!
}

input PostUpsertWithoutCommentInput {
  create: PostCreateWithoutCommentInput!
  update: PostUpdateWithoutCommentInput!
  where: PostWhereInput
}

input PostUpsertWithoutFilesInput {
  create: PostCreateWithoutFilesInput!
  update: PostUpdateWithoutFilesInput!
  where: PostWhereInput
}

input PostWhereInput {
  AND: [PostWhereInput!]
  Comment: CommentListRelationFilter
  NOT: [PostWhereInput!]
  OR: [PostWhereInput!]
  address: AddressRelationFilter
  addressId: IntFilter
  content: StringFilter
  createdAt: DateTimeFilter
  files: PostFileListRelationFilter
  id: IntFilter
  updatedAt: DateTimeFilter
  user: UserRelationFilter
  userId: IntFilter
}

input PostWhereUniqueInput {
  AND: [PostWhereInput!]
  Comment: CommentListRelationFilter
  NOT: [PostWhereInput!]
  OR: [PostWhereInput!]
  address: AddressRelationFilter
  addressId: IntFilter
  content: StringFilter
  createdAt: DateTimeFilter
  files: PostFileListRelationFilter
  id: Int
  updatedAt: DateTimeFilter
  user: UserRelationFilter
  userId: IntFilter
}

type Query {
  account(relationLoadStrategy: RelationLoadStrategy, where: AccountWhereUniqueInput!): Account
  accounts(cursor: AccountWhereUniqueInput, distinct: [AccountScalarFieldEnum!], orderBy: [AccountOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: AccountWhereInput): [Account!]!
  address(relationLoadStrategy: RelationLoadStrategy, where: AddressWhereUniqueInput!): Address
  addresses(cursor: AddressWhereUniqueInput, distinct: [AddressScalarFieldEnum!], orderBy: [AddressOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: AddressWhereInput): [Address!]!
  aggregateAccount(cursor: AccountWhereUniqueInput, orderBy: [AccountOrderByWithRelationInput!], skip: Int, take: Int, where: AccountWhereInput): AggregateAccount!
  aggregateAddress(cursor: AddressWhereUniqueInput, orderBy: [AddressOrderByWithRelationInput!], skip: Int, take: Int, where: AddressWhereInput): AggregateAddress!
  aggregateChat(cursor: ChatWhereUniqueInput, orderBy: [ChatOrderByWithRelationInput!], skip: Int, take: Int, where: ChatWhereInput): AggregateChat!
  aggregateChatMessage(cursor: ChatMessageWhereUniqueInput, orderBy: [ChatMessageOrderByWithRelationInput!], skip: Int, take: Int, where: ChatMessageWhereInput): AggregateChatMessage!
  aggregateChatUser(cursor: ChatUserWhereUniqueInput, orderBy: [ChatUserOrderByWithRelationInput!], skip: Int, take: Int, where: ChatUserWhereInput): AggregateChatUser!
  aggregateComment(cursor: CommentWhereUniqueInput, orderBy: [CommentOrderByWithRelationInput!], skip: Int, take: Int, where: CommentWhereInput): AggregateComment!
  aggregateFile(cursor: FileWhereUniqueInput, orderBy: [FileOrderByWithRelationInput!], skip: Int, take: Int, where: FileWhereInput): AggregateFile!
  aggregatePost(cursor: PostWhereUniqueInput, orderBy: [PostOrderByWithRelationInput!], skip: Int, take: Int, where: PostWhereInput): AggregatePost!
  aggregatePostFile(cursor: PostFileWhereUniqueInput, orderBy: [PostFileOrderByWithRelationInput!], skip: Int, take: Int, where: PostFileWhereInput): AggregatePostFile!
  aggregateSession(cursor: SessionWhereUniqueInput, orderBy: [SessionOrderByWithRelationInput!], skip: Int, take: Int, where: SessionWhereInput): AggregateSession!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  aggregateUserAddress(cursor: UserAddressWhereUniqueInput, orderBy: [UserAddressOrderByWithRelationInput!], skip: Int, take: Int, where: UserAddressWhereInput): AggregateUserAddress!
  aggregateUserFile(cursor: UserFileWhereUniqueInput, orderBy: [UserFileOrderByWithRelationInput!], skip: Int, take: Int, where: UserFileWhereInput): AggregateUserFile!
  aggregateVerificationToken(cursor: VerificationTokenWhereUniqueInput, orderBy: [VerificationTokenOrderByWithRelationInput!], skip: Int, take: Int, where: VerificationTokenWhereInput): AggregateVerificationToken!
  chat(relationLoadStrategy: RelationLoadStrategy, where: ChatWhereUniqueInput!): Chat
  chatMessage(relationLoadStrategy: RelationLoadStrategy, where: ChatMessageWhereUniqueInput!): ChatMessage
  chatMessages(cursor: ChatMessageWhereUniqueInput, distinct: [ChatMessageScalarFieldEnum!], orderBy: [ChatMessageOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: ChatMessageWhereInput): [ChatMessage!]!
  chatUser(relationLoadStrategy: RelationLoadStrategy, where: ChatUserWhereUniqueInput!): ChatUser
  chatUsers(cursor: ChatUserWhereUniqueInput, distinct: [ChatUserScalarFieldEnum!], orderBy: [ChatUserOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: ChatUserWhereInput): [ChatUser!]!
  chats(cursor: ChatWhereUniqueInput, distinct: [ChatScalarFieldEnum!], orderBy: [ChatOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: ChatWhereInput): [Chat!]!
  comment(relationLoadStrategy: RelationLoadStrategy, where: CommentWhereUniqueInput!): Comment
  comments(cursor: CommentWhereUniqueInput, distinct: [CommentScalarFieldEnum!], orderBy: [CommentOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: CommentWhereInput): [Comment!]!
  file(relationLoadStrategy: RelationLoadStrategy, where: FileWhereUniqueInput!): File
  files(cursor: FileWhereUniqueInput, distinct: [FileScalarFieldEnum!], orderBy: [FileOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: FileWhereInput): [File!]!
  findFirstAccount(cursor: AccountWhereUniqueInput, distinct: [AccountScalarFieldEnum!], orderBy: [AccountOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: AccountWhereInput): Account
  findFirstAccountOrThrow(cursor: AccountWhereUniqueInput, distinct: [AccountScalarFieldEnum!], orderBy: [AccountOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: AccountWhereInput): Account
  findFirstAddress(cursor: AddressWhereUniqueInput, distinct: [AddressScalarFieldEnum!], orderBy: [AddressOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: AddressWhereInput): Address
  findFirstAddressOrThrow(cursor: AddressWhereUniqueInput, distinct: [AddressScalarFieldEnum!], orderBy: [AddressOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: AddressWhereInput): Address
  findFirstChat(cursor: ChatWhereUniqueInput, distinct: [ChatScalarFieldEnum!], orderBy: [ChatOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: ChatWhereInput): Chat
  findFirstChatMessage(cursor: ChatMessageWhereUniqueInput, distinct: [ChatMessageScalarFieldEnum!], orderBy: [ChatMessageOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: ChatMessageWhereInput): ChatMessage
  findFirstChatMessageOrThrow(cursor: ChatMessageWhereUniqueInput, distinct: [ChatMessageScalarFieldEnum!], orderBy: [ChatMessageOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: ChatMessageWhereInput): ChatMessage
  findFirstChatOrThrow(cursor: ChatWhereUniqueInput, distinct: [ChatScalarFieldEnum!], orderBy: [ChatOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: ChatWhereInput): Chat
  findFirstChatUser(cursor: ChatUserWhereUniqueInput, distinct: [ChatUserScalarFieldEnum!], orderBy: [ChatUserOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: ChatUserWhereInput): ChatUser
  findFirstChatUserOrThrow(cursor: ChatUserWhereUniqueInput, distinct: [ChatUserScalarFieldEnum!], orderBy: [ChatUserOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: ChatUserWhereInput): ChatUser
  findFirstComment(cursor: CommentWhereUniqueInput, distinct: [CommentScalarFieldEnum!], orderBy: [CommentOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: CommentWhereInput): Comment
  findFirstCommentOrThrow(cursor: CommentWhereUniqueInput, distinct: [CommentScalarFieldEnum!], orderBy: [CommentOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: CommentWhereInput): Comment
  findFirstFile(cursor: FileWhereUniqueInput, distinct: [FileScalarFieldEnum!], orderBy: [FileOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: FileWhereInput): File
  findFirstFileOrThrow(cursor: FileWhereUniqueInput, distinct: [FileScalarFieldEnum!], orderBy: [FileOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: FileWhereInput): File
  findFirstPost(cursor: PostWhereUniqueInput, distinct: [PostScalarFieldEnum!], orderBy: [PostOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: PostWhereInput): Post
  findFirstPostFile(cursor: PostFileWhereUniqueInput, distinct: [PostFileScalarFieldEnum!], orderBy: [PostFileOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: PostFileWhereInput): PostFile
  findFirstPostFileOrThrow(cursor: PostFileWhereUniqueInput, distinct: [PostFileScalarFieldEnum!], orderBy: [PostFileOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: PostFileWhereInput): PostFile
  findFirstPostOrThrow(cursor: PostWhereUniqueInput, distinct: [PostScalarFieldEnum!], orderBy: [PostOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: PostWhereInput): Post
  findFirstSession(cursor: SessionWhereUniqueInput, distinct: [SessionScalarFieldEnum!], orderBy: [SessionOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: SessionWhereInput): Session
  findFirstSessionOrThrow(cursor: SessionWhereUniqueInput, distinct: [SessionScalarFieldEnum!], orderBy: [SessionOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: SessionWhereInput): Session
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: UserWhereInput): User
  findFirstUserAddress(cursor: UserAddressWhereUniqueInput, distinct: [UserAddressScalarFieldEnum!], orderBy: [UserAddressOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: UserAddressWhereInput): UserAddress
  findFirstUserAddressOrThrow(cursor: UserAddressWhereUniqueInput, distinct: [UserAddressScalarFieldEnum!], orderBy: [UserAddressOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: UserAddressWhereInput): UserAddress
  findFirstUserFile(cursor: UserFileWhereUniqueInput, distinct: [UserFileScalarFieldEnum!], orderBy: [UserFileOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: UserFileWhereInput): UserFile
  findFirstUserFileOrThrow(cursor: UserFileWhereUniqueInput, distinct: [UserFileScalarFieldEnum!], orderBy: [UserFileOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: UserFileWhereInput): UserFile
  findFirstUserOrThrow(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: UserWhereInput): User
  findFirstVerificationToken(cursor: VerificationTokenWhereUniqueInput, distinct: [VerificationTokenScalarFieldEnum!], orderBy: [VerificationTokenOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: VerificationTokenWhereInput): VerificationToken
  findFirstVerificationTokenOrThrow(cursor: VerificationTokenWhereUniqueInput, distinct: [VerificationTokenScalarFieldEnum!], orderBy: [VerificationTokenOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: VerificationTokenWhereInput): VerificationToken
  getAccount(relationLoadStrategy: RelationLoadStrategy, where: AccountWhereUniqueInput!): Account
  getAddress(relationLoadStrategy: RelationLoadStrategy, where: AddressWhereUniqueInput!): Address
  getChat(relationLoadStrategy: RelationLoadStrategy, where: ChatWhereUniqueInput!): Chat
  getChatMessage(relationLoadStrategy: RelationLoadStrategy, where: ChatMessageWhereUniqueInput!): ChatMessage
  getChatUser(relationLoadStrategy: RelationLoadStrategy, where: ChatUserWhereUniqueInput!): ChatUser
  getComment(relationLoadStrategy: RelationLoadStrategy, where: CommentWhereUniqueInput!): Comment
  getFile(relationLoadStrategy: RelationLoadStrategy, where: FileWhereUniqueInput!): File
  getPost(relationLoadStrategy: RelationLoadStrategy, where: PostWhereUniqueInput!): Post
  getPostFile(relationLoadStrategy: RelationLoadStrategy, where: PostFileWhereUniqueInput!): PostFile
  getSession(relationLoadStrategy: RelationLoadStrategy, where: SessionWhereUniqueInput!): Session
  getUser(relationLoadStrategy: RelationLoadStrategy, where: UserWhereUniqueInput!): User
  getUserAddress(relationLoadStrategy: RelationLoadStrategy, where: UserAddressWhereUniqueInput!): UserAddress
  getUserFile(relationLoadStrategy: RelationLoadStrategy, where: UserFileWhereUniqueInput!): UserFile
  getVerificationToken(relationLoadStrategy: RelationLoadStrategy, where: VerificationTokenWhereUniqueInput!): VerificationToken
  groupByAccount(by: [AccountScalarFieldEnum!]!, having: AccountScalarWhereWithAggregatesInput, orderBy: [AccountOrderByWithAggregationInput!], skip: Int, take: Int, where: AccountWhereInput): [AccountGroupBy!]!
  groupByAddress(by: [AddressScalarFieldEnum!]!, having: AddressScalarWhereWithAggregatesInput, orderBy: [AddressOrderByWithAggregationInput!], skip: Int, take: Int, where: AddressWhereInput): [AddressGroupBy!]!
  groupByChat(by: [ChatScalarFieldEnum!]!, having: ChatScalarWhereWithAggregatesInput, orderBy: [ChatOrderByWithAggregationInput!], skip: Int, take: Int, where: ChatWhereInput): [ChatGroupBy!]!
  groupByChatMessage(by: [ChatMessageScalarFieldEnum!]!, having: ChatMessageScalarWhereWithAggregatesInput, orderBy: [ChatMessageOrderByWithAggregationInput!], skip: Int, take: Int, where: ChatMessageWhereInput): [ChatMessageGroupBy!]!
  groupByChatUser(by: [ChatUserScalarFieldEnum!]!, having: ChatUserScalarWhereWithAggregatesInput, orderBy: [ChatUserOrderByWithAggregationInput!], skip: Int, take: Int, where: ChatUserWhereInput): [ChatUserGroupBy!]!
  groupByComment(by: [CommentScalarFieldEnum!]!, having: CommentScalarWhereWithAggregatesInput, orderBy: [CommentOrderByWithAggregationInput!], skip: Int, take: Int, where: CommentWhereInput): [CommentGroupBy!]!
  groupByFile(by: [FileScalarFieldEnum!]!, having: FileScalarWhereWithAggregatesInput, orderBy: [FileOrderByWithAggregationInput!], skip: Int, take: Int, where: FileWhereInput): [FileGroupBy!]!
  groupByPost(by: [PostScalarFieldEnum!]!, having: PostScalarWhereWithAggregatesInput, orderBy: [PostOrderByWithAggregationInput!], skip: Int, take: Int, where: PostWhereInput): [PostGroupBy!]!
  groupByPostFile(by: [PostFileScalarFieldEnum!]!, having: PostFileScalarWhereWithAggregatesInput, orderBy: [PostFileOrderByWithAggregationInput!], skip: Int, take: Int, where: PostFileWhereInput): [PostFileGroupBy!]!
  groupBySession(by: [SessionScalarFieldEnum!]!, having: SessionScalarWhereWithAggregatesInput, orderBy: [SessionOrderByWithAggregationInput!], skip: Int, take: Int, where: SessionWhereInput): [SessionGroupBy!]!
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByWithAggregationInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  groupByUserAddress(by: [UserAddressScalarFieldEnum!]!, having: UserAddressScalarWhereWithAggregatesInput, orderBy: [UserAddressOrderByWithAggregationInput!], skip: Int, take: Int, where: UserAddressWhereInput): [UserAddressGroupBy!]!
  groupByUserFile(by: [UserFileScalarFieldEnum!]!, having: UserFileScalarWhereWithAggregatesInput, orderBy: [UserFileOrderByWithAggregationInput!], skip: Int, take: Int, where: UserFileWhereInput): [UserFileGroupBy!]!
  groupByVerificationToken(by: [VerificationTokenScalarFieldEnum!]!, having: VerificationTokenScalarWhereWithAggregatesInput, orderBy: [VerificationTokenOrderByWithAggregationInput!], skip: Int, take: Int, where: VerificationTokenWhereInput): [VerificationTokenGroupBy!]!
  post(relationLoadStrategy: RelationLoadStrategy, where: PostWhereUniqueInput!): Post
  postFile(relationLoadStrategy: RelationLoadStrategy, where: PostFileWhereUniqueInput!): PostFile
  postFiles(cursor: PostFileWhereUniqueInput, distinct: [PostFileScalarFieldEnum!], orderBy: [PostFileOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: PostFileWhereInput): [PostFile!]!
  posts(cursor: PostWhereUniqueInput, distinct: [PostScalarFieldEnum!], orderBy: [PostOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: PostWhereInput): [Post!]!
  session(relationLoadStrategy: RelationLoadStrategy, where: SessionWhereUniqueInput!): Session
  sessions(cursor: SessionWhereUniqueInput, distinct: [SessionScalarFieldEnum!], orderBy: [SessionOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: SessionWhereInput): [Session!]!
  user(relationLoadStrategy: RelationLoadStrategy, where: UserWhereUniqueInput!): User
  userAddress(relationLoadStrategy: RelationLoadStrategy, where: UserAddressWhereUniqueInput!): UserAddress
  userAddresses(cursor: UserAddressWhereUniqueInput, distinct: [UserAddressScalarFieldEnum!], orderBy: [UserAddressOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: UserAddressWhereInput): [UserAddress!]!
  userFile(relationLoadStrategy: RelationLoadStrategy, where: UserFileWhereUniqueInput!): UserFile
  userFiles(cursor: UserFileWhereUniqueInput, distinct: [UserFileScalarFieldEnum!], orderBy: [UserFileOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: UserFileWhereInput): [UserFile!]!
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: UserWhereInput): [User!]!
  verificationToken(relationLoadStrategy: RelationLoadStrategy, where: VerificationTokenWhereUniqueInput!): VerificationToken
  verificationTokens(cursor: VerificationTokenWhereUniqueInput, distinct: [VerificationTokenScalarFieldEnum!], orderBy: [VerificationTokenOrderByWithRelationInput!], relationLoadStrategy: RelationLoadStrategy, skip: Int, take: Int, where: VerificationTokenWhereInput): [VerificationToken!]!
}

enum QueryMode {
  default
  insensitive
}

enum RelationLoadStrategy {
  join
  query
}

enum Role {
  READ
  WRITE
}

type Session {
  createdAt: DateTimeISO!
  expires: DateTimeISO!
  sessionToken: String!
  updatedAt: DateTimeISO!
  user: User!
  userId: Int!
}

type SessionAvgAggregate {
  userId: Float
}

input SessionAvgOrderByAggregateInput {
  userId: SortOrder
}

type SessionCountAggregate {
  _all: Int!
  createdAt: Int!
  expires: Int!
  sessionToken: Int!
  updatedAt: Int!
  userId: Int!
}

input SessionCountOrderByAggregateInput {
  createdAt: SortOrder
  expires: SortOrder
  sessionToken: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input SessionCreateInput {
  createdAt: DateTimeISO
  expires: DateTimeISO!
  sessionToken: String!
  updatedAt: DateTimeISO
  user: UserCreateNestedOneWithoutSessionInput!
}

input SessionCreateManyInput {
  createdAt: DateTimeISO
  expires: DateTimeISO!
  sessionToken: String!
  updatedAt: DateTimeISO
  userId: Int!
}

input SessionCreateManyUserInput {
  createdAt: DateTimeISO
  expires: DateTimeISO!
  sessionToken: String!
  updatedAt: DateTimeISO
}

input SessionCreateManyUserInputEnvelope {
  data: [SessionCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input SessionCreateNestedManyWithoutUserInput {
  connect: [SessionWhereUniqueInput!]
  connectOrCreate: [SessionCreateOrConnectWithoutUserInput!]
  create: [SessionCreateWithoutUserInput!]
  createMany: SessionCreateManyUserInputEnvelope
}

input SessionCreateOrConnectWithoutUserInput {
  create: SessionCreateWithoutUserInput!
  where: SessionWhereUniqueInput!
}

input SessionCreateWithoutUserInput {
  createdAt: DateTimeISO
  expires: DateTimeISO!
  sessionToken: String!
  updatedAt: DateTimeISO
}

type SessionGroupBy {
  _avg: SessionAvgAggregate
  _count: SessionCountAggregate
  _max: SessionMaxAggregate
  _min: SessionMinAggregate
  _sum: SessionSumAggregate
  createdAt: DateTimeISO!
  expires: DateTimeISO!
  sessionToken: String!
  updatedAt: DateTimeISO!
  userId: Int!
}

input SessionListRelationFilter {
  every: SessionWhereInput
  none: SessionWhereInput
  some: SessionWhereInput
}

type SessionMaxAggregate {
  createdAt: DateTimeISO
  expires: DateTimeISO
  sessionToken: String
  updatedAt: DateTimeISO
  userId: Int
}

input SessionMaxOrderByAggregateInput {
  createdAt: SortOrder
  expires: SortOrder
  sessionToken: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

type SessionMinAggregate {
  createdAt: DateTimeISO
  expires: DateTimeISO
  sessionToken: String
  updatedAt: DateTimeISO
  userId: Int
}

input SessionMinOrderByAggregateInput {
  createdAt: SortOrder
  expires: SortOrder
  sessionToken: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input SessionOrderByRelationAggregateInput {
  _count: SortOrder
}

input SessionOrderByWithAggregationInput {
  _avg: SessionAvgOrderByAggregateInput
  _count: SessionCountOrderByAggregateInput
  _max: SessionMaxOrderByAggregateInput
  _min: SessionMinOrderByAggregateInput
  _sum: SessionSumOrderByAggregateInput
  createdAt: SortOrder
  expires: SortOrder
  sessionToken: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input SessionOrderByWithRelationInput {
  createdAt: SortOrder
  expires: SortOrder
  sessionToken: SortOrder
  updatedAt: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

enum SessionScalarFieldEnum {
  createdAt
  expires
  sessionToken
  updatedAt
  userId
}

input SessionScalarWhereInput {
  AND: [SessionScalarWhereInput!]
  NOT: [SessionScalarWhereInput!]
  OR: [SessionScalarWhereInput!]
  createdAt: DateTimeFilter
  expires: DateTimeFilter
  sessionToken: StringFilter
  updatedAt: DateTimeFilter
  userId: IntFilter
}

input SessionScalarWhereWithAggregatesInput {
  AND: [SessionScalarWhereWithAggregatesInput!]
  NOT: [SessionScalarWhereWithAggregatesInput!]
  OR: [SessionScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  expires: DateTimeWithAggregatesFilter
  sessionToken: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  userId: IntWithAggregatesFilter
}

type SessionSumAggregate {
  userId: Int
}

input SessionSumOrderByAggregateInput {
  userId: SortOrder
}

input SessionUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  expires: DateTimeFieldUpdateOperationsInput
  sessionToken: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutSessionNestedInput
}

input SessionUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  expires: DateTimeFieldUpdateOperationsInput
  sessionToken: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SessionUpdateManyWithWhereWithoutUserInput {
  data: SessionUpdateManyMutationInput!
  where: SessionScalarWhereInput!
}

input SessionUpdateManyWithoutUserNestedInput {
  connect: [SessionWhereUniqueInput!]
  connectOrCreate: [SessionCreateOrConnectWithoutUserInput!]
  create: [SessionCreateWithoutUserInput!]
  createMany: SessionCreateManyUserInputEnvelope
  delete: [SessionWhereUniqueInput!]
  deleteMany: [SessionScalarWhereInput!]
  disconnect: [SessionWhereUniqueInput!]
  set: [SessionWhereUniqueInput!]
  update: [SessionUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [SessionUpdateManyWithWhereWithoutUserInput!]
  upsert: [SessionUpsertWithWhereUniqueWithoutUserInput!]
}

input SessionUpdateWithWhereUniqueWithoutUserInput {
  data: SessionUpdateWithoutUserInput!
  where: SessionWhereUniqueInput!
}

input SessionUpdateWithoutUserInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  expires: DateTimeFieldUpdateOperationsInput
  sessionToken: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SessionUpsertWithWhereUniqueWithoutUserInput {
  create: SessionCreateWithoutUserInput!
  update: SessionUpdateWithoutUserInput!
  where: SessionWhereUniqueInput!
}

input SessionWhereInput {
  AND: [SessionWhereInput!]
  NOT: [SessionWhereInput!]
  OR: [SessionWhereInput!]
  createdAt: DateTimeFilter
  expires: DateTimeFilter
  sessionToken: StringFilter
  updatedAt: DateTimeFilter
  user: UserRelationFilter
  userId: IntFilter
}

input SessionWhereUniqueInput {
  AND: [SessionWhereInput!]
  NOT: [SessionWhereInput!]
  OR: [SessionWhereInput!]
  createdAt: DateTimeFilter
  expires: DateTimeFilter
  sessionToken: String
  updatedAt: DateTimeFilter
  user: UserRelationFilter
  userId: IntFilter
}

enum SortOrder {
  asc
  desc
}

input SortOrderInput {
  nulls: NullsOrder
  sort: SortOrder!
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Subscription {
  toChat(chatId: Float!): ChatMessage!
}

type User {
  Account(cursor: AccountWhereUniqueInput, distinct: [AccountScalarFieldEnum!], orderBy: [AccountOrderByWithRelationInput!], skip: Int, take: Int, where: AccountWhereInput): [Account!]!
  ChatUser(cursor: ChatUserWhereUniqueInput, distinct: [ChatUserScalarFieldEnum!], orderBy: [ChatUserOrderByWithRelationInput!], skip: Int, take: Int, where: ChatUserWhereInput): [ChatUser!]!
  Comment(cursor: CommentWhereUniqueInput, distinct: [CommentScalarFieldEnum!], orderBy: [CommentOrderByWithRelationInput!], skip: Int, take: Int, where: CommentWhereInput): [Comment!]!
  Post(cursor: PostWhereUniqueInput, distinct: [PostScalarFieldEnum!], orderBy: [PostOrderByWithRelationInput!], skip: Int, take: Int, where: PostWhereInput): [Post!]!
  Session(cursor: SessionWhereUniqueInput, distinct: [SessionScalarFieldEnum!], orderBy: [SessionOrderByWithRelationInput!], skip: Int, take: Int, where: SessionWhereInput): [Session!]!
  _count: UserCount
  addresses(cursor: UserAddressWhereUniqueInput, distinct: [UserAddressScalarFieldEnum!], orderBy: [UserAddressOrderByWithRelationInput!], skip: Int, take: Int, where: UserAddressWhereInput): [UserAddress!]!
  babyBirth: DateTimeISO
  content: String
  createdAt: DateTimeISO!
  email: String!
  emailVerified: DateTimeISO
  files(cursor: UserFileWhereUniqueInput, distinct: [UserFileScalarFieldEnum!], orderBy: [UserFileOrderByWithRelationInput!], skip: Int, take: Int, where: UserFileWhereInput): [UserFile!]!
  id: ID!
  image: String
  name: String
  role: Role!
  updatedAt: DateTimeISO!
  username: String
}

type UserAddress {
  address: Address!
  addressId: Int!
  createdAt: DateTimeISO!
  id: ID!
  updatedAt: DateTimeISO!
  user: User!
  userId: Int!
}

type UserAddressAvgAggregate {
  addressId: Float
  id: Float
  userId: Float
}

input UserAddressAvgOrderByAggregateInput {
  addressId: SortOrder
  id: SortOrder
  userId: SortOrder
}

type UserAddressCountAggregate {
  _all: Int!
  addressId: Int!
  createdAt: Int!
  id: Int!
  updatedAt: Int!
  userId: Int!
}

input UserAddressCountOrderByAggregateInput {
  addressId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input UserAddressCreateInput {
  address: AddressCreateNestedOneWithoutUsersInput!
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  user: UserCreateNestedOneWithoutAddressesInput!
}

input UserAddressCreateManyAddressInput {
  createdAt: DateTimeISO
  id: Int
  updatedAt: DateTimeISO
  userId: Int!
}

input UserAddressCreateManyAddressInputEnvelope {
  data: [UserAddressCreateManyAddressInput!]!
  skipDuplicates: Boolean
}

input UserAddressCreateManyInput {
  addressId: Int!
  createdAt: DateTimeISO
  id: Int
  updatedAt: DateTimeISO
  userId: Int!
}

input UserAddressCreateManyUserInput {
  addressId: Int!
  createdAt: DateTimeISO
  id: Int
  updatedAt: DateTimeISO
}

input UserAddressCreateManyUserInputEnvelope {
  data: [UserAddressCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input UserAddressCreateNestedManyWithoutUserInput {
  connect: [UserAddressWhereUniqueInput!]
  connectOrCreate: [UserAddressCreateOrConnectWithoutUserInput!]
  create: [UserAddressCreateWithoutUserInput!]
  createMany: UserAddressCreateManyUserInputEnvelope
}

input UserAddressCreateOrConnectWithoutAddressInput {
  create: UserAddressCreateWithoutAddressInput!
  where: UserAddressWhereUniqueInput!
}

input UserAddressCreateOrConnectWithoutUserInput {
  create: UserAddressCreateWithoutUserInput!
  where: UserAddressWhereUniqueInput!
}

input UserAddressCreateWithoutAddressInput {
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  user: UserCreateNestedOneWithoutAddressesInput!
}

input UserAddressCreateWithoutUserInput {
  address: AddressCreateNestedOneWithoutUsersInput!
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
}

type UserAddressGroupBy {
  _avg: UserAddressAvgAggregate
  _count: UserAddressCountAggregate
  _max: UserAddressMaxAggregate
  _min: UserAddressMinAggregate
  _sum: UserAddressSumAggregate
  addressId: Int!
  createdAt: DateTimeISO!
  id: Int!
  updatedAt: DateTimeISO!
  userId: Int!
}

input UserAddressListRelationFilter {
  every: UserAddressWhereInput
  none: UserAddressWhereInput
  some: UserAddressWhereInput
}

type UserAddressMaxAggregate {
  addressId: Int
  createdAt: DateTimeISO
  id: Int
  updatedAt: DateTimeISO
  userId: Int
}

input UserAddressMaxOrderByAggregateInput {
  addressId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

type UserAddressMinAggregate {
  addressId: Int
  createdAt: DateTimeISO
  id: Int
  updatedAt: DateTimeISO
  userId: Int
}

input UserAddressMinOrderByAggregateInput {
  addressId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input UserAddressOrderByRelationAggregateInput {
  _count: SortOrder
}

input UserAddressOrderByWithAggregationInput {
  _avg: UserAddressAvgOrderByAggregateInput
  _count: UserAddressCountOrderByAggregateInput
  _max: UserAddressMaxOrderByAggregateInput
  _min: UserAddressMinOrderByAggregateInput
  _sum: UserAddressSumOrderByAggregateInput
  addressId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input UserAddressOrderByWithRelationInput {
  address: AddressOrderByWithRelationInput
  addressId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  updatedAt: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

enum UserAddressScalarFieldEnum {
  addressId
  createdAt
  id
  updatedAt
  userId
}

input UserAddressScalarWhereInput {
  AND: [UserAddressScalarWhereInput!]
  NOT: [UserAddressScalarWhereInput!]
  OR: [UserAddressScalarWhereInput!]
  addressId: IntFilter
  createdAt: DateTimeFilter
  id: IntFilter
  updatedAt: DateTimeFilter
  userId: IntFilter
}

input UserAddressScalarWhereWithAggregatesInput {
  AND: [UserAddressScalarWhereWithAggregatesInput!]
  NOT: [UserAddressScalarWhereWithAggregatesInput!]
  OR: [UserAddressScalarWhereWithAggregatesInput!]
  addressId: IntWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  userId: IntWithAggregatesFilter
}

type UserAddressSumAggregate {
  addressId: Int
  id: Int
  userId: Int
}

input UserAddressSumOrderByAggregateInput {
  addressId: SortOrder
  id: SortOrder
  userId: SortOrder
}

input UserAddressUpdateInput {
  address: AddressUpdateOneRequiredWithoutUsersNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutAddressesNestedInput
}

input UserAddressUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserAddressUpdateManyWithWhereWithoutAddressInput {
  data: UserAddressUpdateManyMutationInput!
  where: UserAddressScalarWhereInput!
}

input UserAddressUpdateManyWithWhereWithoutUserInput {
  data: UserAddressUpdateManyMutationInput!
  where: UserAddressScalarWhereInput!
}

input UserAddressUpdateManyWithoutAddressNestedInput {
  connect: [UserAddressWhereUniqueInput!]
  connectOrCreate: [UserAddressCreateOrConnectWithoutAddressInput!]
  create: [UserAddressCreateWithoutAddressInput!]
  createMany: UserAddressCreateManyAddressInputEnvelope
  delete: [UserAddressWhereUniqueInput!]
  deleteMany: [UserAddressScalarWhereInput!]
  disconnect: [UserAddressWhereUniqueInput!]
  set: [UserAddressWhereUniqueInput!]
  update: [UserAddressUpdateWithWhereUniqueWithoutAddressInput!]
  updateMany: [UserAddressUpdateManyWithWhereWithoutAddressInput!]
  upsert: [UserAddressUpsertWithWhereUniqueWithoutAddressInput!]
}

input UserAddressUpdateManyWithoutUserNestedInput {
  connect: [UserAddressWhereUniqueInput!]
  connectOrCreate: [UserAddressCreateOrConnectWithoutUserInput!]
  create: [UserAddressCreateWithoutUserInput!]
  createMany: UserAddressCreateManyUserInputEnvelope
  delete: [UserAddressWhereUniqueInput!]
  deleteMany: [UserAddressScalarWhereInput!]
  disconnect: [UserAddressWhereUniqueInput!]
  set: [UserAddressWhereUniqueInput!]
  update: [UserAddressUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [UserAddressUpdateManyWithWhereWithoutUserInput!]
  upsert: [UserAddressUpsertWithWhereUniqueWithoutUserInput!]
}

input UserAddressUpdateWithWhereUniqueWithoutAddressInput {
  data: UserAddressUpdateWithoutAddressInput!
  where: UserAddressWhereUniqueInput!
}

input UserAddressUpdateWithWhereUniqueWithoutUserInput {
  data: UserAddressUpdateWithoutUserInput!
  where: UserAddressWhereUniqueInput!
}

input UserAddressUpdateWithoutAddressInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutAddressesNestedInput
}

input UserAddressUpdateWithoutUserInput {
  address: AddressUpdateOneRequiredWithoutUsersNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserAddressUpsertWithWhereUniqueWithoutAddressInput {
  create: UserAddressCreateWithoutAddressInput!
  update: UserAddressUpdateWithoutAddressInput!
  where: UserAddressWhereUniqueInput!
}

input UserAddressUpsertWithWhereUniqueWithoutUserInput {
  create: UserAddressCreateWithoutUserInput!
  update: UserAddressUpdateWithoutUserInput!
  where: UserAddressWhereUniqueInput!
}

input UserAddressWhereInput {
  AND: [UserAddressWhereInput!]
  NOT: [UserAddressWhereInput!]
  OR: [UserAddressWhereInput!]
  address: AddressRelationFilter
  addressId: IntFilter
  createdAt: DateTimeFilter
  id: IntFilter
  updatedAt: DateTimeFilter
  user: UserRelationFilter
  userId: IntFilter
}

input UserAddressWhereUniqueInput {
  AND: [UserAddressWhereInput!]
  NOT: [UserAddressWhereInput!]
  OR: [UserAddressWhereInput!]
  address: AddressRelationFilter
  addressId: IntFilter
  createdAt: DateTimeFilter
  id: Int
  updatedAt: DateTimeFilter
  user: UserRelationFilter
  userId: IntFilter
}

type UserAvgAggregate {
  id: Float
}

input UserAvgOrderByAggregateInput {
  id: SortOrder
}

type UserCount {
  Account(where: AccountWhereInput): Int!
  ChatUser(where: ChatUserWhereInput): Int!
  Comment(where: CommentWhereInput): Int!
  Post(where: PostWhereInput): Int!
  Session(where: SessionWhereInput): Int!
  addresses(where: UserAddressWhereInput): Int!
  files(where: UserFileWhereInput): Int!
}

type UserCountAggregate {
  _all: Int!
  babyBirth: Int!
  content: Int!
  createdAt: Int!
  email: Int!
  emailVerified: Int!
  id: Int!
  image: Int!
  name: Int!
  role: Int!
  updatedAt: Int!
  username: Int!
}

input UserCountOrderByAggregateInput {
  babyBirth: SortOrder
  content: SortOrder
  createdAt: SortOrder
  email: SortOrder
  emailVerified: SortOrder
  id: SortOrder
  image: SortOrder
  name: SortOrder
  role: SortOrder
  updatedAt: SortOrder
  username: SortOrder
}

input UserCreateInput {
  Account: AccountCreateNestedManyWithoutUserInput
  ChatUser: ChatUserCreateNestedManyWithoutUserInput
  Comment: CommentCreateNestedManyWithoutUserInput
  Post: PostCreateNestedManyWithoutUserInput
  Session: SessionCreateNestedManyWithoutUserInput
  addresses: UserAddressCreateNestedManyWithoutUserInput
  babyBirth: DateTimeISO
  content: String
  createdAt: DateTimeISO
  email: String!
  emailVerified: DateTimeISO
  files: UserFileCreateNestedManyWithoutUserInput
  image: String
  name: String
  role: Role
  updatedAt: DateTimeISO
  username: String
}

input UserCreateManyInput {
  babyBirth: DateTimeISO
  content: String
  createdAt: DateTimeISO
  email: String!
  emailVerified: DateTimeISO
  id: Int
  image: String
  name: String
  role: Role
  updatedAt: DateTimeISO
  username: String
}

input UserCreateNestedOneWithoutAccountInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutAccountInput
  create: UserCreateWithoutAccountInput
}

input UserCreateNestedOneWithoutAddressesInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutAddressesInput
  create: UserCreateWithoutAddressesInput
}

input UserCreateNestedOneWithoutChatUserInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutChatUserInput
  create: UserCreateWithoutChatUserInput
}

input UserCreateNestedOneWithoutCommentInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutCommentInput
  create: UserCreateWithoutCommentInput
}

input UserCreateNestedOneWithoutFilesInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutFilesInput
  create: UserCreateWithoutFilesInput
}

input UserCreateNestedOneWithoutPostInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutPostInput
  create: UserCreateWithoutPostInput
}

input UserCreateNestedOneWithoutSessionInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutSessionInput
  create: UserCreateWithoutSessionInput
}

input UserCreateOrConnectWithoutAccountInput {
  create: UserCreateWithoutAccountInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutAddressesInput {
  create: UserCreateWithoutAddressesInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutChatUserInput {
  create: UserCreateWithoutChatUserInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutCommentInput {
  create: UserCreateWithoutCommentInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutFilesInput {
  create: UserCreateWithoutFilesInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutPostInput {
  create: UserCreateWithoutPostInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutSessionInput {
  create: UserCreateWithoutSessionInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutAccountInput {
  ChatUser: ChatUserCreateNestedManyWithoutUserInput
  Comment: CommentCreateNestedManyWithoutUserInput
  Post: PostCreateNestedManyWithoutUserInput
  Session: SessionCreateNestedManyWithoutUserInput
  addresses: UserAddressCreateNestedManyWithoutUserInput
  babyBirth: DateTimeISO
  content: String
  createdAt: DateTimeISO
  email: String!
  emailVerified: DateTimeISO
  files: UserFileCreateNestedManyWithoutUserInput
  image: String
  name: String
  role: Role
  updatedAt: DateTimeISO
  username: String
}

input UserCreateWithoutAddressesInput {
  Account: AccountCreateNestedManyWithoutUserInput
  ChatUser: ChatUserCreateNestedManyWithoutUserInput
  Comment: CommentCreateNestedManyWithoutUserInput
  Post: PostCreateNestedManyWithoutUserInput
  Session: SessionCreateNestedManyWithoutUserInput
  babyBirth: DateTimeISO
  content: String
  createdAt: DateTimeISO
  email: String!
  emailVerified: DateTimeISO
  files: UserFileCreateNestedManyWithoutUserInput
  image: String
  name: String
  role: Role
  updatedAt: DateTimeISO
  username: String
}

input UserCreateWithoutChatUserInput {
  Account: AccountCreateNestedManyWithoutUserInput
  Comment: CommentCreateNestedManyWithoutUserInput
  Post: PostCreateNestedManyWithoutUserInput
  Session: SessionCreateNestedManyWithoutUserInput
  addresses: UserAddressCreateNestedManyWithoutUserInput
  babyBirth: DateTimeISO
  content: String
  createdAt: DateTimeISO
  email: String!
  emailVerified: DateTimeISO
  files: UserFileCreateNestedManyWithoutUserInput
  image: String
  name: String
  role: Role
  updatedAt: DateTimeISO
  username: String
}

input UserCreateWithoutCommentInput {
  Account: AccountCreateNestedManyWithoutUserInput
  ChatUser: ChatUserCreateNestedManyWithoutUserInput
  Post: PostCreateNestedManyWithoutUserInput
  Session: SessionCreateNestedManyWithoutUserInput
  addresses: UserAddressCreateNestedManyWithoutUserInput
  babyBirth: DateTimeISO
  content: String
  createdAt: DateTimeISO
  email: String!
  emailVerified: DateTimeISO
  files: UserFileCreateNestedManyWithoutUserInput
  image: String
  name: String
  role: Role
  updatedAt: DateTimeISO
  username: String
}

input UserCreateWithoutFilesInput {
  Account: AccountCreateNestedManyWithoutUserInput
  ChatUser: ChatUserCreateNestedManyWithoutUserInput
  Comment: CommentCreateNestedManyWithoutUserInput
  Post: PostCreateNestedManyWithoutUserInput
  Session: SessionCreateNestedManyWithoutUserInput
  addresses: UserAddressCreateNestedManyWithoutUserInput
  babyBirth: DateTimeISO
  content: String
  createdAt: DateTimeISO
  email: String!
  emailVerified: DateTimeISO
  image: String
  name: String
  role: Role
  updatedAt: DateTimeISO
  username: String
}

input UserCreateWithoutPostInput {
  Account: AccountCreateNestedManyWithoutUserInput
  ChatUser: ChatUserCreateNestedManyWithoutUserInput
  Comment: CommentCreateNestedManyWithoutUserInput
  Session: SessionCreateNestedManyWithoutUserInput
  addresses: UserAddressCreateNestedManyWithoutUserInput
  babyBirth: DateTimeISO
  content: String
  createdAt: DateTimeISO
  email: String!
  emailVerified: DateTimeISO
  files: UserFileCreateNestedManyWithoutUserInput
  image: String
  name: String
  role: Role
  updatedAt: DateTimeISO
  username: String
}

input UserCreateWithoutSessionInput {
  Account: AccountCreateNestedManyWithoutUserInput
  ChatUser: ChatUserCreateNestedManyWithoutUserInput
  Comment: CommentCreateNestedManyWithoutUserInput
  Post: PostCreateNestedManyWithoutUserInput
  addresses: UserAddressCreateNestedManyWithoutUserInput
  babyBirth: DateTimeISO
  content: String
  createdAt: DateTimeISO
  email: String!
  emailVerified: DateTimeISO
  files: UserFileCreateNestedManyWithoutUserInput
  image: String
  name: String
  role: Role
  updatedAt: DateTimeISO
  username: String
}

type UserFile {
  createdAt: DateTimeISO!
  file: File!
  fileId: Int!
  id: ID!
  updatedAt: DateTimeISO!
  user: User!
  userId: Int!
}

type UserFileAvgAggregate {
  fileId: Float
  id: Float
  userId: Float
}

input UserFileAvgOrderByAggregateInput {
  fileId: SortOrder
  id: SortOrder
  userId: SortOrder
}

type UserFileCountAggregate {
  _all: Int!
  createdAt: Int!
  fileId: Int!
  id: Int!
  updatedAt: Int!
  userId: Int!
}

input UserFileCountOrderByAggregateInput {
  createdAt: SortOrder
  fileId: SortOrder
  id: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input UserFileCreateInput {
  createdAt: DateTimeISO
  file: FileCreateNestedOneWithoutUserFileInput!
  updatedAt: DateTimeISO
  user: UserCreateNestedOneWithoutFilesInput!
}

input UserFileCreateManyFileInput {
  createdAt: DateTimeISO
  id: Int
  updatedAt: DateTimeISO
  userId: Int!
}

input UserFileCreateManyFileInputEnvelope {
  data: [UserFileCreateManyFileInput!]!
  skipDuplicates: Boolean
}

input UserFileCreateManyInput {
  createdAt: DateTimeISO
  fileId: Int!
  id: Int
  updatedAt: DateTimeISO
  userId: Int!
}

input UserFileCreateManyUserInput {
  createdAt: DateTimeISO
  fileId: Int!
  id: Int
  updatedAt: DateTimeISO
}

input UserFileCreateManyUserInputEnvelope {
  data: [UserFileCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input UserFileCreateNestedManyWithoutFileInput {
  connect: [UserFileWhereUniqueInput!]
  connectOrCreate: [UserFileCreateOrConnectWithoutFileInput!]
  create: [UserFileCreateWithoutFileInput!]
  createMany: UserFileCreateManyFileInputEnvelope
}

input UserFileCreateNestedManyWithoutUserInput {
  connect: [UserFileWhereUniqueInput!]
  connectOrCreate: [UserFileCreateOrConnectWithoutUserInput!]
  create: [UserFileCreateWithoutUserInput!]
  createMany: UserFileCreateManyUserInputEnvelope
}

input UserFileCreateOrConnectWithoutFileInput {
  create: UserFileCreateWithoutFileInput!
  where: UserFileWhereUniqueInput!
}

input UserFileCreateOrConnectWithoutUserInput {
  create: UserFileCreateWithoutUserInput!
  where: UserFileWhereUniqueInput!
}

input UserFileCreateWithoutFileInput {
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  user: UserCreateNestedOneWithoutFilesInput!
}

input UserFileCreateWithoutUserInput {
  createdAt: DateTimeISO
  file: FileCreateNestedOneWithoutUserFileInput!
  updatedAt: DateTimeISO
}

type UserFileGroupBy {
  _avg: UserFileAvgAggregate
  _count: UserFileCountAggregate
  _max: UserFileMaxAggregate
  _min: UserFileMinAggregate
  _sum: UserFileSumAggregate
  createdAt: DateTimeISO!
  fileId: Int!
  id: Int!
  updatedAt: DateTimeISO!
  userId: Int!
}

input UserFileListRelationFilter {
  every: UserFileWhereInput
  none: UserFileWhereInput
  some: UserFileWhereInput
}

type UserFileMaxAggregate {
  createdAt: DateTimeISO
  fileId: Int
  id: Int
  updatedAt: DateTimeISO
  userId: Int
}

input UserFileMaxOrderByAggregateInput {
  createdAt: SortOrder
  fileId: SortOrder
  id: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

type UserFileMinAggregate {
  createdAt: DateTimeISO
  fileId: Int
  id: Int
  updatedAt: DateTimeISO
  userId: Int
}

input UserFileMinOrderByAggregateInput {
  createdAt: SortOrder
  fileId: SortOrder
  id: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input UserFileOrderByRelationAggregateInput {
  _count: SortOrder
}

input UserFileOrderByWithAggregationInput {
  _avg: UserFileAvgOrderByAggregateInput
  _count: UserFileCountOrderByAggregateInput
  _max: UserFileMaxOrderByAggregateInput
  _min: UserFileMinOrderByAggregateInput
  _sum: UserFileSumOrderByAggregateInput
  createdAt: SortOrder
  fileId: SortOrder
  id: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input UserFileOrderByWithRelationInput {
  createdAt: SortOrder
  file: FileOrderByWithRelationInput
  fileId: SortOrder
  id: SortOrder
  updatedAt: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

enum UserFileScalarFieldEnum {
  createdAt
  fileId
  id
  updatedAt
  userId
}

input UserFileScalarWhereInput {
  AND: [UserFileScalarWhereInput!]
  NOT: [UserFileScalarWhereInput!]
  OR: [UserFileScalarWhereInput!]
  createdAt: DateTimeFilter
  fileId: IntFilter
  id: IntFilter
  updatedAt: DateTimeFilter
  userId: IntFilter
}

input UserFileScalarWhereWithAggregatesInput {
  AND: [UserFileScalarWhereWithAggregatesInput!]
  NOT: [UserFileScalarWhereWithAggregatesInput!]
  OR: [UserFileScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  fileId: IntWithAggregatesFilter
  id: IntWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  userId: IntWithAggregatesFilter
}

type UserFileSumAggregate {
  fileId: Int
  id: Int
  userId: Int
}

input UserFileSumOrderByAggregateInput {
  fileId: SortOrder
  id: SortOrder
  userId: SortOrder
}

input UserFileUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  file: FileUpdateOneRequiredWithoutUserFileNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutFilesNestedInput
}

input UserFileUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserFileUpdateManyWithWhereWithoutFileInput {
  data: UserFileUpdateManyMutationInput!
  where: UserFileScalarWhereInput!
}

input UserFileUpdateManyWithWhereWithoutUserInput {
  data: UserFileUpdateManyMutationInput!
  where: UserFileScalarWhereInput!
}

input UserFileUpdateManyWithoutFileNestedInput {
  connect: [UserFileWhereUniqueInput!]
  connectOrCreate: [UserFileCreateOrConnectWithoutFileInput!]
  create: [UserFileCreateWithoutFileInput!]
  createMany: UserFileCreateManyFileInputEnvelope
  delete: [UserFileWhereUniqueInput!]
  deleteMany: [UserFileScalarWhereInput!]
  disconnect: [UserFileWhereUniqueInput!]
  set: [UserFileWhereUniqueInput!]
  update: [UserFileUpdateWithWhereUniqueWithoutFileInput!]
  updateMany: [UserFileUpdateManyWithWhereWithoutFileInput!]
  upsert: [UserFileUpsertWithWhereUniqueWithoutFileInput!]
}

input UserFileUpdateManyWithoutUserNestedInput {
  connect: [UserFileWhereUniqueInput!]
  connectOrCreate: [UserFileCreateOrConnectWithoutUserInput!]
  create: [UserFileCreateWithoutUserInput!]
  createMany: UserFileCreateManyUserInputEnvelope
  delete: [UserFileWhereUniqueInput!]
  deleteMany: [UserFileScalarWhereInput!]
  disconnect: [UserFileWhereUniqueInput!]
  set: [UserFileWhereUniqueInput!]
  update: [UserFileUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [UserFileUpdateManyWithWhereWithoutUserInput!]
  upsert: [UserFileUpsertWithWhereUniqueWithoutUserInput!]
}

input UserFileUpdateWithWhereUniqueWithoutFileInput {
  data: UserFileUpdateWithoutFileInput!
  where: UserFileWhereUniqueInput!
}

input UserFileUpdateWithWhereUniqueWithoutUserInput {
  data: UserFileUpdateWithoutUserInput!
  where: UserFileWhereUniqueInput!
}

input UserFileUpdateWithoutFileInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutFilesNestedInput
}

input UserFileUpdateWithoutUserInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  file: FileUpdateOneRequiredWithoutUserFileNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserFileUpsertWithWhereUniqueWithoutFileInput {
  create: UserFileCreateWithoutFileInput!
  update: UserFileUpdateWithoutFileInput!
  where: UserFileWhereUniqueInput!
}

input UserFileUpsertWithWhereUniqueWithoutUserInput {
  create: UserFileCreateWithoutUserInput!
  update: UserFileUpdateWithoutUserInput!
  where: UserFileWhereUniqueInput!
}

input UserFileWhereInput {
  AND: [UserFileWhereInput!]
  NOT: [UserFileWhereInput!]
  OR: [UserFileWhereInput!]
  createdAt: DateTimeFilter
  file: FileRelationFilter
  fileId: IntFilter
  id: IntFilter
  updatedAt: DateTimeFilter
  user: UserRelationFilter
  userId: IntFilter
}

input UserFileWhereUniqueInput {
  AND: [UserFileWhereInput!]
  NOT: [UserFileWhereInput!]
  OR: [UserFileWhereInput!]
  createdAt: DateTimeFilter
  file: FileRelationFilter
  fileId: IntFilter
  id: Int
  updatedAt: DateTimeFilter
  user: UserRelationFilter
  userId: IntFilter
}

type UserGroupBy {
  _avg: UserAvgAggregate
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  _sum: UserSumAggregate
  babyBirth: DateTimeISO
  content: String
  createdAt: DateTimeISO!
  email: String!
  emailVerified: DateTimeISO
  id: Int!
  image: String
  name: String
  role: Role!
  updatedAt: DateTimeISO!
  username: String
}

type UserMaxAggregate {
  babyBirth: DateTimeISO
  content: String
  createdAt: DateTimeISO
  email: String
  emailVerified: DateTimeISO
  id: Int
  image: String
  name: String
  role: Role
  updatedAt: DateTimeISO
  username: String
}

input UserMaxOrderByAggregateInput {
  babyBirth: SortOrder
  content: SortOrder
  createdAt: SortOrder
  email: SortOrder
  emailVerified: SortOrder
  id: SortOrder
  image: SortOrder
  name: SortOrder
  role: SortOrder
  updatedAt: SortOrder
  username: SortOrder
}

type UserMinAggregate {
  babyBirth: DateTimeISO
  content: String
  createdAt: DateTimeISO
  email: String
  emailVerified: DateTimeISO
  id: Int
  image: String
  name: String
  role: Role
  updatedAt: DateTimeISO
  username: String
}

input UserMinOrderByAggregateInput {
  babyBirth: SortOrder
  content: SortOrder
  createdAt: SortOrder
  email: SortOrder
  emailVerified: SortOrder
  id: SortOrder
  image: SortOrder
  name: SortOrder
  role: SortOrder
  updatedAt: SortOrder
  username: SortOrder
}

input UserOrderByWithAggregationInput {
  _avg: UserAvgOrderByAggregateInput
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  _sum: UserSumOrderByAggregateInput
  babyBirth: SortOrderInput
  content: SortOrderInput
  createdAt: SortOrder
  email: SortOrder
  emailVerified: SortOrderInput
  id: SortOrder
  image: SortOrderInput
  name: SortOrderInput
  role: SortOrder
  updatedAt: SortOrder
  username: SortOrderInput
}

input UserOrderByWithRelationInput {
  Account: AccountOrderByRelationAggregateInput
  ChatUser: ChatUserOrderByRelationAggregateInput
  Comment: CommentOrderByRelationAggregateInput
  Post: PostOrderByRelationAggregateInput
  Session: SessionOrderByRelationAggregateInput
  addresses: UserAddressOrderByRelationAggregateInput
  babyBirth: SortOrderInput
  content: SortOrderInput
  createdAt: SortOrder
  email: SortOrder
  emailVerified: SortOrderInput
  files: UserFileOrderByRelationAggregateInput
  id: SortOrder
  image: SortOrderInput
  name: SortOrderInput
  role: SortOrder
  updatedAt: SortOrder
  username: SortOrderInput
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  babyBirth
  content
  createdAt
  email
  emailVerified
  id
  image
  name
  role
  updatedAt
  username
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  babyBirth: DateTimeNullableWithAggregatesFilter
  content: StringNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  email: StringWithAggregatesFilter
  emailVerified: DateTimeNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  image: StringNullableWithAggregatesFilter
  name: StringNullableWithAggregatesFilter
  role: EnumRoleWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  username: StringNullableWithAggregatesFilter
}

type UserSumAggregate {
  id: Int
}

input UserSumOrderByAggregateInput {
  id: SortOrder
}

input UserUpdateInput {
  Account: AccountUpdateManyWithoutUserNestedInput
  ChatUser: ChatUserUpdateManyWithoutUserNestedInput
  Comment: CommentUpdateManyWithoutUserNestedInput
  Post: PostUpdateManyWithoutUserNestedInput
  Session: SessionUpdateManyWithoutUserNestedInput
  addresses: UserAddressUpdateManyWithoutUserNestedInput
  babyBirth: NullableDateTimeFieldUpdateOperationsInput
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  files: UserFileUpdateManyWithoutUserNestedInput
  image: NullableStringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  username: NullableStringFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  babyBirth: NullableDateTimeFieldUpdateOperationsInput
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  username: NullableStringFieldUpdateOperationsInput
}

input UserUpdateOneRequiredWithoutAccountNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutAccountInput
  create: UserCreateWithoutAccountInput
  update: UserUpdateToOneWithWhereWithoutAccountInput
  upsert: UserUpsertWithoutAccountInput
}

input UserUpdateOneRequiredWithoutAddressesNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutAddressesInput
  create: UserCreateWithoutAddressesInput
  update: UserUpdateToOneWithWhereWithoutAddressesInput
  upsert: UserUpsertWithoutAddressesInput
}

input UserUpdateOneRequiredWithoutChatUserNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutChatUserInput
  create: UserCreateWithoutChatUserInput
  update: UserUpdateToOneWithWhereWithoutChatUserInput
  upsert: UserUpsertWithoutChatUserInput
}

input UserUpdateOneRequiredWithoutCommentNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutCommentInput
  create: UserCreateWithoutCommentInput
  update: UserUpdateToOneWithWhereWithoutCommentInput
  upsert: UserUpsertWithoutCommentInput
}

input UserUpdateOneRequiredWithoutFilesNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutFilesInput
  create: UserCreateWithoutFilesInput
  update: UserUpdateToOneWithWhereWithoutFilesInput
  upsert: UserUpsertWithoutFilesInput
}

input UserUpdateOneRequiredWithoutPostNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutPostInput
  create: UserCreateWithoutPostInput
  update: UserUpdateToOneWithWhereWithoutPostInput
  upsert: UserUpsertWithoutPostInput
}

input UserUpdateOneRequiredWithoutSessionNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutSessionInput
  create: UserCreateWithoutSessionInput
  update: UserUpdateToOneWithWhereWithoutSessionInput
  upsert: UserUpsertWithoutSessionInput
}

input UserUpdateToOneWithWhereWithoutAccountInput {
  data: UserUpdateWithoutAccountInput!
  where: UserWhereInput
}

input UserUpdateToOneWithWhereWithoutAddressesInput {
  data: UserUpdateWithoutAddressesInput!
  where: UserWhereInput
}

input UserUpdateToOneWithWhereWithoutChatUserInput {
  data: UserUpdateWithoutChatUserInput!
  where: UserWhereInput
}

input UserUpdateToOneWithWhereWithoutCommentInput {
  data: UserUpdateWithoutCommentInput!
  where: UserWhereInput
}

input UserUpdateToOneWithWhereWithoutFilesInput {
  data: UserUpdateWithoutFilesInput!
  where: UserWhereInput
}

input UserUpdateToOneWithWhereWithoutPostInput {
  data: UserUpdateWithoutPostInput!
  where: UserWhereInput
}

input UserUpdateToOneWithWhereWithoutSessionInput {
  data: UserUpdateWithoutSessionInput!
  where: UserWhereInput
}

input UserUpdateWithoutAccountInput {
  ChatUser: ChatUserUpdateManyWithoutUserNestedInput
  Comment: CommentUpdateManyWithoutUserNestedInput
  Post: PostUpdateManyWithoutUserNestedInput
  Session: SessionUpdateManyWithoutUserNestedInput
  addresses: UserAddressUpdateManyWithoutUserNestedInput
  babyBirth: NullableDateTimeFieldUpdateOperationsInput
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  files: UserFileUpdateManyWithoutUserNestedInput
  image: NullableStringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  username: NullableStringFieldUpdateOperationsInput
}

input UserUpdateWithoutAddressesInput {
  Account: AccountUpdateManyWithoutUserNestedInput
  ChatUser: ChatUserUpdateManyWithoutUserNestedInput
  Comment: CommentUpdateManyWithoutUserNestedInput
  Post: PostUpdateManyWithoutUserNestedInput
  Session: SessionUpdateManyWithoutUserNestedInput
  babyBirth: NullableDateTimeFieldUpdateOperationsInput
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  files: UserFileUpdateManyWithoutUserNestedInput
  image: NullableStringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  username: NullableStringFieldUpdateOperationsInput
}

input UserUpdateWithoutChatUserInput {
  Account: AccountUpdateManyWithoutUserNestedInput
  Comment: CommentUpdateManyWithoutUserNestedInput
  Post: PostUpdateManyWithoutUserNestedInput
  Session: SessionUpdateManyWithoutUserNestedInput
  addresses: UserAddressUpdateManyWithoutUserNestedInput
  babyBirth: NullableDateTimeFieldUpdateOperationsInput
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  files: UserFileUpdateManyWithoutUserNestedInput
  image: NullableStringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  username: NullableStringFieldUpdateOperationsInput
}

input UserUpdateWithoutCommentInput {
  Account: AccountUpdateManyWithoutUserNestedInput
  ChatUser: ChatUserUpdateManyWithoutUserNestedInput
  Post: PostUpdateManyWithoutUserNestedInput
  Session: SessionUpdateManyWithoutUserNestedInput
  addresses: UserAddressUpdateManyWithoutUserNestedInput
  babyBirth: NullableDateTimeFieldUpdateOperationsInput
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  files: UserFileUpdateManyWithoutUserNestedInput
  image: NullableStringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  username: NullableStringFieldUpdateOperationsInput
}

input UserUpdateWithoutFilesInput {
  Account: AccountUpdateManyWithoutUserNestedInput
  ChatUser: ChatUserUpdateManyWithoutUserNestedInput
  Comment: CommentUpdateManyWithoutUserNestedInput
  Post: PostUpdateManyWithoutUserNestedInput
  Session: SessionUpdateManyWithoutUserNestedInput
  addresses: UserAddressUpdateManyWithoutUserNestedInput
  babyBirth: NullableDateTimeFieldUpdateOperationsInput
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  image: NullableStringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  username: NullableStringFieldUpdateOperationsInput
}

input UserUpdateWithoutPostInput {
  Account: AccountUpdateManyWithoutUserNestedInput
  ChatUser: ChatUserUpdateManyWithoutUserNestedInput
  Comment: CommentUpdateManyWithoutUserNestedInput
  Session: SessionUpdateManyWithoutUserNestedInput
  addresses: UserAddressUpdateManyWithoutUserNestedInput
  babyBirth: NullableDateTimeFieldUpdateOperationsInput
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  files: UserFileUpdateManyWithoutUserNestedInput
  image: NullableStringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  username: NullableStringFieldUpdateOperationsInput
}

input UserUpdateWithoutSessionInput {
  Account: AccountUpdateManyWithoutUserNestedInput
  ChatUser: ChatUserUpdateManyWithoutUserNestedInput
  Comment: CommentUpdateManyWithoutUserNestedInput
  Post: PostUpdateManyWithoutUserNestedInput
  addresses: UserAddressUpdateManyWithoutUserNestedInput
  babyBirth: NullableDateTimeFieldUpdateOperationsInput
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  emailVerified: NullableDateTimeFieldUpdateOperationsInput
  files: UserFileUpdateManyWithoutUserNestedInput
  image: NullableStringFieldUpdateOperationsInput
  name: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  username: NullableStringFieldUpdateOperationsInput
}

input UserUpsertWithoutAccountInput {
  create: UserCreateWithoutAccountInput!
  update: UserUpdateWithoutAccountInput!
  where: UserWhereInput
}

input UserUpsertWithoutAddressesInput {
  create: UserCreateWithoutAddressesInput!
  update: UserUpdateWithoutAddressesInput!
  where: UserWhereInput
}

input UserUpsertWithoutChatUserInput {
  create: UserCreateWithoutChatUserInput!
  update: UserUpdateWithoutChatUserInput!
  where: UserWhereInput
}

input UserUpsertWithoutCommentInput {
  create: UserCreateWithoutCommentInput!
  update: UserUpdateWithoutCommentInput!
  where: UserWhereInput
}

input UserUpsertWithoutFilesInput {
  create: UserCreateWithoutFilesInput!
  update: UserUpdateWithoutFilesInput!
  where: UserWhereInput
}

input UserUpsertWithoutPostInput {
  create: UserCreateWithoutPostInput!
  update: UserUpdateWithoutPostInput!
  where: UserWhereInput
}

input UserUpsertWithoutSessionInput {
  create: UserCreateWithoutSessionInput!
  update: UserUpdateWithoutSessionInput!
  where: UserWhereInput
}

input UserWhereInput {
  AND: [UserWhereInput!]
  Account: AccountListRelationFilter
  ChatUser: ChatUserListRelationFilter
  Comment: CommentListRelationFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  Post: PostListRelationFilter
  Session: SessionListRelationFilter
  addresses: UserAddressListRelationFilter
  babyBirth: DateTimeNullableFilter
  content: StringNullableFilter
  createdAt: DateTimeFilter
  email: StringFilter
  emailVerified: DateTimeNullableFilter
  files: UserFileListRelationFilter
  id: IntFilter
  image: StringNullableFilter
  name: StringNullableFilter
  role: EnumRoleFilter
  updatedAt: DateTimeFilter
  username: StringNullableFilter
}

input UserWhereUniqueInput {
  AND: [UserWhereInput!]
  Account: AccountListRelationFilter
  ChatUser: ChatUserListRelationFilter
  Comment: CommentListRelationFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  Post: PostListRelationFilter
  Session: SessionListRelationFilter
  addresses: UserAddressListRelationFilter
  babyBirth: DateTimeNullableFilter
  content: StringNullableFilter
  createdAt: DateTimeFilter
  email: String
  emailVerified: DateTimeNullableFilter
  files: UserFileListRelationFilter
  id: Int
  image: StringNullableFilter
  name: StringNullableFilter
  role: EnumRoleFilter
  updatedAt: DateTimeFilter
  username: StringNullableFilter
}

type VerificationToken {
  expires: DateTimeISO!
  identifier: String!
  token: String!
}

type VerificationTokenCountAggregate {
  _all: Int!
  expires: Int!
  identifier: Int!
  token: Int!
}

input VerificationTokenCountOrderByAggregateInput {
  expires: SortOrder
  identifier: SortOrder
  token: SortOrder
}

input VerificationTokenCreateInput {
  expires: DateTimeISO!
  identifier: String!
  token: String!
}

input VerificationTokenCreateManyInput {
  expires: DateTimeISO!
  identifier: String!
  token: String!
}

type VerificationTokenGroupBy {
  _count: VerificationTokenCountAggregate
  _max: VerificationTokenMaxAggregate
  _min: VerificationTokenMinAggregate
  expires: DateTimeISO!
  identifier: String!
  token: String!
}

input VerificationTokenIdentifierTokenCompoundUniqueInput {
  identifier: String!
  token: String!
}

type VerificationTokenMaxAggregate {
  expires: DateTimeISO
  identifier: String
  token: String
}

input VerificationTokenMaxOrderByAggregateInput {
  expires: SortOrder
  identifier: SortOrder
  token: SortOrder
}

type VerificationTokenMinAggregate {
  expires: DateTimeISO
  identifier: String
  token: String
}

input VerificationTokenMinOrderByAggregateInput {
  expires: SortOrder
  identifier: SortOrder
  token: SortOrder
}

input VerificationTokenOrderByWithAggregationInput {
  _count: VerificationTokenCountOrderByAggregateInput
  _max: VerificationTokenMaxOrderByAggregateInput
  _min: VerificationTokenMinOrderByAggregateInput
  expires: SortOrder
  identifier: SortOrder
  token: SortOrder
}

input VerificationTokenOrderByWithRelationInput {
  expires: SortOrder
  identifier: SortOrder
  token: SortOrder
}

enum VerificationTokenScalarFieldEnum {
  expires
  identifier
  token
}

input VerificationTokenScalarWhereWithAggregatesInput {
  AND: [VerificationTokenScalarWhereWithAggregatesInput!]
  NOT: [VerificationTokenScalarWhereWithAggregatesInput!]
  OR: [VerificationTokenScalarWhereWithAggregatesInput!]
  expires: DateTimeWithAggregatesFilter
  identifier: StringWithAggregatesFilter
  token: StringWithAggregatesFilter
}

input VerificationTokenUpdateInput {
  expires: DateTimeFieldUpdateOperationsInput
  identifier: StringFieldUpdateOperationsInput
  token: StringFieldUpdateOperationsInput
}

input VerificationTokenUpdateManyMutationInput {
  expires: DateTimeFieldUpdateOperationsInput
  identifier: StringFieldUpdateOperationsInput
  token: StringFieldUpdateOperationsInput
}

input VerificationTokenWhereInput {
  AND: [VerificationTokenWhereInput!]
  NOT: [VerificationTokenWhereInput!]
  OR: [VerificationTokenWhereInput!]
  expires: DateTimeFilter
  identifier: StringFilter
  token: StringFilter
}

input VerificationTokenWhereUniqueInput {
  AND: [VerificationTokenWhereInput!]
  NOT: [VerificationTokenWhereInput!]
  OR: [VerificationTokenWhereInput!]
  expires: DateTimeFilter
  identifier: StringFilter
  identifier_token: VerificationTokenIdentifierTokenCompoundUniqueInput
  token: StringFilter
}